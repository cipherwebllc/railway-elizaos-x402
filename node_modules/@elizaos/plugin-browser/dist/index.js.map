{"version":3,"sources":["../src/services/browser.ts","../src/index.ts"],"sourcesContent":["import {\n  type IAgentRuntime,\n  ModelType,\n  Service,\n  type ServiceTypeName,\n  ServiceType,\n  logger,\n  parseJSONObjectFromText,\n  stringToUuid,\n  trimTokens,\n} from '@elizaos/core';\nimport CaptchaSolver from 'capsolver-npm';\nimport { type Browser, type BrowserContext, type Page, chromium } from 'patchright';\n\n// Type for cached content\ninterface CachedContent {\n  url: string;\n  content: PageContent;\n}\n\n/**\n * Asynchronously generates a summary for a given text using a machine learning model.\n *\n * @param {IAgentRuntime} runtime - The runtime environment for the agent\n * @param {string} text - The text to generate a summary for\n * @returns {Promise<{ title: string; description: string }>} A promise that resolves to an object containing the generated title and summary\n */\nasync function generateSummary(\n  runtime: IAgentRuntime,\n  text: string\n): Promise<{ title: string; description: string }> {\n  // make sure text is under 128k characters\n  const trimmedText = await trimTokens(text, 100000, runtime);\n\n  const prompt = `Please generate a concise summary for the following text:\n\n  Text: \"\"\"\n  ${trimmedText}\n  \"\"\"\n\n  Respond with a JSON object in the following format:\n  \\`\\`\\`json\n  {\n    \"title\": \"Generated Title\",\n    \"summary\": \"Generated summary and/or description of the text\"\n  }\n  \\`\\`\\``;\n\n  const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n    prompt,\n  });\n\n  const parsedResponse = parseJSONObjectFromText(response);\n\n  if (parsedResponse?.title && parsedResponse?.summary) {\n    return {\n      title: parsedResponse.title,\n      description: parsedResponse.summary,\n    };\n  }\n\n  return {\n    title: '',\n    description: '',\n  };\n}\n\n/**\n * Represents the content of a page.\n * @typedef { Object } PageContent\n * @property { string } title - The title of the page.\n * @property { string } description - The description of the page.\n * @property { string } bodyContent - The main content of the page.\n */\ntype PageContent = {\n  title: string;\n  description: string;\n  bodyContent: string;\n};\n\n/**\n * Represents a BrowserService class that extends Service.\n * Provides methods for initializing browser, stopping browser, fetching page content, solving CAPTCHAs, detecting CAPTCHAs, and getting cache key.\n * @extends Service\n */\nexport class BrowserService extends Service {\n  private browser: Browser | undefined;\n  private context: BrowserContext | undefined;\n  private captchaSolver: CaptchaSolver;\n  private cacheKey = 'content/browser';\n\n  static serviceType: ServiceTypeName = ServiceType.BROWSER;\n  capabilityDescription = 'The agent is able to browse the web and fetch content';\n\n  /**\n   * Constructor for the Agent class.\n   * @param {IAgentRuntime} runtime - The runtime object for the agent.\n   */\n  constructor(runtime: IAgentRuntime) {\n    super();\n    this.runtime = runtime;\n    this.browser = undefined;\n    this.context = undefined;\n    this.captchaSolver = new CaptchaSolver(runtime.getSetting('CAPSOLVER_API_KEY') || '');\n  }\n\n  /**\n   * Starts the BrowserService asynchronously.\n   *\n   * @param {IAgentRuntime} runtime - The runtime for the agent.\n   * @returns {Promise<BrowserService>} A promise that resolves to the initialized BrowserService.\n   */\n  static async start(runtime: IAgentRuntime): Promise<BrowserService> {\n    const service = new BrowserService(runtime);\n    await service.initializeBrowser();\n    return service;\n  }\n\n  /**\n   * Function to stop the browser service asynchronously.\n   *\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   */\n  static async stop(runtime: IAgentRuntime) {\n    const service = runtime.getService(ServiceType.BROWSER);\n    if (service) {\n      await service.stop();\n    }\n  }\n\n  /**\n   * Initializes the browser by launching Chromium with specified options and setting the user agent based on the platform.\n   * @returns {Promise<void>} A promise that resolves once the browser is successfully initialized.\n   */\n  async initializeBrowser() {\n    if (!this.browser) {\n      this.browser = await chromium.launch({\n        headless: true,\n        args: [\n          '--disable-dev-shm-usage', // Uses /tmp instead of /dev/shm. Prevents memory issues on low-memory systems\n          '--block-new-web-contents', // Prevents creation of new windows/tabs\n        ],\n      });\n\n      const platform = process.platform;\n      let userAgent = '';\n\n      // Change the user agent to match the platform to reduce bot detection\n      switch (platform) {\n        case 'darwin':\n          userAgent =\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';\n          break;\n        case 'win32':\n          userAgent =\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';\n          break;\n        case 'linux':\n          userAgent =\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';\n          break;\n        default:\n          userAgent =\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';\n      }\n\n      this.context = await this.browser.newContext({\n        userAgent,\n        acceptDownloads: false,\n      });\n    }\n  }\n\n  /**\n   * Asynchronously stops the browser and context if they are currently running.\n   */\n  async stop() {\n    if (this.context) {\n      await this.context.close();\n      this.context = undefined;\n    }\n    if (this.browser) {\n      await this.browser.close();\n      this.browser = undefined;\n    }\n  }\n\n  /**\n   * Asynchronously fetches the content of a web page.\n   *\n   * @param {string} url - The URL of the web page to fetch content from.\n   * @param {IAgentRuntime} runtime - The runtime environment for the web scraping agent.\n   * @returns {Promise<PageContent>} A Promise that resolves with the content of the web page.\n   */\n  async getPageContent(url: string, runtime: IAgentRuntime): Promise<PageContent> {\n    await this.initializeBrowser();\n    return await this.fetchPageContent(url, runtime);\n  }\n\n  /**\n   * Generates a cache key for the provided URL by converting it to a UUID string.\n   *\n   * @param {string} url - The URL for which a cache key is being generated.\n   * @returns {string} A UUID string representing the cache key for the URL.\n   */\n  private getCacheKey(url: string): string {\n    return stringToUuid(url);\n  }\n\n  /**\n   * Fetches the content of a page from the specified URL using a headless browser.\n   *\n   * @param {string} url - The URL of the page to fetch the content from.\n   * @param {IAgentRuntime} runtime - The runtime environment for the agent.\n   * @returns {Promise<PageContent>} A promise that resolves to the content of the fetched page.\n   */\n  private async fetchPageContent(url: string, runtime: IAgentRuntime): Promise<PageContent> {\n    const cacheKey = this.getCacheKey(url);\n    const cached = await runtime.getCache<CachedContent>(`${this.cacheKey}/${cacheKey}`);\n\n    if (cached) {\n      return cached.content;\n    }\n\n    let page: Page | undefined;\n\n    try {\n      if (!this.context) {\n        logger.log('Browser context not initialized. Call initializeBrowser() first.');\n        throw new Error('Browser context not initialized');\n      }\n\n      page = await this.context.newPage();\n\n      // Enable stealth mode\n      await page.setExtraHTTPHeaders({\n        'Accept-Language': 'en-US,en;q=0.9',\n      });\n\n      const response = await page.goto(url, { waitUntil: 'networkidle' });\n\n      if (!response) {\n        logger.error('Failed to load the page');\n        throw new Error('Failed to load the page');\n      }\n\n      if (response.status() === 403 || response.status() === 404) {\n        return await this.tryAlternativeSources(url, runtime);\n      }\n\n      // Check for CAPTCHA\n      const captchaDetected = await this.detectCaptcha(page);\n      if (captchaDetected) {\n        await this.solveCaptcha(page, url);\n      }\n      const documentTitle = await page.evaluate(() => document.title);\n      const bodyContent = await page.evaluate(() => document.body.innerText);\n      const { title: parsedTitle, description } = await generateSummary(\n        runtime,\n        `${documentTitle}\\n${bodyContent}`\n      );\n      const content = { title: parsedTitle, description, bodyContent };\n      await runtime.setCache<CachedContent>(`${this.cacheKey}/${cacheKey}`, {\n        url,\n        content,\n      });\n      return content;\n    } catch (error) {\n      logger.error('Error:', error);\n      return {\n        title: url,\n        description: 'Error, could not fetch content',\n        bodyContent: '',\n      };\n    } finally {\n      if (page) {\n        await page.close();\n      }\n    }\n  }\n\n  /**\n   * Detects if a captcha is present on the page based on the specified selectors.\n   *\n   * @param {Page} page The Puppeteer page to check for captcha.\n   * @returns {Promise<boolean>} A boolean indicating whether a captcha was detected.\n   */\n  private async detectCaptcha(page: Page): Promise<boolean> {\n    const captchaSelectors = [\n      'iframe[src*=\"captcha\"]',\n      'div[class*=\"captcha\"]',\n      '#captcha',\n      '.g-recaptcha',\n      '.h-captcha',\n    ];\n\n    for (const selector of captchaSelectors) {\n      const element = await page.$(selector);\n      if (element) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Solves the CAPTCHA challenge on the provided page using either hCaptcha or reCaptcha.\n   *\n   * @param {Page} page - The page where the CAPTCHA challenge needs to be solved.\n   * @param {string} url - The URL of the website with the CAPTCHA challenge.\n   * @returns {Promise<void>} - A promise that resolves once the CAPTCHA is solved.\n   */\n  private async solveCaptcha(page: Page, url: string): Promise<void> {\n    try {\n      const hcaptchaKey = await this.getHCaptchaWebsiteKey(page);\n      if (hcaptchaKey) {\n        const solution = await this.captchaSolver.hcaptchaProxyless({\n          websiteURL: url,\n          websiteKey: hcaptchaKey,\n        });\n        await page.evaluate((token) => {\n          // eslint-disable-next-line\n          // @ts-ignore\n          window.hcaptcha.setResponse(token);\n        }, solution.gRecaptchaResponse);\n        return;\n      }\n\n      const recaptchaKey = await this.getReCaptchaWebsiteKey(page);\n      if (recaptchaKey) {\n        const solution = await this.captchaSolver.recaptchaV2Proxyless({\n          websiteURL: url,\n          websiteKey: recaptchaKey,\n        });\n        await page.evaluate((token) => {\n          // eslint-disable-next-line\n          // @ts-ignore\n          document.getElementById('g-recaptcha-response').innerHTML = token;\n        }, solution.gRecaptchaResponse);\n      }\n    } catch (error) {\n      logger.error('Error solving CAPTCHA:', error);\n    }\n  }\n\n  /**\n   * Get the hCaptcha website key from the given Page\n   * @param {Page} page - The Page object to extract the hCaptcha website key from\n   * @returns {Promise<string>} The hCaptcha website key\n   */\n  private async getHCaptchaWebsiteKey(page: Page): Promise<string> {\n    return page.evaluate(() => {\n      const hcaptchaIframe = document.querySelector('iframe[src*=\"hcaptcha.com\"]');\n      if (hcaptchaIframe) {\n        const src = hcaptchaIframe.getAttribute('src');\n        const match = src?.match(/sitekey=([^&]*)/);\n        return match ? match[1] : '';\n      }\n      return '';\n    });\n  }\n\n  /**\n   * Retrieves the ReCaptcha website key from a given page.\n   * @param {Page} page - The page to extract the ReCaptcha website key from.\n   * @returns {Promise<string>} The ReCaptcha website key, or an empty string if not found.\n   */\n  private async getReCaptchaWebsiteKey(page: Page): Promise<string> {\n    return page.evaluate(() => {\n      const recaptchaElement = document.querySelector('.g-recaptcha');\n      return recaptchaElement ? recaptchaElement.getAttribute('data-sitekey') || '' : '';\n    });\n  }\n\n  /**\n   * Try fetching content from alternative sources if the original source fails.\n   *\n   * @param {string} url - The URL of the content to fetch.\n   * @param {IAgentRuntime} runtime - The runtime environment.\n   * @returns {Promise<{ title: string; description: string; bodyContent: string }>} The fetched content with title, description, and body.\n   */\n  private async tryAlternativeSources(\n    url: string,\n    runtime: IAgentRuntime\n  ): Promise<{ title: string; description: string; bodyContent: string }> {\n    // because this (tryAlternativeSources) calls fetchPageContent\n    // and fetchPageContent calls tryAlternativeSources\n    // we need these url.matches to progress\n    // through the things to try\n    if (!url.match(/web.archive.org\\/web/)) {\n      // Try Internet Archive\n      const archiveUrl = `https://web.archive.org/web/${url}`;\n      try {\n        return await this.fetchPageContent(archiveUrl, runtime);\n      } catch (error) {\n        logger.error('Error fetching from Internet Archive:', error);\n      }\n    }\n\n    if (!url.match(/www.google.com\\/search/)) {\n      // Try Google Search as a last resort\n      const googleSearchUrl = `https://www.google.com/search?q=${encodeURIComponent(url)}`;\n      try {\n        return await this.fetchPageContent(googleSearchUrl, runtime);\n      } catch (error) {\n        logger.error('Error fetching from Google Search:', error);\n        logger.error('Failed to fetch content from alternative sources');\n      }\n    }\n\n    // Return error content if all alternatives fail\n    return {\n      title: url,\n      description: 'Error, could not fetch content from alternative sources',\n      bodyContent: '',\n    };\n  }\n}\n","import type { Plugin , IAgentRuntime} from \"@elizaos/core\";\n\nimport { BrowserService } from \"./services/browser\";\n\nexport const browserPlugin: Plugin = {\n  name: \"browser-plugin\",\n  description: \"Plugin for browser actions\",\n  services: [BrowserService],\n  actions: [],\n  tests: [\n    {\n      name: \"test browser service\",\n      tests: [\n        {\n          name: \"Browser service initialization\",\n          fn: async (runtime: IAgentRuntime) => {\n            const service = await BrowserService.start(runtime);\n            if (!service) {\n              throw new Error(\"Failed to initialize BrowserService\");\n            }\n          },\n        },\n      ],\n    }\n  ],\n};\n"],"mappings":"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","names":[]}