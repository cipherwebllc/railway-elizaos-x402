var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};

// src/error/base.ts
var PythError;
var init_base = __esm({
  "src/error/base.ts"() {
    "use strict";
    PythError = class extends Error {
      constructor(code, message, severity = "MEDIUM" /* MEDIUM */, details, originalError) {
        super(message);
        this.code = code;
        this.message = message;
        this.severity = severity;
        this.details = details;
        this.originalError = originalError;
        this.timestamp = Date.now();
        Object.setPrototypeOf(this, new.target.prototype);
      }
      timestamp;
      name = "PythError";
      toJSON() {
        return {
          name: this.name,
          code: this.code,
          message: this.message,
          severity: this.severity,
          timestamp: this.timestamp,
          details: this.details,
          stack: this.stack,
          originalError: this.originalError ? {
            name: this.originalError.name,
            message: this.originalError.message,
            stack: this.originalError.stack
          } : void 0
        };
      }
    };
  }
});

// src/error/websocket.ts
var init_websocket = __esm({
  "src/error/websocket.ts"() {
    "use strict";
    init_base();
  }
});

// src/error/data.ts
var DataError;
var init_data = __esm({
  "src/error/data.ts"() {
    "use strict";
    init_base();
    DataError = class _DataError extends PythError {
      name = "DataError";
      constructor(code, message, severity = "MEDIUM" /* MEDIUM */, details, originalError) {
        super(code, message, severity, details, originalError);
        Object.setPrototypeOf(this, new.target.prototype);
      }
      // Factory methods
      static invalidSubscription(subscription, reason) {
        return new _DataError(
          "DATA_INVALID_SUBSCRIPTION" /* INVALID_SUBSCRIPTION */,
          "Invalid subscription parameters",
          "MEDIUM" /* MEDIUM */,
          { subscription, reason }
        );
      }
      static subscriptionLimitExceeded(currentCount, maxLimit) {
        return new _DataError(
          "DATA_SUBSCRIPTION_LIMIT" /* SUBSCRIPTION_LIMIT */,
          `Subscription limit exceeded (${currentCount}/${maxLimit})`,
          "HIGH" /* HIGH */,
          { currentCount, maxLimit }
        );
      }
      static validationFailed(data, validationErrors) {
        return new _DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Data validation failed",
          "MEDIUM" /* MEDIUM */,
          { data, validationErrors }
        );
      }
      static sequenceError(expected, received, details) {
        return new _DataError(
          "DATA_SEQUENCE_ERROR" /* SEQUENCE_ERROR */,
          `Message sequence error: expected ${expected}, received ${received}`,
          "MEDIUM" /* MEDIUM */,
          { expected, received, ...details }
        );
      }
      static transformError(data, targetFormat, error) {
        return new _DataError(
          "DATA_TRANSFORM_ERROR" /* TRANSFORM_ERROR */,
          "Failed to transform data",
          "MEDIUM" /* MEDIUM */,
          { data, targetFormat },
          error
        );
      }
      static schemaError(data, schema, error) {
        return new _DataError(
          "DATA_SCHEMA_ERROR" /* SCHEMA_ERROR */,
          "Data does not match schema",
          "HIGH" /* HIGH */,
          { data, schema },
          error
        );
      }
      static stalePriceError(symbol, lastUpdateTime, maxAge) {
        return new _DataError(
          "DATA_STALE_PRICE" /* STALE_PRICE */,
          `Price data for ${symbol} is stale`,
          "HIGH" /* HIGH */,
          {
            symbol,
            lastUpdateTime,
            maxAge,
            currentTime: Date.now()
          }
        );
      }
      static chainError(chain, operation, error) {
        return new _DataError(
          "DATA_CHAIN_ERROR" /* CHAIN_DATA_ERROR */,
          `Chain-specific error on ${chain} during ${operation}`,
          "HIGH" /* HIGH */,
          { chain, operation },
          error
        );
      }
    };
  }
});

// src/error/runtime.ts
var init_runtime = __esm({
  "src/error/runtime.ts"() {
    "use strict";
    init_base();
  }
});

// src/index.ts
import chalk from "chalk";
import Table from "cli-table3";
import ora from "ora";

// src/actions/actionGetPriceFeeds.ts
import { elizaLogger as elizaLogger2 } from "@elizaos/core";
import { HermesClient } from "@pythnetwork/hermes-client";

// src/error/index.ts
init_base();
init_websocket();
init_data();
init_runtime();

// src/environment.ts
import { z } from "zod";
var ENV = "mainnet";
var PYTH_NETWORKS = {
  mainnet: {
    hermes: process.env.PYTH_MAINNET_HERMES_URL || "https://hermes.pyth.network",
    wss: process.env.PYTH_MAINNET_WSS_URL || "wss://hermes.pyth.network/ws",
    pythnet: process.env.PYTH_MAINNET_PYTHNET_URL || "https://pythnet.rpcpool.com",
    contractRegistry: process.env.PYTH_MAINNET_CONTRACT_REGISTRY || "https://pyth.network/developers/price-feed-ids",
    programKey: process.env.PYTH_MAINNET_PROGRAM_KEY || "FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH"
  },
  testnet: {
    hermes: process.env.PYTH_TESTNET_HERMES_URL || "https://hermes-beta.pyth.network",
    wss: process.env.PYTH_TESTNET_WSS_URL || "wss://hermes-beta.pyth.network/ws",
    pythnet: process.env.PYTH_TESTNET_PYTHNET_URL || "https://api.devnet.solana.com",
    contractRegistry: process.env.PYTH_TESTNET_CONTRACT_REGISTRY || "https://pyth.network/developers/price-feed-ids#testnet",
    programKey: process.env.PYTH_TESTNET_PROGRAM_KEY || "FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH"
  }
};
var pythEnvSchema = z.object({
  PYTH_NETWORK_ENV: z.enum(["mainnet", "testnet"]).default("mainnet"),
  PYTH_MAX_RETRIES: z.string().transform(Number).default("3"),
  PYTH_RETRY_DELAY: z.string().transform(Number).default("1000"),
  PYTH_TIMEOUT: z.string().transform(Number).default("5000"),
  PYTH_GRANULAR_LOG: z.boolean().default(true),
  PYTH_LOG_LEVEL: z.enum(["error", "warn", "info", "debug"]).default("info"),
  RUNTIME_CHECK_MODE: z.boolean().default(false),
  PYTH_ENABLE_PRICE_STREAMING: z.boolean().default(true),
  PYTH_MAX_PRICE_STREAMS: z.string().transform(Number).default("10"),
  PYTH_TEST_ID01: z.string().default(
    "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43"
  ),
  PYTH_TEST_ID02: z.string().default(
    "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace"
  )
});
function getConfig(env = process.env.PYTH_NETWORK_ENV || ENV) {
  const network = env || "mainnet";
  ENV = network;
  const maxRetries = process.env.PYTH_MAX_RETRIES ? Number(process.env.PYTH_MAX_RETRIES) : 3;
  const retryDelay = process.env.PYTH_RETRY_DELAY ? Number(process.env.PYTH_RETRY_DELAY) : 1e3;
  const timeout = process.env.PYTH_TIMEOUT ? Number(process.env.PYTH_TIMEOUT) : 5e3;
  const maxPriceStreams = process.env.PYTH_MAX_PRICE_STREAMS ? Number(process.env.PYTH_MAX_PRICE_STREAMS) : 10;
  return {
    PYTH_NETWORK_ENV: network,
    PYTH_MAX_RETRIES: isNaN(maxRetries) ? 3 : maxRetries,
    PYTH_RETRY_DELAY: isNaN(retryDelay) ? 1e3 : retryDelay,
    PYTH_TIMEOUT: isNaN(timeout) ? 5e3 : timeout,
    PYTH_GRANULAR_LOG: process.env.PYTH_GRANULAR_LOG === "true",
    PYTH_LOG_LEVEL: process.env.PYTH_LOG_LEVEL || "info",
    RUNTIME_CHECK_MODE: process.env.RUNTIME_CHECK_MODE === "true",
    PYTH_ENABLE_PRICE_STREAMING: process.env.PYTH_ENABLE_PRICE_STREAMING !== "false",
    PYTH_MAX_PRICE_STREAMS: isNaN(maxPriceStreams) ? 10 : maxPriceStreams,
    PYTH_TEST_ID01: process.env.PYTH_TEST_ID01 || "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
    PYTH_TEST_ID02: process.env.PYTH_TEST_ID02 || "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace"
  };
}
async function validatePythConfig(runtime) {
  try {
    const networkEnv = runtime.getSetting("PYTH_NETWORK_ENV") || process.env.PYTH_NETWORK_ENV || "mainnet";
    const maxRetries = runtime.getSetting("PYTH_MAX_RETRIES") || process.env.PYTH_MAX_RETRIES || "3";
    const retryDelay = runtime.getSetting("PYTH_RETRY_DELAY") || process.env.PYTH_RETRY_DELAY || "1000";
    const logLevel = runtime.getSetting("PYTH_LOG_LEVEL") || process.env.PYTH_LOG_LEVEL || "info";
    const maxPriceStreams = runtime.getSetting("PYTH_MAX_PRICE_STREAMS") || process.env.PYTH_MAX_PRICE_STREAMS || "10";
    const config5 = {
      PYTH_NETWORK_ENV: networkEnv,
      PYTH_MAX_RETRIES: isNaN(Number(maxRetries)) ? 3 : Number(maxRetries),
      PYTH_RETRY_DELAY: isNaN(Number(retryDelay)) ? 1e3 : Number(retryDelay),
      PYTH_TIMEOUT: 5e3,
      PYTH_GRANULAR_LOG: process.env.PYTH_GRANULAR_LOG === "true",
      PYTH_LOG_LEVEL: ["error", "warn", "info", "debug"].includes(logLevel) ? logLevel : "info",
      RUNTIME_CHECK_MODE: process.env.RUNTIME_CHECK_MODE === "true",
      PYTH_ENABLE_PRICE_STREAMING: process.env.PYTH_ENABLE_PRICE_STREAMING !== "false",
      PYTH_MAX_PRICE_STREAMS: isNaN(Number(maxPriceStreams)) ? 10 : Number(maxPriceStreams),
      PYTH_TEST_ID01: process.env.PYTH_TEST_ID01 || "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
      PYTH_TEST_ID02: process.env.PYTH_TEST_ID02 || "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace"
    };
    return config5;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to validate Pyth configuration: ${errorMessage}`);
  }
}
var getNetworkConfig = (env = ENV) => {
  const network = env === "testnet" ? "testnet" : "mainnet";
  const config5 = PYTH_NETWORKS[network];
  return {
    hermes: config5.hermes,
    websocket: config5.wss,
    rpcEndpoint: config5.pythnet,
    contractAddress: config5.programKey
  };
};

// src/utils/priceFeedsValidation.ts
import { z as z2 } from "zod";
import { elizaLogger } from "@elizaos/core";
var priceFeedAttributesSchema = z2.object({
  asset_type: z2.string(),
  base: z2.string(),
  description: z2.string(),
  display_symbol: z2.string(),
  quote_currency: z2.string(),
  schedule: z2.string(),
  symbol: z2.string(),
  generic_symbol: z2.string().optional(),
  cms_symbol: z2.string().optional(),
  country: z2.string().optional(),
  cqs_symbol: z2.string().optional(),
  nasdaq_symbol: z2.string().optional(),
  contract_id: z2.string().optional()
});
var priceFeedsSchema = z2.object({
  text: z2.string(),
  query: z2.string().optional(),
  filter: z2.string().optional()
});
async function validatePriceFeedsData(content) {
  try {
    const result = await priceFeedsSchema.parseAsync(content);
    elizaLogger.debug("Price feeds validation passed", { result });
  } catch (error) {
    elizaLogger.error("Price feeds validation failed", { error });
    throw new DataError(
      "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
      "Price feeds validation failed",
      "HIGH" /* HIGH */,
      { error }
    );
  }
}

// src/actions/actionGetPriceFeeds.ts
var config = getConfig();
var GRANULAR_LOG = config.PYTH_GRANULAR_LOG;
var logGranular = (message, data) => {
  if (GRANULAR_LOG) {
    elizaLogger2.info(`[PriceFeeds] ${message}`, data);
    console.log(
      `[PriceFeeds] ${message}`,
      data ? JSON.stringify(data, null, 2) : ""
    );
  }
};
var getPriceFeedsAction = {
  name: "GET_PRICE_FEEDS",
  similes: ["FETCH_PRICE_FEEDS", "LIST_PRICE_FEEDS", "QUERY_PRICE_FEEDS"],
  description: "Retrieve price feeds from Pyth Network matching specific criteria",
  examples: [
    [
      {
        user: "user",
        name: "userMessage",
        content: {
          text: "Get all available price feeds from Pyth Network",
          query: "BTC",
          filter: "USD"
        }
      },
      {
        user: "assistant",
        name: "assistantMessage",
        content: {
          text: "Price feeds matching query BTC and filter USD",
          success: true,
          query: "BTC",
          filter: "USD",
          data: {
            feeds: [
              {
                id: "f9c0172ba10dfa4d19088d94f5bf61d3b54d5bd7483a322a982e1373ee8ea31b",
                attributes: {
                  asset_type: "Crypto",
                  base: "BTC",
                  description: "BITCOIN / US DOLLAR",
                  display_symbol: "BTC/USD",
                  generic_symbol: "BTCUSD",
                  quote_currency: "USD",
                  schedule: "America/New_York;O,O,O,O,O,O,O;",
                  symbol: "Crypto.BTC/USD"
                }
              }
            ]
          }
        }
      }
    ]
  ],
  async validate(runtime, message) {
    logGranular("Starting validation", {
      messageId: message.id,
      content: message.content
    });
    try {
      if (!message.content) {
        logGranular("Validation failed: no content");
        return false;
      }
      if (message.content.type !== "GET_PRICE_FEEDS") {
        return true;
      }
      const content = message.content;
      logGranular("Validating content structure", { content });
      try {
        await validatePriceFeedsData(content);
        logGranular("Schema validation passed");
      } catch (error) {
        logGranular("Schema validation error", { error });
        if (error instanceof DataError) {
          elizaLogger2.error("Schema validation failed", {
            errors: error.details?.errors
          });
          throw error;
        }
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Schema validation failed",
          "HIGH" /* HIGH */,
          { error }
        );
      }
      const config5 = await validatePythConfig(runtime);
      logGranular("Pyth config validation", { config: config5 });
      if (!config5) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Invalid Pyth configuration",
          "HIGH" /* HIGH */
        );
      }
      if (content.query && typeof content.query !== "string") {
        logGranular("Invalid query type", { query: content.query });
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Query must be a string",
          "HIGH" /* HIGH */
        );
      }
      if (content.filter && typeof content.filter !== "string") {
        logGranular("Invalid filter type", { filter: content.filter });
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Filter must be a string",
          "HIGH" /* HIGH */
        );
      }
      logGranular("Validation successful", {
        query: content.query,
        filter: content.filter
      });
      return true;
    } catch (error) {
      logGranular("Validation failed", {
        error: error instanceof Error ? {
          message: error.message,
          stack: error.stack,
          name: error.name
        } : String(error)
      });
      return false;
    }
  },
  async handler(runtime, message, state, _options = {}, callback) {
    logGranular("Starting handler execution", {
      messageId: message.id,
      hasCallback: !!callback
    });
    try {
      const messageContent = message.content;
      const { query, filter } = messageContent;
      logGranular("Processing request", { query, filter });
      const config5 = await validatePythConfig(runtime);
      logGranular("Got Pyth config", { networkEnv: config5.PYTH_NETWORK_ENV });
      const networkConfig = getNetworkConfig(config5.PYTH_NETWORK_ENV);
      logGranular("Network config", { networkConfig });
      const client = new HermesClient(networkConfig.hermes);
      logGranular("Initialized HermesClient", {
        endpoint: networkConfig.hermes
      });
      const options = {
        query,
        filter
      };
      logGranular("Fetching price feeds with options", {
        options,
        hermesEndpoint: networkConfig.hermes,
        clientType: typeof client.getPriceFeeds
      });
      const priceFeeds = await client.getPriceFeeds(options);
      if (!Array.isArray(priceFeeds)) {
        throw new Error("Invalid response from API: expected array of price feeds");
      }
      logGranular("Retrieved price feeds", {
        responseType: typeof priceFeeds,
        isArray: Array.isArray(priceFeeds),
        count: priceFeeds.length,
        sample: priceFeeds.slice(0, 3)
        // Log first 3 feeds for debugging
      });
      const transformedFeeds = priceFeeds.map((feed) => ({
        id: feed.id,
        attributes: {
          asset_type: feed.attributes?.asset_type || "Unknown",
          base: feed.attributes?.base || "Unknown",
          description: feed.attributes?.description || "Unknown",
          display_symbol: feed.attributes?.display_symbol || "Unknown",
          quote_currency: feed.attributes?.quote_currency || "Unknown",
          schedule: feed.attributes?.schedule || "",
          symbol: feed.attributes?.symbol || "Unknown",
          generic_symbol: feed.attributes?.generic_symbol,
          cms_symbol: feed.attributes?.cms_symbol,
          country: feed.attributes?.country,
          cqs_symbol: feed.attributes?.cqs_symbol,
          nasdaq_symbol: feed.attributes?.nasdaq_symbol,
          contract_id: feed.attributes?.contract_id
        }
      }));
      const callbackContent = {
        text: `Retrieved ${priceFeeds.length} price feeds:
${transformedFeeds.map(
          (feed) => `- ${feed.attributes.description} (${feed.attributes.display_symbol})
  Type: ${feed.attributes.asset_type}
  Base: ${feed.attributes.base}
  Quote: ${feed.attributes.quote_currency}
  Schedule: ${feed.attributes.schedule}
  ID: ${feed.id}`
        ).join("\n")}
${query ? `
Matching query: "${query}"` : ""}${filter ? `
With filter: "${filter}"` : ""}`,
        query,
        filter,
        success: true,
        data: {
          feeds: transformedFeeds,
          count: priceFeeds.length,
          responseType: "object",
          isArray: true
        }
      };
      logGranular("Prepared callback content", {
        feedCount: transformedFeeds.length,
        firstFeed: transformedFeeds[0]
      });
      if (callback) {
        logGranular("Executing callback");
        await callback(callbackContent);
        logGranular("Callback completed");
      }
      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      const errorStack = error instanceof Error ? error.stack : void 0;
      logGranular("Error retrieving price feeds", {
        error: errorMessage,
        stack: errorStack
      });
      const errorContent = {
        text: `Error: ${errorMessage}`,
        success: false
      };
      if (callback) {
        await callback(errorContent);
      }
      return true;
    }
  }
};
var actionGetPriceFeeds_default = getPriceFeedsAction;

// src/actions/actionGetPriceUpdatesStream.ts
import { elizaLogger as elizaLogger4 } from "@elizaos/core";
import { HermesClient as HermesClient2 } from "@pythnetwork/hermes-client";
import { EventSource } from "eventsource";

// src/utils/priceUpdateStreamValidation.ts
import { z as z3 } from "zod";
import { elizaLogger as elizaLogger3 } from "@elizaos/core";
var streamOptionsSchema = z3.object({
  encoding: z3.enum(["hex", "base64"]).optional(),
  parsed: z3.boolean().optional(),
  allowUnordered: z3.boolean().optional(),
  benchmarksOnly: z3.boolean().optional()
});
var priceMetadataSchema = z3.object({
  slot: z3.number(),
  proof_available_time: z3.number(),
  prev_publish_time: z3.number()
});
var priceDataSchema = z3.object({
  price: z3.string(),
  conf: z3.string(),
  expo: z3.number(),
  publish_time: z3.number()
});
var parsedPriceUpdateSchema = z3.object({
  id: z3.string(),
  price: priceDataSchema,
  ema_price: priceDataSchema,
  metadata: priceMetadataSchema.optional()
});
var binaryDataSchema = z3.object({
  encoding: z3.string(),
  data: z3.array(z3.string())
});
var priceUpdateStreamSchema = z3.object({
  text: z3.string(),
  priceIds: z3.array(z3.string()).optional(),
  options: streamOptionsSchema.optional()
});
async function validatePriceUpdateStreamData(content) {
  try {
    const result = await priceUpdateStreamSchema.parseAsync(content);
    elizaLogger3.debug("Price update stream validation passed", { result });
  } catch (error) {
    elizaLogger3.error("Price update stream validation failed", { error });
    throw new DataError(
      "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
      "Price update stream validation failed",
      "HIGH" /* HIGH */,
      { error }
    );
  }
}

// src/actions/actionGetPriceUpdatesStream.ts
var config2 = getConfig();
var GRANULAR_LOG2 = config2.PYTH_GRANULAR_LOG;
var PYTH_MAX_PRICE_STREAMS = Number(config2.PYTH_MAX_PRICE_STREAMS);
var activeStreams = /* @__PURE__ */ new Map();
var logGranular2 = (message, data) => {
  if (GRANULAR_LOG2) {
    elizaLogger4.info(`[PriceUpdatesStream] ${message}`, data);
    console.log(
      `[PriceUpdatesStream] ${message}`,
      data ? JSON.stringify(data, null, 2) : ""
    );
  }
};
function extractPriceIds(text) {
  let priceIds = [];
  const symbolMatch = text.match(/(?:BTC|ETH|SOL)\/USD/g);
  if (symbolMatch) {
    const symbolToId = {
      "BTC/USD": "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
      "ETH/USD": "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
      "SOL/USD": "0xef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d"
    };
    priceIds = symbolMatch.map((symbol) => symbolToId[symbol]).filter((id) => id);
  }
  if (priceIds.length === 0) {
    const hexMatchesWithPrefix = text.match(/0x[0-9a-fA-F]{64}/g);
    if (hexMatchesWithPrefix) {
      priceIds = hexMatchesWithPrefix;
    } else {
      const hexMatches = text.match(/[0-9a-fA-F]{64}/g);
      if (hexMatches) {
        priceIds = hexMatches.map((id) => `0x${id}`);
      }
    }
  }
  return priceIds;
}
function processPriceUpdateData(data) {
  return {
    binary: data.binary,
    parsed: data.parsed.map((item) => ({
      id: item.id,
      price: {
        price: item.price.price,
        conf: item.price.conf,
        expo: item.price.expo,
        publish_time: item.price.publish_time
      },
      ema_price: {
        price: item.ema_price.price,
        conf: item.ema_price.conf,
        expo: item.ema_price.expo,
        publish_time: item.ema_price.publish_time
      },
      metadata: item.metadata ? {
        slot: item.metadata.slot,
        proof_available_time: item.metadata.proof_available_time,
        prev_publish_time: item.metadata.prev_publish_time
      } : void 0
    }))
  };
}
function formatPriceUpdateText(streamId, messageCount, data) {
  return `Price Update Stream (ID: stream_${streamId}, Update ${messageCount}/${PYTH_MAX_PRICE_STREAMS}):
${data.parsed.map(
    (item) => `Price Feed: ${item.id}
Current Price: ${(Number(item.price.price) * Math.pow(10, item.price.expo)).toFixed(2)} USD
Confidence: \xB1${(Number(item.price.conf) * Math.pow(10, item.price.expo)).toFixed(2)} USD
EMA Price: ${(Number(item.ema_price.price) * Math.pow(10, item.ema_price.expo)).toFixed(2)} USD
EMA Confidence: \xB1${(Number(item.ema_price.conf) * Math.pow(10, item.ema_price.expo)).toFixed(2)} USD
Last Update: ${new Date(item.price.publish_time * 1e3).toLocaleString()}${item.metadata ? `
Slot: ${item.metadata.slot}
Proof Available: ${new Date(item.metadata.proof_available_time * 1e3).toLocaleString()}` : ""}`
  ).join("\n\n")}`;
}
async function collectStreamData(eventSource, streamId) {
  return new Promise((resolve, reject) => {
    let messageCount = 0;
    const collectedData = {
      binary: { encoding: "hex", data: [] },
      parsed: []
    };
    eventSource.onmessage = (event) => {
      messageCount++;
      logGranular2("Received price update", {
        streamId,
        messageCount,
        data: event.data
      });
      try {
        const rawData = JSON.parse(event.data);
        collectedData.binary.data.push(...rawData.binary.data);
        collectedData.parsed.push(...rawData.parsed);
        if (messageCount >= PYTH_MAX_PRICE_STREAMS) {
          eventSource.close();
          resolve(collectedData);
        }
      } catch (error) {
        eventSource.close();
        reject(error);
      }
    };
    eventSource.onerror = (error) => {
      eventSource.close();
      reject(error);
    };
  });
}
async function createPriceStream(runtime, priceIds, callback) {
  const config5 = await validatePythConfig(runtime);
  if (!config5) {
    throw new DataError(
      "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
      "Invalid Pyth configuration",
      "HIGH" /* HIGH */
    );
  }
  const networkConfig = getNetworkConfig(config5.PYTH_NETWORK_ENV);
  const client = new HermesClient2(networkConfig.hermes);
  const streamId = `stream_${Date.now()}`;
  logGranular2("Creating price stream for IDs:", { streamId, priceIds });
  try {
    const params = new URLSearchParams();
    priceIds.forEach((id) => params.append("ids[]", id));
    params.append("parsed", "true");
    params.append("encoding", "hex");
    const streamUrl = `${networkConfig.hermes}/v2/updates/price/stream?${params.toString()}`;
    const eventSource = new EventSource(streamUrl);
    activeStreams.set(streamId, eventSource);
    try {
      const collectedData = await collectStreamData(
        eventSource,
        streamId
      );
      const processedData = processPriceUpdateData(collectedData);
      const updateText = formatPriceUpdateText(
        streamId,
        PYTH_MAX_PRICE_STREAMS,
        collectedData
      );
      if (callback) {
        callback({
          text: updateText,
          success: true,
          priceIds,
          data: {
            streamId,
            status: "connected",
            ...processedData
          }
        });
      }
      activeStreams.delete(streamId);
      logGranular2("Stream completed successfully", { streamId });
    } catch (error) {
      logGranular2("Error collecting stream data", { streamId, error });
      if (callback) {
        callback({
          text: `Error processing price updates: ${error instanceof Error ? error.message : String(error)}`,
          success: false,
          priceIds,
          data: {
            streamId,
            status: "error",
            error: error instanceof Error ? error.message : String(error)
          }
        });
      }
      activeStreams.delete(streamId);
      throw error;
    }
  } catch (error) {
    logGranular2("Error creating price stream", { streamId, error });
    throw new DataError(
      "DATA_TRANSFORM_ERROR" /* TRANSFORM_ERROR */,
      error instanceof Error ? error.message : String(error),
      "HIGH" /* HIGH */
    );
  }
}
var getPriceUpdatesStreamAction = {
  name: "GET_PRICE_UPDATES_STREAM",
  similes: ["STREAM_PRICE_UPDATES", "SUBSCRIBE_TO_PRICES", "WATCH_PRICE_FEED"],
  description: "Create a streaming connection for real-time price updates from Pyth Network",
  examples: [
    [
      {
        user: "user",
        name: "userMessage",
        content: {
          text: "Stream BTC/USD price updates",
          priceIds: [
            "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43"
          ],
          options: {
            encoding: "hex",
            parsed: true,
            benchmarksOnly: true
          }
        }
      },
      {
        user: "assistant",
        name: "assistantMessage",
        content: {
          text: "Starting BTC/USD price stream...",
          success: true,
          priceIds: [
            "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43"
          ],
          data: {
            streamId: "stream_1",
            status: "connected",
            updates: [
              {
                id: "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
                price: 42e3,
                confidence: 100,
                timestamp: 1641034800,
                emaPrice: 41950
              }
            ]
          }
        }
      }
    ],
    [
      {
        user: "user",
        name: "userMessage",
        content: {
          text: "Stream ETH and BTC prices with benchmarks only",
          priceIds: [
            "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
            "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace"
          ],
          options: {
            benchmarksOnly: true,
            parsed: true
          }
        }
      },
      {
        user: "assistant",
        name: "assistantMessage",
        content: {
          text: "Starting price stream for BTC and ETH...",
          success: true,
          priceIds: [
            "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
            "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace"
          ],
          data: {
            streamId: "stream_2",
            status: "connected",
            updates: [
              {
                id: "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
                price: 42e3,
                confidence: 100,
                timestamp: 1641034800,
                emaPrice: 41950
              },
              {
                id: "0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
                price: 2500,
                confidence: 50,
                timestamp: 1641034800,
                emaPrice: 2495
              }
            ]
          }
        }
      }
    ]
  ],
  validate: async (_runtime, message) => {
    if (message.content?.type !== "GET_PRICE_UPDATES_STREAM") {
      return true;
    }
    logGranular2("Starting validation", {
      content: message.content
    });
    try {
      let content = message.content;
      if (!content.priceIds) {
        const priceIds = extractPriceIds(content.text);
        if (priceIds.length > 0) {
          content = {
            ...content,
            priceIds,
            options: {
              parsed: true,
              encoding: "hex"
            }
          };
          message.content = content;
        }
      }
      try {
        await validatePriceUpdateStreamData(content);
        logGranular2("Schema validation passed");
      } catch (error) {
        logGranular2("Schema validation failed", { error });
        if (error instanceof DataError) {
          elizaLogger4.error("Schema validation failed", {
            errors: error.details?.errors
          });
        }
        return false;
      }
      const config5 = await validatePythConfig(_runtime);
      if (!config5) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Invalid Pyth configuration",
          "HIGH" /* HIGH */
        );
      }
      if (!content.priceIds || !Array.isArray(content.priceIds)) {
        throw DataError.validationFailed(content, [
          "priceIds must be an array of strings"
        ]);
      }
      if (content.priceIds.length === 0) {
        throw DataError.validationFailed(content, [
          "priceIds array cannot be empty"
        ]);
      }
      content.priceIds.forEach((id, index) => {
        if (!/^0x[0-9a-fA-F]{64}$/.test(id)) {
          throw DataError.validationFailed(content, [
            `Invalid price ID at index ${index}: ${id}`
          ]);
        }
      });
      if (content.options) {
        const { encoding, parsed, allowUnordered, benchmarksOnly } = content.options;
        if (encoding && !["hex", "base64"].includes(encoding)) {
          throw DataError.validationFailed(content, [
            "encoding must be either 'hex' or 'base64'"
          ]);
        }
        if (parsed !== void 0 && typeof parsed !== "boolean") {
          throw DataError.validationFailed(content, [
            "parsed must be a boolean"
          ]);
        }
        if (allowUnordered !== void 0 && typeof allowUnordered !== "boolean") {
          throw DataError.validationFailed(content, [
            "allowUnordered must be a boolean"
          ]);
        }
        if (benchmarksOnly !== void 0 && typeof benchmarksOnly !== "boolean") {
          throw DataError.validationFailed(content, [
            "benchmarksOnly must be a boolean"
          ]);
        }
      }
      logGranular2("GET_PRICE_UPDATES_STREAM validation successful", {
        priceIds: content.priceIds,
        options: content.options
      });
      return true;
    } catch (error) {
      logGranular2("Validation failed", { error });
      return false;
    }
  },
  async handler(runtime, message, state, _options = {}, callback) {
    logGranular2("Starting handler execution", {
      messageId: message.id,
      messageContent: message.content
    });
    try {
      const messageContent = message.content;
      let priceIds = messageContent.priceIds;
      if (!priceIds) {
        priceIds = extractPriceIds(messageContent.text);
        if (priceIds.length === 0) {
          throw new DataError(
            "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
            "Could not extract any valid price IDs from message",
            "HIGH" /* HIGH */
          );
        }
      }
      await createPriceStream(runtime, priceIds, callback);
      return true;
    } catch (error) {
      logGranular2("Error in price updates stream handler", error);
      throw new DataError(
        "DATA_TRANSFORM_ERROR" /* TRANSFORM_ERROR */,
        error instanceof Error ? error.message : String(error),
        "HIGH" /* HIGH */
      );
    }
  }
};
var actionGetPriceUpdatesStream_default = getPriceUpdatesStreamAction;

// src/actions/actionGetLatestPriceUpdates.ts
import { elizaLogger as elizaLogger6 } from "@elizaos/core";
import { HermesClient as HermesClient3 } from "@pythnetwork/hermes-client";

// src/utils/priceUpdatesValidation.ts
import { elizaLogger as elizaLogger5 } from "@elizaos/core";
import Ajv from "ajv";
var ajv = new Ajv({
  allErrors: true,
  verbose: true,
  coerceTypes: false,
  useDefaults: true
});
var priceUpdatesSchema = {
  type: "object",
  required: ["priceIds"],
  properties: {
    text: { type: "string" },
    priceIds: {
      type: "array",
      items: {
        type: "string",
        pattern: "^(0x)?[0-9a-fA-F]+$"
      },
      minItems: 1,
      description: "Array of price feed IDs to fetch updates for"
    },
    options: {
      type: "object",
      properties: {
        encoding: {
          type: "string",
          enum: ["hex", "base64"],
          description: "Encoding format for the price updates"
        },
        parsed: {
          type: "boolean",
          description: "Whether to return parsed price updates"
        }
      }
    }
  }
};
async function validatePriceUpdatesData(data) {
  try {
    const validate = ajv.compile(priceUpdatesSchema);
    const valid = validate(data);
    if (!valid) {
      const errors = validate.errors || [];
      elizaLogger5.error("Price updates validation failed", {
        errors,
        data
      });
      throw new DataError(
        "DATA_VALIDATION_FAILED" /* DATA_VALIDATION_FAILED */,
        "Price updates validation failed",
        "HIGH" /* HIGH */,
        {
          errors: errors.map((err) => ({
            path: err.schemaPath,
            message: err.message,
            params: err.params
          })),
          data
        }
      );
    }
  } catch (error) {
    if (error instanceof DataError) {
      throw error;
    }
    elizaLogger5.error("Price updates validation error", {
      error: error instanceof Error ? error.message : String(error),
      data
    });
    throw new DataError(
      "DATA_SCHEMA_ERROR" /* DATA_SCHEMA_ERROR */,
      "Price updates validation error",
      "HIGH" /* HIGH */,
      {
        error: error instanceof Error ? error.message : String(error),
        data
      }
    );
  }
}

// src/actions/actionGetLatestPriceUpdates.ts
var config3 = getConfig();
var GRANULAR_LOG3 = config3.PYTH_GRANULAR_LOG;
var logGranular3 = (message, data) => {
  if (GRANULAR_LOG3) {
    elizaLogger6.info(`[PriceUpdates] ${message}`, data);
    console.log(
      `[PriceUpdates] ${message}`,
      data ? JSON.stringify(data, null, 2) : ""
    );
  }
};
var normalizePriceFeedId = (id) => {
  return id.toLowerCase().startsWith("0x") ? id.toLowerCase() : `0x${id.toLowerCase()}`;
};
var formatPriceFeedId = (id) => {
  return id.toLowerCase().startsWith("0x") ? id.toLowerCase() : `0x${id.toLowerCase()}`;
};
var getLatestPriceUpdatesAction = {
  name: "GET_LATEST_PRICE_UPDATES",
  similes: ["FETCH_LATEST_PRICES", "GET_CURRENT_PRICES", "CHECK_PRICE_FEED"],
  description: "Retrieve latest price updates from Pyth Network",
  examples: [
    [
      {
        user: "user",
        name: "userMessage",
        content: {
          text: "Get latest price updates for 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
          priceIds: [
            "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43"
          ],
          options: {
            encoding: "base64",
            parsed: true
          }
        }
      },
      {
        user: "assistant",
        name: "assistantMessage",
        content: {
          text: "Here is the latest BTC/USD price",
          success: true,
          priceIds: [
            "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43"
          ],
          data: {
            updates: [
              {
                price_feed_id: "0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
                price: 42e9,
                conf: 1e8,
                expo: -8,
                publish_time: 1641034800,
                ema_price: {
                  price: 4195e7,
                  conf: 95e6,
                  expo: -8
                }
              }
            ]
          }
        }
      }
    ]
  ],
  validate: async (_runtime, message) => {
    if (message.content?.type !== "GET_LATEST_PRICE_UPDATES") {
      return true;
    }
    logGranular3("Validating GET_LATEST_PRICE_UPDATES action", {
      content: message.content
    });
    try {
      const content = message.content;
      if (!content.priceIds && content.text) {
        const match = content.text.match(/([a-fA-F0-9]{64})/);
        if (match) {
          content.priceIds = [formatPriceFeedId(match[1])];
        }
      }
      if (content.priceIds) {
        content.priceIds = content.priceIds.map(normalizePriceFeedId);
      }
      try {
        await validatePriceUpdatesData(content);
        logGranular3("Schema validation passed");
      } catch (error) {
        logGranular3("Schema validation failed", { error });
        if (error instanceof DataError) {
          elizaLogger6.error("Schema validation failed", {
            errors: error.details?.errors
          });
          throw error;
        }
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Schema validation failed",
          "HIGH" /* HIGH */,
          { error }
        );
      }
      if (!content.priceIds || !Array.isArray(content.priceIds)) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "priceIds must be an array of strings",
          "HIGH" /* HIGH */
        );
      }
      if (content.priceIds.length === 0) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "priceIds array cannot be empty",
          "HIGH" /* HIGH */
        );
      }
      content.priceIds.forEach((id, index) => {
        const cleanId = id.startsWith("0x") ? id.slice(2) : id;
        if (!/^[0-9a-fA-F]{64}$/.test(cleanId)) {
          throw new DataError(
            "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
            `Invalid price ID at index ${index}: ${id}. Must be a 64-character hex string`,
            "HIGH" /* HIGH */
          );
        }
      });
      if (content.options) {
        if (content.options.encoding && !["hex", "base64"].includes(content.options.encoding)) {
          throw new DataError(
            "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
            "Invalid encoding option. Must be 'hex' or 'base64'",
            "HIGH" /* HIGH */
          );
        }
      }
      return true;
    } catch (error) {
      logGranular3("Validation failed", { error });
      elizaLogger6.error("Validation failed for GET_LATEST_PRICE_UPDATES", {
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  },
  handler: async (runtime, message, _state, _options = {}, callback) => {
    logGranular3("Executing GET_LATEST_PRICE_UPDATES action");
    try {
      const messageContent = message.content;
      logGranular3("Message content received", messageContent);
      if (!messageContent.priceIds && messageContent.text) {
        const match = messageContent.text.match(/([a-fA-F0-9]{64})/);
        if (match) {
          messageContent.priceIds = [formatPriceFeedId(match[1])];
        }
      }
      if (messageContent.priceIds) {
        messageContent.priceIds = messageContent.priceIds.map(normalizePriceFeedId);
      }
      const { priceIds, options = {} } = messageContent;
      logGranular3("Extracted values", {
        priceIds,
        options
      });
      const config5 = await validatePythConfig(runtime);
      if (!config5) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Invalid Pyth configuration",
          "HIGH" /* HIGH */
        );
      }
      const networkConfig = getNetworkConfig(config5.PYTH_NETWORK_ENV);
      const hermesClient = new HermesClient3(networkConfig.hermes);
      logGranular3("Initialized HermesClient", {
        endpoint: networkConfig.hermes
      });
      try {
        logGranular3("Requesting price updates with params", {
          priceIds,
          options
        });
        const updates = await hermesClient.getLatestPriceUpdates(priceIds, {
          parsed: true,
          encoding: options?.encoding
        });
        logGranular3("Raw response from Hermes", {
          updates
        });
        if (!updates || !updates.parsed) {
          throw new Error("No updates received from Hermes");
        }
        logGranular3("Successfully retrieved price updates", {
          updates,
          parsedCount: updates.parsed?.length
        });
        if (callback) {
          const formattedText = updates.parsed?.map((update) => {
            const metadata = update.metadata;
            const proofTime = metadata?.proof_available_time;
            return `Price Feed: ${normalizePriceFeedId(update.id)}
Current Price: ${(Number(update.price.price) * Math.pow(10, update.price.expo)).toFixed(2)} USD
Confidence: \xB1${(Number(update.price.conf) * Math.pow(10, update.price.expo)).toFixed(2)} USD
EMA Price: ${(Number(update.ema_price.price) * Math.pow(10, update.ema_price.expo)).toFixed(2)} USD
EMA Confidence: \xB1${(Number(update.ema_price.conf) * Math.pow(10, update.ema_price.expo)).toFixed(2)} USD
Last Update: ${new Date(update.price.publish_time * 1e3).toLocaleString()}${metadata ? `
Slot: ${metadata.slot}
Proof Available: ${proofTime ? new Date(proofTime * 1e3).toLocaleString() : "Not available"}` : ""}`;
          }).join("\n\n");
          callback({
            text: formattedText,
            success: true,
            priceIds,
            data: {
              updates: updates.parsed?.map((update) => ({
                price_feed_id: normalizePriceFeedId(update.id),
                price: Number(update.price.price),
                conf: Number(update.price.conf),
                expo: update.price.expo,
                publish_time: update.price.publish_time,
                ema_price: update.ema_price ? {
                  price: Number(update.ema_price.price),
                  conf: Number(update.ema_price.conf),
                  expo: update.ema_price.expo
                } : void 0,
                metadata: update.metadata
              }))
            }
          });
        }
        return true;
      } catch (error) {
        logGranular3("Failed to process price updates request", { error });
        if (callback) {
          callback({
            text: `Error retrieving price updates: ${error instanceof Error ? error.message : String(error)}`,
            success: false,
            priceIds,
            data: {
              error: error instanceof Error ? error.message : String(error)
            }
          });
        }
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Failed to process price updates request",
          "HIGH" /* HIGH */,
          { originalError: error }
        );
      }
    } catch (error) {
      logGranular3("Failed to get latest price updates", { error });
      throw new DataError(
        "NETWORK_ERROR" /* NETWORK_ERROR */,
        "Failed to get latest price updates",
        "HIGH" /* HIGH */,
        { originalError: error }
      );
    }
  }
};
var actionGetLatestPriceUpdates_default = getLatestPriceUpdatesAction;

// src/actions/actionGetLatestPublisherCaps.ts
import { elizaLogger as elizaLogger8 } from "@elizaos/core";
import { HermesClient as HermesClient4 } from "@pythnetwork/hermes-client";

// src/utils/publisherCapsValidation.ts
import { elizaLogger as elizaLogger7 } from "@elizaos/core";
import Ajv2 from "ajv";
var ajv2 = new Ajv2({
  allErrors: true,
  verbose: true,
  coerceTypes: false,
  useDefaults: true
});
var publisherCapsSchema = {
  type: "object",
  required: ["text"],
  properties: {
    text: { type: "string" },
    limit: { type: "number" },
    offset: { type: "number" }
  }
};
async function validatePublisherCapsData(data) {
  try {
    const validate = ajv2.compile(publisherCapsSchema);
    const valid = validate(data);
    if (!valid) {
      const errors = validate.errors || [];
      elizaLogger7.error("Publisher caps validation failed", {
        errors,
        data
      });
      throw new DataError(
        "DATA_VALIDATION_FAILED" /* DATA_VALIDATION_FAILED */,
        "Publisher caps validation failed",
        "HIGH" /* HIGH */,
        {
          errors: errors.map((err) => ({
            path: err.schemaPath,
            message: err.message,
            params: err.params
          })),
          data
        }
      );
    }
  } catch (error) {
    if (error instanceof DataError) {
      throw error;
    }
    elizaLogger7.error("Publisher caps validation error", {
      error: error instanceof Error ? error.message : String(error),
      data
    });
    throw new DataError(
      "DATA_SCHEMA_ERROR" /* DATA_SCHEMA_ERROR */,
      "Publisher caps validation error",
      "HIGH" /* HIGH */,
      {
        error: error instanceof Error ? error.message : String(error),
        data
      }
    );
  }
}

// src/actions/actionGetLatestPublisherCaps.ts
var config4 = getConfig();
var GRANULAR_LOG4 = config4.PYTH_GRANULAR_LOG;
var logGranular4 = (message, data) => {
  if (GRANULAR_LOG4) {
    elizaLogger8.info(`[PublisherCaps] ${message}`, data);
    console.log(
      `[PublisherCaps] ${message}`,
      data ? JSON.stringify(data, null, 2) : ""
    );
  }
};
var getLatestPublisherCapsAction = {
  name: "GET_LATEST_PUBLISHER_CAPS",
  similes: [
    "FETCH_PUBLISHER_CAPS",
    "GET_PUBLISHER_LIMITS",
    "CHECK_PUBLISHER_CAPS"
  ],
  description: "Retrieve latest publisher caps from Pyth Network",
  examples: [
    [
      {
        user: "user",
        name: "userMessage",
        content: {
          text: "Get me all the latest publisher caps"
        }
      },
      {
        user: "assistant",
        name: "assistantMessage",
        content: {
          text: "Latest publisher caps",
          success: true,
          data: {
            caps: [
              {
                publisher: "0x1234567890abcdef1234567890abcdef12345678",
                cap: 1e6,
                timestamp: 1641034800
              }
            ]
          }
        }
      }
    ]
  ],
  validate: async (_runtime, message) => {
    logGranular4("Validating GET_LATEST_PUBLISHER_CAPS action", {
      content: message.content
    });
    try {
      if (!message.content) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Message content is required",
          "HIGH" /* HIGH */
        );
      }
      if (message.content.type !== "GET_LATEST_PUBLISHER_CAPS") {
        return true;
      }
      const content = message.content;
      try {
        await validatePublisherCapsData(content);
        logGranular4("Publisher caps validation passed");
      } catch (error) {
        logGranular4("Publisher caps validation failed", { error });
        if (error instanceof DataError) {
          elizaLogger8.error("Publisher caps validation failed", {
            errors: error.details?.errors
          });
          throw error;
        }
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Publisher caps validation failed",
          "HIGH" /* HIGH */,
          { error }
        );
      }
      return true;
    } catch (error) {
      logGranular4("Validation failed", { error });
      elizaLogger8.error("Validation failed for GET_LATEST_PUBLISHER_CAPS", {
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  },
  handler: async (runtime, message, _state, _options = {}, callback) => {
    logGranular4("Executing GET_LATEST_PUBLISHER_CAPS action");
    try {
      const config5 = await validatePythConfig(runtime);
      if (!config5) {
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Invalid Pyth configuration",
          "HIGH" /* HIGH */
        );
      }
      const networkConfig = getNetworkConfig(config5.PYTH_NETWORK_ENV);
      const hermesClient = new HermesClient4(networkConfig.hermes);
      logGranular4("Initialized HermesClient", {
        endpoint: networkConfig.hermes
      });
      try {
        const response = await hermesClient.getLatestPublisherCaps({
          parsed: true
        });
        if (!response.parsed?.[0]?.publisher_stake_caps) {
          throw new DataError(
            "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
            "No publisher caps data found in response",
            "HIGH" /* HIGH */
          );
        }
        const publisherCaps = response.parsed[0].publisher_stake_caps;
        const currentTimestamp = Date.now();
        publisherCaps.forEach((cap, index) => {
          logGranular4(`Publisher Cap ${index + 1}`, {
            publisher: cap.publisher,
            cap: cap.cap.toLocaleString(),
            timestamp: new Date(currentTimestamp).toLocaleString()
          });
        });
        logGranular4("Successfully retrieved publisher caps", {
          totalCaps: publisherCaps.length,
          allCaps: publisherCaps.map((cap) => ({
            publisher: cap.publisher,
            cap: cap.cap.toLocaleString(),
            timestamp: new Date(currentTimestamp).toLocaleString()
          }))
        });
        const formattedText = publisherCaps.length === 0 ? "No publisher caps found" : publisherCaps.map(
          (cap, index) => `Publisher ${index + 1}:
ID: ${cap.publisher}
Cap: ${cap.cap.toLocaleString()} tokens
Timestamp: ${new Date(currentTimestamp).toLocaleString()}`
        ).join("\n\n");
        if (callback) {
          await callback({
            text: publisherCaps.length === 0 ? "No publisher caps found" : `Retrieved ${publisherCaps.length} publisher caps:

${formattedText}`,
            success: true,
            data: {
              caps: publisherCaps.map((cap) => ({
                publisher: cap.publisher,
                cap: cap.cap,
                timestamp: currentTimestamp
              })),
              count: publisherCaps.length
            }
          });
        }
        return true;
      } catch (error) {
        logGranular4("Failed to process publisher caps request", { error });
        if (callback) {
          await callback({
            text: `Error retrieving publisher caps: ${error instanceof Error ? error.message : String(error)}`,
            success: false,
            data: {
              caps: [],
              count: 0,
              error: error instanceof Error ? error.message : String(error)
            }
          });
        }
        if (error instanceof DataError) {
          throw error;
        }
        throw new DataError(
          "DATA_VALIDATION_FAILED" /* VALIDATION_FAILED */,
          "Failed to process publisher caps request",
          "HIGH" /* HIGH */,
          { originalError: error }
        );
      }
    } catch (error) {
      logGranular4("Failed to get publisher caps", { error });
      if (error instanceof DataError) {
        throw error;
      }
      throw new DataError(
        "NETWORK_ERROR" /* NETWORK_ERROR */,
        "Failed to get publisher caps",
        "HIGH" /* HIGH */,
        { originalError: error }
      );
    }
  }
};
var actionGetLatestPublisherCaps_default = getLatestPublisherCapsAction;

// src/index.ts
var spinner = ora({
  text: chalk.cyan("Initializing Pyth Data Plugin..."),
  spinner: "dots12",
  color: "cyan"
}).start();
await new Promise((resolve) => setTimeout(resolve, 1e3));
var actions = [
  actionGetPriceFeeds_default,
  actionGetPriceUpdatesStream_default,
  actionGetLatestPriceUpdates_default,
  actionGetLatestPublisherCaps_default
];
console.log("\n" + chalk.cyan("\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510"));
console.log(
  chalk.cyan("\u2502") + chalk.yellow.bold("          PYTH DATA PLUGIN             ") + chalk.cyan(" \u2502")
);
console.log(chalk.cyan("\u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524"));
console.log(
  chalk.cyan("\u2502") + chalk.white("  Initializing Pyth Data Services...    ") + chalk.cyan("\u2502")
);
console.log(
  chalk.cyan("\u2502") + chalk.white("  Version: 1.0.0                        ") + chalk.cyan("\u2502")
);
console.log(chalk.cyan("\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"));
spinner.succeed(chalk.green("Pyth Data Plugin initialized successfully!"));
var actionTable = new Table({
  head: [
    chalk.cyan("Action"),
    chalk.cyan("H"),
    chalk.cyan("V"),
    chalk.cyan("E"),
    chalk.cyan("Similes")
  ],
  style: {
    head: [],
    border: ["cyan"]
  }
});
actions.forEach((action) => {
  actionTable.push([
    chalk.white(action.name),
    typeof action.handler === "function" ? chalk.green("\u2713") : chalk.red("\u2717"),
    typeof action.validate === "function" ? chalk.green("\u2713") : chalk.red("\u2717"),
    action.examples && action.examples.length > 0 ? chalk.green("\u2713") : chalk.red("\u2717"),
    chalk.gray(action.similes?.join(", ") || "none")
  ]);
});
console.log("\n" + actionTable.toString());
var statusTable = new Table({
  style: {
    border: ["cyan"]
  }
});
statusTable.push(
  [chalk.cyan("Plugin Status")],
  [chalk.white("Name    : ") + chalk.yellow("pyth-data")],
  [chalk.white("Actions : ") + chalk.green(actions.length.toString())],
  [chalk.white("Status  : ") + chalk.green("Loaded & Ready")]
);
console.log("\n" + statusTable.toString() + "\n");
var pythDataPlugin = {
  name: "pyth-data",
  description: "Pyth Data Plugin for price feeds and market data",
  actions,
  evaluators: []
};
var index_default = pythDataPlugin;
export {
  index_default as default,
  pythDataPlugin
};
//# sourceMappingURL=index.js.map