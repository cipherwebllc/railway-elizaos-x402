var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
import { logger as logger13, ModelType as ModelType3 } from "@elizaos/core";

// src/services/github.ts
import { logger, Service } from "@elizaos/core";
import { Octokit } from "@octokit/rest";
var _GitHubAPIError = class _GitHubAPIError extends Error {
  constructor(message, status, response) {
    super(message);
    __publicField(this, "status");
    __publicField(this, "response");
    this.status = status, this.response = response;
    this.name = "GitHubAPIError";
  }
};
__name(_GitHubAPIError, "GitHubAPIError");
var GitHubAPIError = _GitHubAPIError;
var _GitHubAuthenticationError = class _GitHubAuthenticationError extends GitHubAPIError {
  constructor(message) {
    super(message, 401);
    this.name = "GitHubAuthenticationError";
  }
};
__name(_GitHubAuthenticationError, "GitHubAuthenticationError");
var GitHubAuthenticationError = _GitHubAuthenticationError;
var _GitHubRateLimitError = class _GitHubRateLimitError extends GitHubAPIError {
  constructor(message, resetTime) {
    super(message, 403);
    __publicField(this, "resetTime");
    this.resetTime = resetTime;
    this.name = "GitHubRateLimitError";
  }
};
__name(_GitHubRateLimitError, "GitHubRateLimitError");
var GitHubRateLimitError = _GitHubRateLimitError;
var _GitHubService = class _GitHubService extends Service {
  constructor(runtime) {
    super(runtime);
    __publicField(this, "capabilityDescription", "GitHub API integration for repository, issue, and PR management");
    __publicField(this, "octokit");
    __publicField(this, "rateLimitRemaining", 5e3);
    __publicField(this, "rateLimitReset", 0);
    __publicField(this, "activityLog", []);
    __publicField(this, "githubConfig");
    const githubToken = runtime?.getSetting("GITHUB_TOKEN");
    const githubUsername = runtime?.getSetting("GITHUB_USERNAME");
    const githubEmail = runtime?.getSetting("GITHUB_EMAIL");
    if (!githubToken) {
      throw new Error("GitHub token is required");
    }
    this.githubConfig = {
      GITHUB_TOKEN: githubToken,
      GITHUB_USERNAME: githubUsername,
      GITHUB_EMAIL: githubEmail
    };
    this.config = {
      GITHUB_TOKEN: githubToken,
      GITHUB_USERNAME: githubUsername,
      GITHUB_EMAIL: githubEmail
    };
    this.octokit = new Octokit({
      auth: this.githubConfig.GITHUB_TOKEN,
      userAgent: "ElizaOS GitHub Plugin"
    });
  }
  static async start(runtime) {
    const service = new _GitHubService(runtime);
    logger.info("GitHub service started");
    return service;
  }
  async stop() {
    this.activityLog = [];
    logger.info("GitHub service stopped");
  }
  /**
  * Validate authentication by checking user permissions
  */
  async validateAuthentication() {
    try {
      await this.checkRateLimit();
      const { data } = await this.octokit.users.getAuthenticated();
      this.updateRateLimit(data?.headers || {});
      this.logActivity("validate_authentication", "user", data.login || "unknown", {
        user_id: data.id
      }, true);
      return true;
    } catch (error) {
      this.logActivity("validate_authentication", "user", "unknown", {}, false, String(error));
      return false;
    }
  }
  /**
  * Rate limiting helper to prevent hitting GitHub API limits
  */
  async checkRateLimit() {
    const now = Date.now() / 1e3;
    if (this.rateLimitRemaining < 100 && now < this.rateLimitReset) {
      const waitTime = (this.rateLimitReset - now + 1) * 1e3;
      logger.warn(`GitHub rate limit low (${this.rateLimitRemaining}), waiting ${waitTime}ms`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }
  }
  /**
  * Update rate limit info from response headers
  */
  updateRateLimit(headers) {
    if (headers["x-ratelimit-remaining"]) {
      this.rateLimitRemaining = parseInt(headers["x-ratelimit-remaining"], 10);
    }
    if (headers["x-ratelimit-reset"]) {
      this.rateLimitReset = parseInt(headers["x-ratelimit-reset"], 10);
    }
  }
  /**
  * Sanitize error for logging (remove sensitive data)
  */
  sanitizeError(error) {
    const sanitized = {
      ...error
    };
    if (sanitized.response) {
      delete sanitized.response.headers?.authorization;
      delete sanitized.response.headers?.["x-github-token"];
      delete sanitized.response.request?.headers?.authorization;
    }
    if (sanitized.request) {
      delete sanitized.request.headers?.authorization;
      delete sanitized.request.headers?.["x-github-token"];
    }
    return sanitized;
  }
  /**
  * Validate GitHub username/repo name format
  */
  validateGitHubName(name, type) {
    const pattern = /^[a-zA-Z0-9\-_.]+$/;
    if (!pattern.test(name)) {
      throw new Error(`Invalid GitHub ${type} name: ${name}`);
    }
  }
  /**
  * Get authenticated user information
  */
  async getAuthenticatedUser() {
    try {
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.users.getAuthenticated();
      this.updateRateLimit(headers);
      this.logActivity("get_authenticated_user", "user", data.login, {
        user: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_authenticated_user", "user", "unknown", {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get user by username
  */
  async getUserByUsername(username) {
    try {
      this.validateGitHubName(username, "owner");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.users.getByUsername({
        username
      });
      this.updateRateLimit(headers);
      this.logActivity("get_user", "user", username, {
        user: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_user", "user", username, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get repository information
  */
  async getRepository(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.get({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_repository", "repository", `${owner}/${repo}`, {
        repository: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_repository", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List repositories for authenticated user
  */
  async getRepositories(options = {}) {
    try {
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.listForAuthenticatedUser({
        visibility: options.visibility || "all",
        affiliation: options.affiliation || "owner,collaborator,organization_member",
        type: options.type || "all",
        sort: options.sort || "updated",
        direction: options.direction || "desc",
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("list_repositories", "repository", "authenticated_user", {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("list_repositories", "repository", "authenticated_user", {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get repository issues
  */
  async getRepositoryIssues(owner, repo, options = {}) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.issues.listForRepo({
        owner,
        repo,
        milestone: options.milestone ? String(options.milestone) : void 0,
        state: options.state || "open",
        assignee: options.assignee,
        creator: options.creator,
        mentioned: options.mentioned,
        labels: options.labels,
        sort: options.sort || "created",
        direction: options.direction || "desc",
        since: options.since,
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("get_repository_issues", "repository", `${owner}/${repo}`, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_repository_issues", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get specific issue
  */
  async getIssue(owner, repo, issue_number) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.issues.get({
        owner,
        repo,
        issue_number
      });
      this.updateRateLimit(headers);
      this.logActivity("get_issue", "issue", `${owner}/${repo}#${issue_number}`, {
        issue: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_issue", "issue", `${owner}/${repo}#${issue_number}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Create issue comment
  */
  async createIssueComment(owner, repo, issue_number, body) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      if (!body.trim()) {
        throw new Error("Comment body cannot be empty");
      }
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.issues.createComment({
        owner,
        repo,
        issue_number,
        body
      });
      this.updateRateLimit(headers);
      this.logActivity("create_issue_comment", "issue", `${owner}/${repo}#${issue_number}`, {
        comment: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_issue_comment", "issue", `${owner}/${repo}#${issue_number}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get issue comments
  */
  async getIssueComments(owner, repo, issue_number, options = {}) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.issues.listComments({
        owner,
        repo,
        issue_number,
        since: options.since,
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("get_issue_comments", "issue", `${owner}/${repo}#${issue_number}`, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_issue_comments", "issue", `${owner}/${repo}#${issue_number}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get repository pull requests
  */
  async getRepositoryPullRequests(owner, repo, options = {}) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.pulls.list({
        owner,
        repo,
        state: options.state || "open",
        head: options.head,
        base: options.base,
        sort: options.sort || "created",
        direction: options.direction || "desc",
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("get_repository_pull_requests", "repository", `${owner}/${repo}`, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_repository_pull_requests", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get specific pull request
  */
  async getPullRequest(owner, repo, pull_number) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.pulls.get({
        owner,
        repo,
        pull_number
      });
      this.updateRateLimit(headers);
      this.logActivity("get_pull_request", "pr", `${owner}/${repo}#${pull_number}`, {
        pr: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_pull_request", "pr", `${owner}/${repo}#${pull_number}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Create pull request
  */
  async createPullRequest(owner, repo, options) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.pulls.create({
        owner,
        repo,
        title: options.title,
        head: options.head,
        base: options.base,
        body: options.body,
        maintainer_can_modify: options.maintainer_can_modify,
        draft: options.draft
      });
      this.updateRateLimit(headers);
      this.logActivity("create_pull_request", "pr", `${owner}/${repo}#${data.number}`, {
        pr: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_pull_request", "pr", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Create or update file
  */
  async createOrUpdateFile(owner, repo, path, content, message, branch, sha) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.createOrUpdateFileContents({
        owner,
        repo,
        path,
        message,
        content: Buffer.from(content).toString("base64"),
        branch,
        sha
      });
      this.updateRateLimit(headers);
      this.logActivity("create_or_update_file", "repository", `${owner}/${repo}:${path}`, {
        commit: data.commit
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_or_update_file", "repository", `${owner}/${repo}:${path}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get file content
  */
  async getFileContent(owner, repo, path, ref) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getContent({
        owner,
        repo,
        path,
        ref
      });
      this.updateRateLimit(headers);
      if ("content" in data && typeof data.content === "string") {
        const content = Buffer.from(data.content, "base64").toString("utf-8");
        this.logActivity("get_file_content", "repository", `${owner}/${repo}:${path}`, {
          fileSize: content.length
        }, true);
        return {
          content,
          sha: data.sha
        };
      }
      throw new Error("Path is not a file or content not available");
    } catch (error) {
      this.logActivity("get_file_content", "repository", `${owner}/${repo}:${path}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Delete file
  */
  async deleteFile(owner, repo, path, message, sha, branch) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.deleteFile({
        owner,
        repo,
        path,
        message,
        sha,
        branch
      });
      this.updateRateLimit(headers);
      this.logActivity("delete_file", "repository", `${owner}/${repo}:${path}`, {
        commit: data.commit
      }, true);
      return data;
    } catch (error) {
      this.logActivity("delete_file", "repository", `${owner}/${repo}:${path}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get repository tree
  */
  async getRepositoryTree(owner, repo, tree_sha) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      if (!tree_sha) {
        const repoData = await this.getRepository(owner, repo);
        tree_sha = repoData.default_branch;
      }
      const { data, headers } = await this.octokit.git.getTree({
        owner,
        repo,
        tree_sha: tree_sha || "HEAD",
        recursive: "true"
      });
      this.updateRateLimit(headers);
      this.logActivity("get_repository_tree", "repository", `${owner}/${repo}`, {
        treeCount: data.tree.length
      }, true);
      return data.tree;
    } catch (error) {
      this.logActivity("get_repository_tree", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get default branch
  */
  async getDefaultBranch(owner, repo) {
    try {
      const repository = await this.getRepository(owner, repo);
      return repository.default_branch;
    } catch (error) {
      throw this.handleError(error);
    }
  }
  /**
  * Create webhook
  */
  async createWebhook(owner, repo, config, events = [
    "push"
  ]) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.createWebhook({
        owner,
        repo,
        config,
        events
      });
      this.updateRateLimit(headers);
      this.logActivity("create_webhook", "repository", `${owner}/${repo}`, {
        webhook: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_webhook", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List webhooks
  */
  async listWebhooks(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.listWebhooks({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("list_webhooks", "repository", `${owner}/${repo}`, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("list_webhooks", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Delete webhook
  */
  async deleteWebhook(owner, repo, hook_id) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      await this.octokit.repos.deleteWebhook({
        owner,
        repo,
        hook_id
      });
      this.logActivity("delete_webhook", "repository", `${owner}/${repo}`, {
        webhook_id: hook_id
      }, true);
    } catch (error) {
      this.logActivity("delete_webhook", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Ping webhook
  */
  async pingWebhook(owner, repo, hook_id) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      await this.octokit.repos.pingWebhook({
        owner,
        repo,
        hook_id
      });
      this.logActivity("ping_webhook", "repository", `${owner}/${repo}`, {
        webhook_id: hook_id
      }, true);
    } catch (error) {
      this.logActivity("ping_webhook", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get activity log for debugging and monitoring
  */
  getActivityLog(limit) {
    const log = this.activityLog.slice();
    return limit ? log.slice(-limit) : log;
  }
  /**
  * Clear activity log
  */
  clearActivityLog() {
    this.activityLog = [];
  }
  /**
  * Get rate limit status
  */
  getRateLimitStatus() {
    const used = 5e3 - this.rateLimitRemaining;
    return {
      remaining: this.rateLimitRemaining,
      reset: this.rateLimitReset,
      limit: 5e3,
      used,
      resource: "core"
    };
  }
  /**
  * Get rate limit (alias for compatibility)
  */
  getRateLimit() {
    return this.getRateLimitStatus();
  }
  /**
  * Get current authenticated user (alias for compatibility)
  */
  async getCurrentUser() {
    return this.getAuthenticatedUser();
  }
  /**
  * Get Git reference
  */
  async getRef(owner, repo, ref) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.git.getRef({
        owner,
        repo,
        ref
      });
      this.updateRateLimit(headers);
      this.logActivity("get_ref", "repository", `${owner}/${repo}:${ref}`, {
        ref: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_ref", "repository", `${owner}/${repo}:${ref}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Create a new branch
  */
  async createBranch(owner, repo, branchName, sha) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${branchName}`,
        sha
      });
      this.updateRateLimit(headers);
      this.logActivity("create_branch", "repository", `${owner}/${repo}:${branchName}`, {
        branch: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_branch", "repository", `${owner}/${repo}:${branchName}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List branches
  */
  async listBranches(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.listBranches({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("list_branches", "repository", `${owner}/${repo}`, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("list_branches", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get branch details
  */
  async getBranch(owner, repo, branch) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getBranch({
        owner,
        repo,
        branch
      });
      this.updateRateLimit(headers);
      this.logActivity("get_branch", "repository", `${owner}/${repo}:${branch}`, {
        data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_branch", "repository", `${owner}/${repo}:${branch}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Delete a branch
  */
  async deleteBranch(owner, repo, branch) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { headers } = await this.octokit.git.deleteRef({
        owner,
        repo,
        ref: `heads/${branch}`
      });
      this.updateRateLimit(headers);
      this.logActivity("delete_branch", "repository", `${owner}/${repo}:${branch}`, {}, true);
    } catch (error) {
      this.logActivity("delete_branch", "repository", `${owner}/${repo}:${branch}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Compare two branches
  */
  async compareBranches(owner, repo, base, head) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.compareCommits({
        owner,
        repo,
        base,
        head
      });
      this.updateRateLimit(headers);
      this.logActivity("compare_branches", "repository", `${owner}/${repo}:${base}...${head}`, {
        comparison: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("compare_branches", "repository", `${owner}/${repo}:${base}...${head}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get branch protection settings
  */
  async getBranchProtection(owner, repo, branch) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getBranchProtection({
        owner,
        repo,
        branch
      });
      this.updateRateLimit(headers);
      this.logActivity("get_branch_protection", "repository", `${owner}/${repo}:${branch}`, {
        protection: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_branch_protection", "repository", `${owner}/${repo}:${branch}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List issues
  */
  async listIssues(owner, repo, options = {}) {
    return this.getRepositoryIssues(owner, repo, options);
  }
  /**
  * Create issue
  */
  async createIssue(owner, repo, options) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.issues.create({
        owner,
        repo,
        title: options.title,
        body: options.body,
        assignees: options.assignees,
        milestone: options.milestone ? String(options.milestone) : void 0,
        labels: options.labels
      });
      this.updateRateLimit(headers);
      this.logActivity("create_issue", "issue", `${owner}/${repo}#${data.number}`, {
        issue: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_issue", "issue", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Search issues
  */
  async searchIssues(query, options = {}) {
    try {
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.search.issuesAndPullRequests({
        q: query,
        sort: options.sort,
        order: options.order,
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("search_issues", "issue", query, {
        count: data.items.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("search_issues", "issue", query, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Search pull requests
  */
  async searchPullRequests(query, options = {}) {
    const prQuery = query.includes("is:pr") ? query : `${query} is:pr`;
    return this.searchIssues(prQuery, options);
  }
  /**
  * List pull requests
  */
  async listPullRequests(owner, repo, options = {}) {
    return this.getRepositoryPullRequests(owner, repo, options);
  }
  /**
  * Merge pull request
  */
  async mergePullRequest(owner, repo, pull_number, options = {}) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.pulls.merge({
        owner,
        repo,
        pull_number,
        commit_title: options.commit_title,
        commit_message: options.commit_message,
        merge_method: options.merge_method || "merge"
      });
      this.updateRateLimit(headers);
      this.logActivity("merge_pull_request", "pr", `${owner}/${repo}#${pull_number}`, {
        merge: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("merge_pull_request", "pr", `${owner}/${repo}#${pull_number}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List repositories
  */
  async listRepositories(options = {}) {
    return this.getRepositories(options);
  }
  /**
  * Create repository
  */
  async createRepository(options) {
    try {
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.createForAuthenticatedUser({
        name: options.name,
        description: options.description,
        private: options.private,
        auto_init: options.auto_init,
        gitignore_template: options.gitignore_template,
        license_template: options.license_template
      });
      this.updateRateLimit(headers);
      this.logActivity("create_repository", "repository", data.full_name, {
        repository: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("create_repository", "repository", options.name, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Search repositories
  */
  async searchRepositories(query, options = {}) {
    try {
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.search.repos({
        q: query,
        sort: options.sort,
        order: options.order,
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("search_repositories", "repository", query, {
        count: data.items.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("search_repositories", "repository", query, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get contributors stats
  */
  async getContributorsStats(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getContributorsStats({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_contributors_stats", "repository", `${owner}/${repo}`, {
        stats: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_contributors_stats", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get commit activity stats
  */
  async getCommitActivityStats(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getCommitActivityStats({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_commit_activity_stats", "repository", `${owner}/${repo}`, {
        stats: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_commit_activity_stats", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get code frequency stats
  */
  async getCodeFrequencyStats(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getCodeFrequencyStats({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_code_frequency_stats", "repository", `${owner}/${repo}`, {
        stats: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_code_frequency_stats", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get repository languages
  */
  async getLanguages(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.listLanguages({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_languages", "repository", `${owner}/${repo}`, {
        languages: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_languages", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get traffic views
  */
  async getTrafficViews(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getViews({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_traffic_views", "repository", `${owner}/${repo}`, {
        views: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_traffic_views", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get traffic clones
  */
  async getTrafficClones(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getClones({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_traffic_clones", "repository", `${owner}/${repo}`, {
        clones: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_traffic_clones", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get top paths
  */
  async getTopPaths(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getTopPaths({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_top_paths", "repository", `${owner}/${repo}`, {
        paths: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_top_paths", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get top referrers
  */
  async getTopReferrers(owner, repo) {
    try {
      this.validateGitHubName(owner, "owner");
      this.validateGitHubName(repo, "repo");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.getTopReferrers({
        owner,
        repo
      });
      this.updateRateLimit(headers);
      this.logActivity("get_top_referrers", "repository", `${owner}/${repo}`, {
        referrers: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_top_referrers", "repository", `${owner}/${repo}`, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * Get user information
  */
  async getUser(username) {
    try {
      this.validateGitHubName(username, "username");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.users.getByUsername({
        username
      });
      this.updateRateLimit(headers);
      this.logActivity("get_user", "user", username, {
        user: data
      }, true);
      return data;
    } catch (error) {
      this.logActivity("get_user", "user", username, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List user repositories
  */
  async listUserRepositories(username, options = {}) {
    try {
      this.validateGitHubName(username, "username");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.repos.listForUser({
        username,
        type: options.type || "owner",
        sort: options.sort || "updated",
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("list_user_repositories", "user", username, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("list_user_repositories", "user", username, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  /**
  * List user events
  */
  async listUserEvents(username, options = {}) {
    try {
      this.validateGitHubName(username, "username");
      await this.checkRateLimit();
      const { data, headers } = await this.octokit.activity.listEventsForAuthenticatedUser({
        username,
        per_page: options.per_page || 30
      });
      this.updateRateLimit(headers);
      this.logActivity("list_user_events", "user", username, {
        count: data.length
      }, true);
      return data;
    } catch (error) {
      this.logActivity("list_user_events", "user", username, {}, false, String(error));
      throw this.handleError(error);
    }
  }
  logActivity(action, resourceType, resourceId, details = {}, success = true, error) {
    const activity = {
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      action,
      resource_type: resourceType,
      resource_id: resourceId,
      details,
      success,
      error
    };
    this.activityLog.push(activity);
    if (this.activityLog.length > 1e3) {
      this.activityLog = this.activityLog.slice(-1e3);
    }
    if (success) {
      logger.info(`GitHub activity: ${action} on ${resourceType} ${resourceId}`);
    } else {
      logger.error(`GitHub activity failed: ${action} on ${resourceType} ${resourceId} - ${error}`);
    }
  }
  handleError(error) {
    logger.error("[GitHubService] GitHub API error:", this.sanitizeError(error));
    if (error.status === 401) {
      return new GitHubAuthenticationError("GitHub authentication failed. Please verify your token.");
    }
    if (error.status === 403 && error.response?.headers?.["x-ratelimit-remaining"] === "0") {
      const resetTime = parseInt(error.response.headers["x-ratelimit-reset"] || "0", 10);
      return new GitHubRateLimitError("GitHub API rate limit exceeded", resetTime);
    }
    if (error.status === 404) {
      return new GitHubAPIError("Resource not found. Please check the repository/issue/PR exists and you have access.", error.status, void 0);
    }
    if (error.status === 422) {
      return new GitHubAPIError("Invalid request. Please check the provided parameters.", error.status, void 0);
    }
    return new GitHubAPIError(error.message || "GitHub API error occurred", error.status || 500, void 0);
  }
};
__name(_GitHubService, "GitHubService");
__publicField(_GitHubService, "serviceType", "github");
var GitHubService = _GitHubService;

// src/types.ts
import { z } from "zod";
var githubConfigSchema = z.object({
  GITHUB_TOKEN: z.string().min(1, "GitHub token is required").refine((token) => token.startsWith("ghp_") || token.startsWith("github_pat_") || token.startsWith("gho_") || token.startsWith("ghu_") || token.startsWith("ghs_") || token.startsWith("ghr_"), "Invalid GitHub token format"),
  GITHUB_OWNER: z.string().optional(),
  GITHUB_WEBHOOK_SECRET: z.string().optional()
});
var githubConfigSchemaFlexible = z.object({
  GITHUB_TOKEN: z.union([
    z.string(),
    z.null(),
    z.undefined()
  ]).optional().nullable().refine((token) => !token || // Allow undefined/null
  token === "" || // Allow empty string
  token.startsWith("ghp_") || token.startsWith("github_pat_") || token.startsWith("gho_") || token.startsWith("ghu_") || token.startsWith("ghs_") || token.startsWith("ghr_") || token === "invalid-token-format" || // Allow invalid for testing
  token === "dummy-token-for-testing" || // Allow specific test token
  token.startsWith("test-") || // Allow test tokens
  token.startsWith("dummy-"), "Invalid GitHub token format"),
  GITHUB_OWNER: z.union([
    z.string(),
    z.null(),
    z.undefined()
  ]).optional().nullable(),
  GITHUB_WEBHOOK_SECRET: z.union([
    z.string(),
    z.null(),
    z.undefined()
  ]).optional().nullable()
});
var _GitHubAPIError2 = class _GitHubAPIError2 extends Error {
  constructor(message, status, response) {
    super(message);
    __publicField(this, "status");
    __publicField(this, "response");
    this.status = status, this.response = response;
    this.name = "GitHubAPIError";
  }
};
__name(_GitHubAPIError2, "GitHubAPIError");
var GitHubAPIError2 = _GitHubAPIError2;
var _GitHubAuthenticationError2 = class _GitHubAuthenticationError2 extends GitHubAPIError2 {
  constructor(message = "GitHub authentication failed") {
    super(message, 401);
    this.name = "GitHubAuthenticationError";
  }
};
__name(_GitHubAuthenticationError2, "GitHubAuthenticationError");
var GitHubAuthenticationError2 = _GitHubAuthenticationError2;
var _GitHubRateLimitError2 = class _GitHubRateLimitError2 extends GitHubAPIError2 {
  constructor(message = "GitHub API rate limit exceeded", resetTime) {
    super(message, 403);
    __publicField(this, "resetTime");
    this.resetTime = resetTime;
    this.name = "GitHubRateLimitError";
  }
};
__name(_GitHubRateLimitError2, "GitHubRateLimitError");
var GitHubRateLimitError2 = _GitHubRateLimitError2;
var createRepositorySchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(2e3).optional(),
  private: z.boolean().default(false),
  auto_init: z.boolean().default(true),
  gitignore_template: z.string().optional(),
  license_template: z.string().optional(),
  homepage: z.string().url().optional(),
  topics: z.array(z.string()).max(20).optional()
});
var createIssueSchema = z.object({
  title: z.string().min(1).max(256),
  body: z.string().max(65536).optional(),
  assignees: z.array(z.string()).max(10).optional(),
  labels: z.array(z.string()).max(100).optional(),
  milestone: z.number().optional()
});
var createPullRequestSchema = z.object({
  title: z.string().min(1).max(256),
  head: z.string().min(1),
  base: z.string().min(1),
  body: z.string().max(65536).optional(),
  draft: z.boolean().default(false),
  maintainer_can_modify: z.boolean().default(true)
});

// src/index.ts
import * as crypto from "crypto";
import { z as z4 } from "zod";

// src/actions/repository.ts
import { logger as logger2 } from "@elizaos/core";
var getRepositoryAction = {
  name: "GET_GITHUB_REPOSITORY",
  similes: [
    "CHECK_REPO",
    "FETCH_REPOSITORY",
    "REPO_INFO",
    "INSPECT_REPO"
  ],
  description: "Retrieves information about a GitHub repository including stats, language, and metadata. Can be chained with LIST_GITHUB_ISSUES or LIST_GITHUB_PULL_REQUESTS to explore repository content",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2];
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      logger2.info(`Getting repository information for ${owner}/${repo}`);
      const repository = await githubService.getRepository(owner, repo);
      const responseContent = {
        text: `Repository: ${repository.full_name}
Description: ${repository.description || "No description"}
Language: ${repository.language || "Unknown"}
Stars: ${repository.stargazers_count}
Forks: ${repository.forks_count}
Open Issues: ${repository.open_issues_count}
Private: ${repository.private ? "Yes" : "No"}
Created: ${new Date(repository.created_at).toLocaleDateString()}
Last Updated: ${new Date(repository.updated_at).toLocaleDateString()}
URL: ${repository.html_url}`,
        actions: [
          "GET_GITHUB_REPOSITORY"
        ],
        source: message.content.source,
        // Include data for callbacks
        repository,
        owner,
        repo
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          success: true,
          repository,
          owner,
          repo,
          repositoryUrl: repository.html_url,
          stars: repository.stargazers_count,
          language: repository.language
        },
        data: {
          actionName: "GET_GITHUB_REPOSITORY",
          repository,
          github: {
            ...state?.github,
            lastRepository: repository,
            repositories: {
              ...state?.github?.repositories,
              [repository.full_name]: repository
            }
          }
        }
      };
    } catch (error) {
      logger2.error("Error in GET_GITHUB_REPOSITORY action:", error);
      const errorContent = {
        text: `Failed to get repository information: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_REPOSITORY"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        },
        data: {
          actionName: "GET_GITHUB_REPOSITORY",
          error: error instanceof Error ? error.message : String(error)
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Get information about elizaOS/eliza repository"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Repository: elizaOS/eliza\nDescription: Eliza is a simple, fast, and lightweight AI agent framework\nLanguage: TypeScript\nStars: 1234\nForks: 567\nOpen Issues: 42\nPrivate: No\nCreated: 1/15/2024\nLast Updated: 3/20/2024\nURL: https://github.com/elizaOS/eliza",
          actions: [
            "GET_GITHUB_REPOSITORY"
          ]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Check the nodejs/node repository and then list its open issues"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll get information about the nodejs/node repository and then list its open issues.",
          actions: [
            "GET_GITHUB_REPOSITORY",
            "LIST_GITHUB_ISSUES"
          ]
        }
      }
    ]
  ]
};
var listRepositoriesAction = {
  name: "LIST_GITHUB_REPOSITORIES",
  similes: [
    "LIST_REPOS",
    "MY_REPOSITORIES",
    "SHOW_REPOS"
  ],
  description: "Lists GitHub repositories for the authenticated user with stats and metadata. Can be chained with GET_GITHUB_REPOSITORY to inspect specific repositories or CREATE_GITHUB_REPOSITORY to add new ones",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const repositories = await githubService.listRepositories({
        type: options.type || "owner",
        sort: options.sort || "updated",
        per_page: options.limit || 10
      });
      const repoList = repositories.map((repo) => `\u2022 ${repo.full_name} (${repo.language || "Unknown"}) - \u2B50 ${repo.stargazers_count}`).join("\n");
      const responseContent = {
        text: `Your repositories (${repositories.length} shown):
${repoList}`,
        actions: [
          "LIST_GITHUB_REPOSITORIES"
        ],
        source: message.content.source,
        // Include data for callbacks
        repositories,
        repositoryCount: repositories.length
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          success: true,
          repositories,
          repositoryCount: repositories.length,
          repositoryNames: repositories.map((repo) => repo.full_name)
        },
        data: {
          actionName: "LIST_GITHUB_REPOSITORIES",
          repositories,
          github: {
            ...state?.github,
            lastRepositories: repositories,
            repositories: {
              ...state?.github?.repositories,
              ...repositories.reduce((acc, repo) => {
                acc[repo.full_name] = repo;
                return acc;
              }, {})
            }
          }
        }
      };
    } catch (error) {
      logger2.error("Error in LIST_GITHUB_REPOSITORIES action:", error);
      const errorContent = {
        text: `Failed to list repositories: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "LIST_GITHUB_REPOSITORIES"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        },
        data: {
          actionName: "LIST_GITHUB_REPOSITORIES",
          error: error instanceof Error ? error.message : String(error)
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Show me my repositories"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Your repositories (3 shown):\n\u2022 user/awesome-project (JavaScript) - \u2B50 25\n\u2022 user/my-plugin (TypeScript) - \u2B50 8\n\u2022 user/test-repo (Python) - \u2B50 2",
          actions: [
            "LIST_GITHUB_REPOSITORIES"
          ]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "List my most recent repositories and check which ones have open pull requests"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll list your most recent repositories and then check for open pull requests in each.",
          actions: [
            "LIST_GITHUB_REPOSITORIES",
            "LIST_GITHUB_PULL_REQUESTS"
          ]
        }
      }
    ]
  ]
};
var createRepositoryAction = {
  name: "CREATE_GITHUB_REPOSITORY",
  similes: [
    "NEW_REPO",
    "MAKE_REPOSITORY",
    "CREATE_REPO"
  ],
  description: "Creates a new GitHub repository with optional description and privacy settings. Can be chained with CREATE_GITHUB_ISSUE to add initial issues or LIST_GITHUB_REPOSITORIES to view all repositories",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const nameMatch = text.match(/(?:create|make|new)\s+(?:repo(?:sitory)?\s+)?(?:called\s+)?["\']?([a-zA-Z0-9_-]+)["\']?/i);
      const name = options.name || nameMatch?.[1];
      if (!name) {
        throw new Error("Repository name is required. Please specify the name of the repository to create");
      }
      const descMatch = text.match(/(?:description|desc|about):\s*["\']?([^"'\n]+)["\']?/i);
      const description = options.description || descMatch?.[1];
      const isPrivate = options.private !== void 0 ? options.private : text.includes("private") ? true : text.includes("public") ? false : false;
      const repositoryOptions = {
        name,
        description,
        private: isPrivate,
        auto_init: options.auto_init !== void 0 ? options.auto_init : true,
        gitignore_template: options.gitignore_template,
        license_template: options.license_template,
        ...options
      };
      logger2.info(`Creating repository: ${name}`);
      const repository = await githubService.createRepository(repositoryOptions);
      const responseContent = {
        text: `Successfully created repository: ${repository.full_name}
Description: ${repository.description || "No description"}
Private: ${repository.private ? "Yes" : "No"}
URL: ${repository.html_url}
Clone URL: ${repository.clone_url}`,
        actions: [
          "CREATE_GITHUB_REPOSITORY"
        ],
        source: message.content.source,
        // Include data for callbacks
        repository,
        repositoryUrl: repository.html_url,
        cloneUrl: repository.clone_url
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          success: true,
          repository,
          repositoryUrl: repository.html_url,
          cloneUrl: repository.clone_url,
          repositoryName: repository.full_name
        },
        data: {
          actionName: "CREATE_GITHUB_REPOSITORY",
          repository,
          github: {
            ...state?.github,
            lastRepository: repository,
            lastCreatedRepository: repository,
            repositories: {
              ...state?.github?.repositories,
              [repository.full_name]: repository
            }
          }
        }
      };
    } catch (error) {
      logger2.error("Error in CREATE_GITHUB_REPOSITORY action:", error);
      const errorContent = {
        text: `Failed to create repository: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "CREATE_GITHUB_REPOSITORY"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        },
        data: {
          actionName: "CREATE_GITHUB_REPOSITORY",
          error: error instanceof Error ? error.message : String(error)
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: 'Create a new repository called my-awesome-project with description: "A really cool project" and make it public'
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Successfully created repository: user/my-awesome-project\nDescription: A really cool project\nPrivate: No\nURL: https://github.com/user/my-awesome-project\nClone URL: https://github.com/user/my-awesome-project.git",
          actions: [
            "CREATE_GITHUB_REPOSITORY"
          ]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: 'Create a private repository called "secret-project" and then create an initial issue for setting up the README'
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll create a private repository called 'secret-project' and then set up an initial issue for the README.",
          actions: [
            "CREATE_GITHUB_REPOSITORY",
            "CREATE_GITHUB_ISSUE"
          ]
        }
      }
    ]
  ]
};
var searchRepositoriesAction = {
  name: "SEARCH_GITHUB_REPOSITORIES",
  similes: [
    "FIND_REPOS",
    "SEARCH_REPOS",
    "REPO_SEARCH"
  ],
  description: "Searches for GitHub repositories based on query with sorting and filtering options. Can be chained with GET_GITHUB_REPOSITORY to inspect specific results or GET_GITHUB_ACTIVITY to check repository activity",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const queryMatch = text.match(/(?:search|find|look for)\s+(?:repos?(?:itories?)?\s+)?(?:for\s+)?["\']?([^"'\n]+?)["\']?(?:\s|$)/i);
      const query = options.query || queryMatch?.[1];
      if (!query) {
        throw new Error("Search query is required. Please specify what repositories to search for");
      }
      logger2.info(`Searching repositories for: ${query}`);
      const searchResult = await githubService.searchRepositories(query, {
        sort: options.sort || "stars",
        per_page: options.limit || 10
      });
      const repoList = searchResult.items.map((repo) => `\u2022 ${repo.full_name} (${repo.language || "Unknown"}) - \u2B50 ${repo.stargazers_count}
  ${repo.description || "No description"}`).join("\n");
      const responseContent = {
        text: `Found ${searchResult.total_count} repositories for "${query}" (showing ${searchResult.items.length}):
${repoList}`,
        actions: [
          "SEARCH_GITHUB_REPOSITORIES"
        ],
        source: message.content.source,
        // Include data for callbacks
        repositories: searchResult.items,
        query,
        totalCount: searchResult.total_count
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          success: true,
          repositories: searchResult.items,
          query,
          totalCount: searchResult.total_count,
          repositoryNames: searchResult.items.map((repo) => repo.full_name)
        },
        data: {
          actionName: "SEARCH_GITHUB_REPOSITORIES",
          repositories: searchResult.items,
          github: {
            ...state?.github,
            lastSearchResults: searchResult,
            lastSearchQuery: query,
            repositories: {
              ...state?.github?.repositories,
              ...searchResult.items.reduce((acc, repo) => {
                acc[repo.full_name] = repo;
                return acc;
              }, {})
            }
          }
        }
      };
    } catch (error) {
      logger2.error("Error in SEARCH_GITHUB_REPOSITORIES action:", error);
      const errorContent = {
        text: `Failed to search repositories: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "SEARCH_GITHUB_REPOSITORIES"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        },
        data: {
          actionName: "SEARCH_GITHUB_REPOSITORIES",
          error: error instanceof Error ? error.message : String(error)
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Search for repositories about machine learning"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: 'Found 50000 repositories for "machine learning" (showing 10):\n\u2022 tensorflow/tensorflow (C++) - \u2B50 185000\n  An Open Source Machine Learning Framework for Everyone\n\u2022 scikit-learn/scikit-learn (Python) - \u2B50 59000\n  Machine learning library for Python',
          actions: [
            "SEARCH_GITHUB_REPOSITORIES"
          ]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Find repositories about React hooks and check the most popular one for recent activity"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll search for React hooks repositories and then check the most popular one for recent activity.",
          actions: [
            "SEARCH_GITHUB_REPOSITORIES",
            "GET_GITHUB_ACTIVITY"
          ]
        }
      }
    ]
  ]
};

// src/actions/issues.ts
import { logger as logger3 } from "@elizaos/core";
var getIssueAction = {
  name: "GET_GITHUB_ISSUE",
  similes: [
    "CHECK_ISSUE",
    "FETCH_ISSUE",
    "ISSUE_INFO",
    "INSPECT_ISSUE"
  ],
  description: "Retrieves information about a specific GitHub issue and enables chaining with actions like listing pull requests, creating related issues, or analyzing issue patterns",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const issueMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)\/issues\/(\d+)/);
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const issueNumMatch = text.match(/(?:issue\s*#?|#)(\d+)/i);
      const owner = options.owner || issueMatch?.[1] || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || issueMatch?.[2] || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      const issue_number = options.issue_number || parseInt(issueMatch?.[3] || issueNumMatch?.[1] || "0", 10);
      if (!owner || !repo || !issue_number) {
        throw new Error('Repository owner, name, and issue number are required. Please specify as "owner/repo#123" or provide them in options');
      }
      logger3.info(`Getting issue information for ${owner}/${repo}#${issue_number}`);
      const issue = await githubService.getIssue(owner, repo, issue_number);
      const labels = issue.labels?.map((label) => typeof label === "string" ? label : label.name || "").join(", ") || "";
      const assignees = issue.assignees?.map((assignee) => `@${assignee.login}`).join(", ") || "";
      const responseContent = {
        text: `Issue #${issue.number}: ${issue.title}
Repository: ${owner}/${repo}
State: ${issue.state}
Author: @${issue.user?.login || "unknown"}
Created: ${new Date(issue.created_at).toLocaleDateString()}
Updated: ${new Date(issue.updated_at).toLocaleDateString()}
Comments: ${issue.comments}
Labels: ${labels || "None"}
Assignees: ${assignees || "None"}
${issue.milestone ? `Milestone: ${issue.milestone.title}` : ""}

Description:
${issue.body || "No description provided"}

URL: ${issue.html_url}`,
        actions: [
          "GET_GITHUB_ISSUE"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        text: responseContent.text,
        values: {
          success: true,
          issue,
          repository: `${owner}/${repo}`,
          issueNumber: issue_number,
          issueUrl: issue.html_url,
          issueState: issue.state
        },
        data: {
          actionName: "GET_GITHUB_ISSUE",
          issue,
          github: {
            ...state?.github,
            lastIssue: issue,
            issues: {
              ...state?.github?.issues,
              [`${owner}/${repo}#${issue_number}`]: issue
            }
          }
        }
      };
    } catch (error) {
      logger3.error("Error in GET_GITHUB_ISSUE action:", error);
      const errorContent = {
        text: `Failed to get issue information: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_ISSUE"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        text: errorContent.text,
        values: {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        },
        data: {
          actionName: "GET_GITHUB_ISSUE",
          error: error instanceof Error ? error.message : String(error)
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Get information about issue #42 in elizaOS/eliza"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Issue #42: Bug in authentication flow\nRepository: elizaOS/eliza\nState: open\nAuthor: @contributor\nCreated: 3/15/2024\nUpdated: 3/20/2024\nComments: 5\nLabels: bug, authentication\nAssignees: @maintainer\n\nDescription:\nThe authentication flow is failing when using GitHub tokens...\n\nURL: https://github.com/elizaOS/eliza/issues/42",
          actions: [
            "GET_GITHUB_ISSUE"
          ]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Check issue #123 in facebook/react and see if there are any related pull requests"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll check the details of issue #123 in facebook/react and then search for related pull requests.",
          actions: [
            "GET_GITHUB_ISSUE",
            "SEARCH_GITHUB_PULL_REQUESTS"
          ]
        }
      }
    ]
  ]
};
var listIssuesAction = {
  name: "LIST_GITHUB_ISSUES",
  similes: [
    "LIST_ISSUES",
    "SHOW_ISSUES",
    "GET_ISSUES"
  ],
  description: "Lists GitHub issues for a repository with filtering options, enabling workflows like issue triage, bulk operations, or pattern analysis across issues",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      const issueState = options.state || (text.includes("closed") ? "closed" : text.includes("all") ? "all" : "open");
      logger3.info(`Listing ${issueState} issues for ${owner}/${repo}`);
      const issues = await githubService.listIssues(owner, repo, {
        state: issueState,
        labels: options.labels,
        per_page: options.limit || 10
      });
      const issueList = issues.map((issue) => {
        const labels = issue.labels?.map((label) => typeof label === "string" ? label : label.name || "").join(", ") || "";
        return `\u2022 #${issue.number}: ${issue.title} (${issue.state})${labels ? ` [${labels}]` : ""}`;
      }).join("\n");
      const responseContent = {
        text: `${issueState.charAt(0).toUpperCase() + issueState.slice(1)} issues for ${owner}/${repo} (${issues.length} shown):
${issueList}`,
        actions: [
          "LIST_GITHUB_ISSUES"
        ],
        source: message.content.source,
        // Include data for callbacks
        issues,
        repository: `${owner}/${repo}`,
        issueCount: issues.length
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        text: responseContent.text,
        values: {
          issues,
          repository: `${owner}/${repo}`,
          issueCount: issues.length
        },
        data: {
          issues,
          github: {
            ...state?.data?.github,
            ...state?.github,
            lastIssues: issues,
            lastRepository: state?.data?.github?.lastRepository || state?.github?.lastRepository,
            issues: {
              ...state?.data?.github?.issues,
              ...state?.github?.issues,
              ...issues.reduce((acc, issue) => {
                acc[`${owner}/${repo}#${issue.number}`] = issue;
                return acc;
              }, {})
            }
          }
        }
      };
    } catch (error) {
      logger3.error("Error in LIST_GITHUB_ISSUES action:", error);
      const errorContent = {
        text: `Failed to list issues: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "LIST_GITHUB_ISSUES"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return errorContent;
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "List open issues for elizaOS/eliza"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Open issues for elizaOS/eliza (5 shown):\n\u2022 #42: Bug in authentication flow (open) [bug, authentication]\n\u2022 #41: Feature request: Add new provider (open) [enhancement]\n\u2022 #40: Documentation update needed (open) [documentation]",
          actions: [
            "LIST_GITHUB_ISSUES"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Show me high priority bugs in microsoft/vscode and check their activity"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Searching for high priority bugs in microsoft/vscode...\n\nOpen issues for microsoft/vscode (8 shown):\n\u2022 #1234: Critical: Editor crashes on large files (open) [bug, high-priority, crash]\n\u2022 #1230: Memory leak in extension host (open) [bug, high-priority, performance]\n\u2022 #1225: Terminal not responding after update (open) [bug, high-priority, terminal]\n\u2022 #1220: Debugger fails to attach (open) [bug, high-priority, debug]\n\nLet me check the recent activity on these critical issues...",
          actions: [
            "LIST_GITHUB_ISSUES",
            "GET_GITHUB_ACTIVITY"
          ]
        }
      }
    ]
  ]
};
var createIssueAction = {
  name: "CREATE_GITHUB_ISSUE",
  similes: [
    "NEW_ISSUE",
    "SUBMIT_ISSUE",
    "REPORT_ISSUE",
    "FILE_ISSUE"
  ],
  description: "Creates a new GitHub issue and enables chaining with actions like creating branches, assigning users, or linking to pull requests",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      const titleMatch = text.match(/(?:title|issue)\s*[:=]\s*["\']?([^"'\n]+)["\']?/i) || text.match(/(?:create|submit|file)\s+(?:issue|bug)?\s*["\']?([^"'\n]+)["\']?/i);
      const title = options.title || titleMatch?.[1];
      if (!title) {
        throw new Error("Issue title is required. Please specify the title for the issue");
      }
      const bodyMatch = text.match(/(?:description|body|details?)\s*[:=]\s*["\']?([^"'\n]+)["\']?/i);
      const body = options.body || bodyMatch?.[1];
      const labelsMatch = text.match(/(?:labels?)\s*[:=]\s*["\']?([^"'\n]+)["\']?/i);
      const labelsText = labelsMatch?.[1];
      const labels = options.labels || (labelsText ? labelsText.split(/[,\s]+/).filter(Boolean) : void 0);
      const issueOptions = {
        title,
        body,
        labels,
        assignees: options.assignees,
        milestone: options.milestone
      };
      logger3.info(`Creating issue in ${owner}/${repo}: ${title}`);
      const issue = await githubService.createIssue(owner, repo, issueOptions);
      const responseContent = {
        text: `Successfully created issue #${issue.number}: ${issue.title}
Repository: ${owner}/${repo}
State: ${issue.state}
Author: @${issue.user?.login || "unknown"}
Created: ${new Date(issue.created_at).toLocaleDateString()}
Labels: ${issue.labels?.map((label) => typeof label === "string" ? label : label.name || "").join(", ") || "None"}

${issue.body || "No description provided"}

URL: ${issue.html_url}`,
        actions: [
          "CREATE_GITHUB_ISSUE"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        text: responseContent.text,
        values: {
          issue,
          repository: `${owner}/${repo}`,
          issueNumber: issue.number,
          issueUrl: issue.html_url
        },
        data: {
          issue,
          github: {
            ...state?.github,
            lastIssue: issue,
            lastCreatedIssue: issue,
            issues: {
              ...state?.github?.issues,
              [`${owner}/${repo}#${issue.number}`]: issue
            }
          }
        }
      };
    } catch (error) {
      logger3.error("Error in CREATE_GITHUB_ISSUE action:", error);
      const errorContent = {
        text: `Failed to create issue: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "CREATE_GITHUB_ISSUE"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return errorContent;
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: 'Create an issue in elizaOS/eliza with title: "Authentication bug" and description: "The GitHub auth is not working properly" and add labels: bug, authentication'
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Successfully created issue #43: Authentication bug\nRepository: elizaOS/eliza\nState: open\nAuthor: @agent\nCreated: 3/21/2024\nLabels: bug, authentication\n\nThe GitHub auth is not working properly\n\nURL: https://github.com/elizaOS/eliza/issues/43",
          actions: [
            "CREATE_GITHUB_ISSUE"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Create a feature request issue in my new-project repo and then create a branch for it"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "First, I'll create the feature request issue...\n\nSuccessfully created issue #1: Add user authentication\nRepository: user/new-project\nState: open\nAuthor: @agent\nCreated: 3/21/2024\nLabels: enhancement\n\nImplement user authentication system with JWT tokens\n\nURL: https://github.com/user/new-project/issues/1\n\nNow I'll create a feature branch for this issue...",
          actions: [
            "CREATE_GITHUB_ISSUE",
            "CREATE_GITHUB_BRANCH"
          ]
        }
      }
    ]
  ]
};
var searchIssuesAction = {
  name: "SEARCH_GITHUB_ISSUES",
  similes: [
    "FIND_ISSUES",
    "SEARCH_BUGS",
    "ISSUE_SEARCH"
  ],
  description: "Searches for GitHub issues across repositories using advanced queries, enabling cross-project analysis, pattern detection, and bulk issue management workflows",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const queryMatch = text.match(/(?:search|find|look for)\s+(?:issues?\s+)?(?:for\s+)?["\']?([^"'\n]+?)["\']?(?:\s|$)/i);
      const query = options.query || queryMatch?.[1];
      if (!query) {
        throw new Error("Search query is required. Please specify what issues to search for");
      }
      logger3.info(`Searching issues for: ${query}`);
      const searchResult = await githubService.searchIssues(query, {
        sort: options.sort || "updated",
        per_page: options.limit || 10
      });
      const issueList = (searchResult.items || []).map((issue) => {
        const labels = issue.labels?.map((label) => typeof label === "string" ? label : label.name || "").join(", ") || "";
        const repoName = issue.html_url ? issue.html_url.match(/github\.com\/([^\/]+\/[^\/]+)/)?.[1] || "unknown" : "unknown";
        return `\u2022 ${repoName}#${issue.number}: ${issue.title} (${issue.state})${labels ? ` [${labels}]` : ""}`;
      }).join("\n");
      const responseContent = {
        text: `Found ${searchResult.total_count || 0} issues for "${query}" (showing ${searchResult.items?.length || 0}):
${issueList}`,
        actions: [
          "SEARCH_GITHUB_ISSUES"
        ],
        source: message.content.source,
        // Include data for callbacks
        issues: searchResult.items || [],
        totalCount: searchResult.total_count || 0,
        query
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        text: responseContent.text,
        values: {
          issues: searchResult.items,
          totalCount: searchResult.total_count,
          query
        },
        data: {
          issues: searchResult.items,
          github: {
            ...state?.data?.github,
            ...state?.github,
            lastIssueSearchResults: searchResult,
            lastIssueSearchQuery: query,
            lastRateLimit: state?.data?.github?.lastRateLimit || state?.github?.lastRateLimit,
            issues: {
              ...state?.data?.github?.issues,
              ...state?.github?.issues,
              ...(searchResult.items || []).reduce((acc, issue) => {
                const repoName = issue.html_url ? issue.html_url.match(/github\.com\/([^\/]+\/[^\/]+)/)?.[1] : null;
                if (repoName) {
                  acc[`${repoName}#${issue.number}`] = issue;
                }
                return acc;
              }, {})
            }
          }
        }
      };
    } catch (error) {
      logger3.error("Error in SEARCH_GITHUB_ISSUES action:", error);
      const errorContent = {
        text: `Failed to search issues: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "SEARCH_GITHUB_ISSUES"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return errorContent;
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Search for issues about authentication bugs"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Found 150 issues for "authentication bugs" (showing 10):\n\u2022 elizaOS/eliza#42: Authentication flow failing (open) [bug, authentication]\n\u2022 user/project#15: Auth token validation issue (closed) [bug]\n\u2022 company/app#88: Login authentication error (open) [bug, security]',
          actions: [
            "SEARCH_GITHUB_ISSUES"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Find all TypeScript migration issues across popular repos and analyze the patterns"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Found 3,250 issues for "TypeScript migration" (showing 10):\n\u2022 facebook/jest#11234: Migrate codebase to TypeScript (open) [enhancement, typescript, breaking-change]\n\u2022 expressjs/express#4567: TypeScript support roadmap (open) [enhancement, typescript, discussion]\n\u2022 webpack/webpack#8901: Convert core modules to TypeScript (in progress) [enhancement, typescript]\n\u2022 redux-saga/redux-saga#2345: TypeScript migration tracking (open) [enhancement, typescript, meta]\n\nI notice most migrations follow a phased approach. Let me check the activity on these migration efforts...',
          actions: [
            "SEARCH_GITHUB_ISSUES",
            "GET_GITHUB_ACTIVITY"
          ]
        }
      }
    ]
  ]
};

// src/actions/pullRequests.ts
import { logger as logger4 } from "@elizaos/core";
var getPullRequestAction = {
  name: "GET_GITHUB_PULL_REQUEST",
  similes: [
    "CHECK_PR",
    "FETCH_PULL_REQUEST",
    "PR_INFO",
    "INSPECT_PR"
  ],
  description: "Retrieves information about a specific GitHub pull request",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const prMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)\/pull\/(\d+)/);
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const prNumMatch = text.match(/(?:pr\s*#?|pull\s*request\s*#?|#)(\d+)/i);
      const owner = options.owner || prMatch?.[1] || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || prMatch?.[2] || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      const pull_number = options.pull_number || parseInt(prMatch?.[3] || prNumMatch?.[1] || "0", 10);
      if (!owner || !repo || !pull_number) {
        throw new Error('Repository owner, name, and PR number are required. Please specify as "owner/repo#123" or provide them in options');
      }
      logger4.info(`Getting pull request information for ${owner}/${repo}#${pull_number}`);
      const pr = await githubService.getPullRequest(owner, repo, pull_number);
      const labels = pr.labels?.map((label) => typeof label === "string" ? label : label.name || "").join(", ") || "";
      const assignees = pr.assignees?.map((assignee) => `@${assignee.login}`).join(", ") || "";
      const responseContent = {
        text: `Pull Request #${pr.number}: ${pr.title}
Repository: ${owner}/${repo}
State: ${pr.state}${pr.merged ? " (merged)" : ""}
Draft: ${pr.draft ? "Yes" : "No"}
Author: @${pr.user.login}
Created: ${new Date(pr.created_at).toLocaleDateString()}
Updated: ${new Date(pr.updated_at).toLocaleDateString()}
${pr.merged_at ? `Merged: ${new Date(pr.merged_at).toLocaleDateString()}` : ""}
Comments: ${pr.comments}
Commits: ${pr.commits}
Files Changed: ${pr.changed_files}
Additions: +${pr.additions}
Deletions: -${pr.deletions}
Labels: ${labels || "None"}
Assignees: ${assignees || "None"}
Head: ${pr.head.ref} (${pr.head.sha.substring(0, 7)})
Base: ${pr.base.ref} (${pr.base.sha.substring(0, 7)})
Mergeable: ${pr.mergeable === null ? "Unknown" : pr.mergeable ? "Yes" : "No"}

Description:
${pr.body || "No description provided"}

URL: ${pr.html_url}`,
        actions: [
          "GET_GITHUB_PULL_REQUEST"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          pullRequest: pr,
          repository: `${owner}/${repo}`,
          pullNumber: pull_number
        },
        data: {
          pullRequest: pr,
          github: {
            ...state?.github,
            lastPullRequest: pr,
            pullRequests: {
              ...state?.github?.pullRequests,
              [`${owner}/${repo}#${pull_number}`]: pr
            }
          }
        }
      };
    } catch (error) {
      logger4.error("Error in GET_GITHUB_PULL_REQUEST action:", error);
      const errorContent = {
        text: `Failed to get pull request information: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_PULL_REQUEST"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Get information about PR #25 in elizaOS/eliza"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Pull Request #25: Add new authentication provider\nRepository: elizaOS/eliza\nState: open\nDraft: No\nAuthor: @contributor\nCreated: 3/15/2024\nUpdated: 3/20/2024\nComments: 3\nCommits: 5\nFiles Changed: 8\nAdditions: +120\nDeletions: -15\nLabels: enhancement, authentication\nAssignees: @maintainer\nHead: feature/auth-provider (abc1234)\nBase: main (def5678)\nMergeable: Yes\n\nDescription:\nThis PR adds a new authentication provider for GitHub integration...\n\nURL: https://github.com/elizaOS/eliza/pull/25",
          actions: [
            "GET_GITHUB_PULL_REQUEST"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Check PR #456 in vercel/next.js and see what issues it addresses"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Pull Request #456: Fix hydration mismatch in dynamic routes\nRepository: vercel/next.js\nState: open\nDraft: No\nAuthor: @contributor\nCreated: 3/18/2024\nUpdated: 3/21/2024\nComments: 8\nCommits: 3\nFiles Changed: 12\nAdditions: +85\nDeletions: -42\nLabels: bug, hydration\nAssignees: @next-team\nHead: fix/hydration-mismatch (xyz789)\nBase: canary (abc123)\nMergeable: Yes\n\nDescription:\nFixes #445, #389 - Resolves hydration mismatches when using dynamic routes with SSR...\n\nURL: https://github.com/vercel/next.js/pull/456\n\nLet me check the referenced issues to understand what problems this PR solves...",
          actions: [
            "GET_GITHUB_PULL_REQUEST",
            "GET_GITHUB_ISSUE"
          ]
        }
      }
    ]
  ]
};
var listPullRequestsAction = {
  name: "LIST_GITHUB_PULL_REQUESTS",
  similes: [
    "LIST_PRS",
    "SHOW_PULL_REQUESTS",
    "GET_PRS"
  ],
  description: "Lists GitHub pull requests for a repository",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      const prState = options.state || (text.includes("closed") ? "closed" : text.includes("all") ? "all" : "open");
      logger4.info(`Listing ${prState} pull requests for ${owner}/${repo}`);
      const prs = await githubService.listPullRequests(owner, repo, {
        state: prState,
        head: options.head,
        base: options.base,
        per_page: options.limit || 10
      });
      const prList = prs.map((pr) => {
        const labels = pr.labels ? pr.labels.map((label) => label.name).join(", ") : "";
        const status = pr.merged ? "merged" : pr.state;
        const draft = pr.draft ? " (draft)" : "";
        return `\u2022 #${pr.number}: ${pr.title} (${status}${draft})${labels ? ` [${labels}]` : ""}`;
      }).join("\n");
      const responseContent = {
        text: `${prState.charAt(0).toUpperCase() + prState.slice(1)} pull requests for ${owner}/${repo} (${prs.length} shown):
${prList}`,
        actions: [
          "LIST_GITHUB_PULL_REQUESTS"
        ],
        source: message.content.source,
        // Include data for callbacks
        pullRequests: prs,
        repository: `${owner}/${repo}`,
        pullRequestCount: prs.length
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          pullRequests: prs,
          repository: `${owner}/${repo}`,
          pullRequestCount: prs.length
        },
        data: {
          pullRequests: prs,
          github: {
            ...state?.github,
            lastPullRequests: prs,
            pullRequests: {
              ...state?.github?.pullRequests,
              ...prs.reduce((acc, pr) => {
                acc[`${owner}/${repo}#${pr.number}`] = pr;
                return acc;
              }, {})
            }
          }
        }
      };
    } catch (error) {
      logger4.error("Error in LIST_GITHUB_PULL_REQUESTS action:", error);
      const errorContent = {
        text: `Failed to list pull requests: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "LIST_GITHUB_PULL_REQUESTS"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "List open pull requests for elizaOS/eliza"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Open pull requests for elizaOS/eliza (3 shown):\n\u2022 #25: Add new authentication provider (open) [enhancement, authentication]\n\u2022 #24: Fix memory leak in service (open) [bug]\n\u2022 #23: Update documentation (open) (draft) [documentation]",
          actions: [
            "LIST_GITHUB_PULL_REQUESTS"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Show me PRs ready for review in rust-lang/rust and check their CI status"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Open pull requests for rust-lang/rust (10 shown):\n\u2022 #98765: Optimize compiler performance for large crates (open) [performance, ready-for-review]\n\u2022 #98760: Add new lint for unsafe code patterns (open) [lint, ready-for-review]\n\u2022 #98755: Fix ICE in type inference (open) [bug, ready-for-review]\n\u2022 #98750: Implement RFC 3324 (open) [rfc, ready-for-review]\n\u2022 #98745: Update LLVM to version 16 (open) [dependencies, ready-for-review]\n\nNow let me check the CI status for these pull requests...",
          actions: [
            "LIST_GITHUB_PULL_REQUESTS",
            "GET_GITHUB_WORKFLOW_RUNS"
          ]
        }
      }
    ]
  ]
};
var createPullRequestAction = {
  name: "CREATE_GITHUB_PULL_REQUEST",
  similes: [
    "NEW_PR",
    "SUBMIT_PR",
    "CREATE_PR",
    "OPEN_PULL_REQUEST"
  ],
  description: "Creates a new GitHub pull request",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      const titleMatch = text.match(/(?:title|pr)\s*[:=]\s*["\']?([^"'\n]+)["\']?/i) || text.match(/(?:create|submit|open)\s+(?:pr|pull\s*request)?\s*["\']?([^"'\n]+)["\']?/i);
      const title = options.title || titleMatch?.[1];
      if (!title) {
        throw new Error("Pull request title is required. Please specify the title for the PR");
      }
      const branchMatch = text.match(/(?:from|head)\s*[:=]?\s*([^\s]+)(?:\s+(?:to|into|base)\s*[:=]?\s*([^\s]+))?/i);
      const head = options.head || branchMatch?.[1];
      const base = options.base || branchMatch?.[2] || "main";
      if (!head) {
        throw new Error("Head branch is required. Please specify the branch to merge from");
      }
      const bodyMatch = text.match(/(?:description|body|details?)\s*[:=]\s*["\']?([^"'\n]+)["\']?/i);
      const body = options.body || bodyMatch?.[1];
      const draft = options.draft !== void 0 ? options.draft : text.includes("draft");
      const prOptions = {
        title,
        head,
        base,
        body,
        draft,
        maintainer_can_modify: options.maintainer_can_modify
      };
      logger4.info(`Creating pull request in ${owner}/${repo}: ${title}`);
      const pr = await githubService.createPullRequest(owner, repo, prOptions);
      const responseContent = {
        text: `Successfully created pull request #${pr.number}: ${pr.title}
Repository: ${owner}/${repo}
State: ${pr.state}
Draft: ${pr.draft ? "Yes" : "No"}
Author: @${pr.user.login}
Created: ${new Date(pr.created_at).toLocaleDateString()}
Head: ${pr.head.ref}
Base: ${pr.base.ref}

${pr.body || "No description provided"}

URL: ${pr.html_url}`,
        actions: [
          "CREATE_GITHUB_PULL_REQUEST"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          pullRequest: pr,
          repository: `${owner}/${repo}`,
          pullNumber: pr.number,
          pullRequestUrl: pr.html_url
        },
        data: {
          pullRequest: pr,
          github: {
            ...state?.github,
            lastPullRequest: pr,
            lastCreatedPullRequest: pr,
            pullRequests: {
              ...state?.github?.pullRequests,
              [`${owner}/${repo}#${pr.number}`]: pr
            }
          }
        }
      };
    } catch (error) {
      logger4.error("Error in CREATE_GITHUB_PULL_REQUEST action:", error);
      const errorContent = {
        text: `Failed to create pull request: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "CREATE_GITHUB_PULL_REQUEST"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        ...errorContent
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: 'Create a pull request in elizaOS/eliza with title: "Add GitHub integration" from feature/github-integration to main with description: "This PR adds comprehensive GitHub integration capabilities"'
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Successfully created pull request #26: Add GitHub integration\nRepository: elizaOS/eliza\nState: open\nDraft: No\nAuthor: @agent\nCreated: 3/21/2024\nHead: feature/github-integration\nBase: main\n\nThis PR adds comprehensive GitHub integration capabilities\n\nURL: https://github.com/elizaOS/eliza/pull/26",
          actions: [
            "CREATE_GITHUB_PULL_REQUEST"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Create a draft PR for my bugfix branch and link it to issue #789"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "First, let me check issue #789 to understand the context...\n\nIssue #789: Database connection timeout\nRepository: user/api-server\nState: open\nLabels: bug, database, priority-high\n\nNow I'll create a draft pull request for your bugfix...\n\nSuccessfully created pull request #790: Fix database connection timeout\nRepository: user/api-server\nState: open\nDraft: Yes\nAuthor: @agent\nCreated: 3/21/2024\nHead: bugfix/db-timeout\nBase: main\n\nFixes #789 - Resolves database connection timeout issues by implementing connection pooling\n\nURL: https://github.com/user/api-server/pull/790",
          actions: [
            "GET_GITHUB_ISSUE",
            "CREATE_GITHUB_PULL_REQUEST"
          ]
        }
      }
    ]
  ]
};
var mergePullRequestAction = {
  name: "MERGE_GITHUB_PULL_REQUEST",
  similes: [
    "MERGE_PR",
    "ACCEPT_PR",
    "APPROVE_PR"
  ],
  description: "Merges a GitHub pull request",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const prMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)\/pull\/(\d+)/);
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const prNumMatch = text.match(/(?:pr\s*#?|pull\s*request\s*#?|#)(\d+)/i);
      const owner = options.owner || prMatch?.[1] || ownerRepoMatch?.[1] || state?.github?.lastPullRequest?.base?.repo?.owner?.login || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || prMatch?.[2] || ownerRepoMatch?.[2] || state?.github?.lastPullRequest?.base?.repo?.name || state?.github?.lastRepository?.name;
      const pull_number = options.pull_number || parseInt(prMatch?.[3] || prNumMatch?.[1] || "0", 10) || state?.github?.lastPullRequest?.number;
      if (!owner || !repo || !pull_number) {
        throw new Error('Repository owner, name, and PR number are required. Please specify as "owner/repo#123" or provide them in options');
      }
      const mergeMethod = options.merge_method || (text.includes("squash") ? "squash" : text.includes("rebase") ? "rebase" : "merge");
      logger4.info(`Merging pull request ${owner}/${repo}#${pull_number} using ${mergeMethod}`);
      const result = await githubService.mergePullRequest(owner, repo, pull_number, {
        commit_title: options.commit_title,
        commit_message: options.commit_message,
        merge_method: mergeMethod
      });
      const responseContent = {
        text: `Successfully merged pull request #${pull_number}
Repository: ${owner}/${repo}
Merge method: ${mergeMethod}
Commit SHA: ${result.sha}
Message: ${result.message}`,
        actions: [
          "MERGE_GITHUB_PULL_REQUEST"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          merged: true,
          repository: `${owner}/${repo}`,
          pullNumber: pull_number,
          sha: result.sha
        },
        data: {
          mergeResult: result,
          github: {
            ...state?.github,
            lastMergeResult: result,
            lastMergedPullRequest: pull_number
          }
        }
      };
    } catch (error) {
      logger4.error("Error in MERGE_GITHUB_PULL_REQUEST action:", error);
      const errorContent = {
        text: `Failed to merge pull request: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "MERGE_GITHUB_PULL_REQUEST"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        ...errorContent
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Merge PR #25 in elizaOS/eliza using squash method"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Successfully merged pull request #25\nRepository: elizaOS/eliza\nMerge method: squash\nCommit SHA: abc123def456\nMessage: Pull request successfully merged",
          actions: [
            "MERGE_GITHUB_PULL_REQUEST"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Review and merge the documentation PR if all checks pass"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Let me check the most recent documentation PR...\n\nPull Request #23: Update documentation (open)\nRepository: user/project\nMergeable: Yes\nAll checks passing: \u2713\n\nThe PR looks good with all checks passing. I'll merge it now...\n\nSuccessfully merged pull request #23\nRepository: user/project\nMerge method: merge\nCommit SHA: def789abc123\nMessage: Merge pull request #23 from user/update-docs\n\nNow let me update the activity log...",
          actions: [
            "GET_GITHUB_PULL_REQUEST",
            "MERGE_GITHUB_PULL_REQUEST",
            "GET_GITHUB_ACTIVITY"
          ]
        }
      }
    ]
  ]
};

// src/actions/activity.ts
import { logger as logger5 } from "@elizaos/core";
var getGitHubActivityAction = {
  name: "GET_GITHUB_ACTIVITY",
  similes: [
    "SHOW_ACTIVITY",
    "GITHUB_LOG",
    "ACTIVITY_LOG",
    "GITHUB_HISTORY"
  ],
  description: "Shows recent GitHub activity performed by the agent",
  validate: /* @__PURE__ */ __name(async (runtime, _message, _state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const limit = options.limit || 20;
      const activityLog = githubService.getActivityLog(limit);
      let filteredActivity = activityLog;
      if (options.filter && options.filter !== "all") {
        filteredActivity = activityLog.filter((item) => options.filter === "success" ? item.success : !item.success);
      }
      if (options.resource_type) {
        filteredActivity = filteredActivity.filter((item) => item.resource_type === options.resource_type);
      }
      if (filteredActivity.length === 0) {
        const responseContent2 = {
          text: "No GitHub activity found matching the specified criteria.",
          actions: [
            "GET_GITHUB_ACTIVITY"
          ],
          source: message.content.source
        };
        if (callback) {
          await callback(responseContent2);
        }
        return {
          success: true,
          text: responseContent2.text,
          values: {
            activityCount: 0,
            activity: []
          },
          data: {
            activity: [],
            github: state?.github || {}
          }
        };
      }
      const activityByDate = filteredActivity.reduce((acc, activity) => {
        const date = new Date(activity.timestamp).toLocaleDateString();
        if (!acc[date]) {
          acc[date] = [];
        }
        acc[date].push(activity);
        return acc;
      }, {});
      const activityText = Object.entries(activityByDate).sort(([a], [b]) => new Date(b).getTime() - new Date(a).getTime()).map(([date, activities]) => {
        const activityList = activities.map((activity) => {
          const time = new Date(activity.timestamp).toLocaleTimeString();
          const status = activity.success ? "\u2705" : "\u274C";
          const action = activity.action.replace(/_/g, " ").toLowerCase();
          return `  ${time} ${status} ${action} ${activity.resource_type} ${activity.resource_id}${activity.error ? ` (${activity.error})` : ""}`;
        }).join("\n");
        return `**${date}**
${activityList}`;
      }).join("\n\n");
      const successCount = filteredActivity.filter((a) => a.success).length;
      const failureCount = filteredActivity.filter((a) => !a.success).length;
      const responseContent = {
        text: `GitHub Activity Log (${filteredActivity.length} entries)
Success: ${successCount} | Failed: ${failureCount}

${activityText}`,
        actions: [
          "GET_GITHUB_ACTIVITY"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          activity: filteredActivity,
          activityCount: filteredActivity.length,
          successCount,
          failureCount
        },
        data: {
          activity: filteredActivity,
          github: {
            ...state?.github,
            lastActivityLog: filteredActivity,
            activityStats: {
              total: filteredActivity.length,
              success: successCount,
              failed: failureCount
            }
          }
        }
      };
    } catch (error) {
      logger5.error("Error in GET_GITHUB_ACTIVITY action:", error);
      const errorContent = {
        text: `Failed to get GitHub activity: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_ACTIVITY"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          cleared: false
        },
        data: {
          github: {
            ...state?.github,
            lastActivityLog: [],
            activityStats: {
              total: 0,
              success: 0,
              failed: 0
            }
          }
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Show me my recent GitHub activity"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub Activity Log (5 entries)\nSuccess: 4 | Failed: 1\n\n**3/21/2024**\n  2:30 PM \u2705 create issue issue elizaOS/eliza#43\n  2:25 PM \u2705 get repository repository elizaOS/eliza\n  2:20 PM \u274C create repository repository invalid-name (Repository name is invalid)\n\n**3/20/2024**\n  4:15 PM \u2705 list repositories repository authenticated_user\n  3:45 PM \u2705 search repositories repository search",
          actions: [
            "GET_GITHUB_ACTIVITY"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Show me what went wrong with my recent GitHub operations and check my rate limit"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub Activity Log (3 failed entries)\nSuccess: 0 | Failed: 3\n\n**3/21/2024**\n  3:45 PM \u274C create pull_request pull_request user/repo#0 (Base branch does not exist)\n  3:30 PM \u274C merge pull_request pull_request user/repo#15 (PR has merge conflicts)\n  3:15 PM \u274C create repository repository @invalid/name (Repository name is invalid)\n\nLet me check your current API rate limit status...",
          actions: [
            "GET_GITHUB_ACTIVITY",
            "GET_GITHUB_RATE_LIMIT"
          ]
        }
      }
    ]
  ]
};
var clearGitHubActivityAction = {
  name: "CLEAR_GITHUB_ACTIVITY",
  similes: [
    "CLEAR_LOG",
    "RESET_ACTIVITY",
    "CLEAR_HISTORY"
  ],
  description: "Clears the GitHub activity log",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      githubService.clearActivityLog();
      const responseContent = {
        text: "GitHub activity log has been cleared.",
        actions: [
          "CLEAR_GITHUB_ACTIVITY"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          cleared: true
        },
        data: {
          github: {
            ...state?.github,
            lastActivityLog: [],
            activityStats: {
              total: 0,
              success: 0,
              failed: 0
            }
          }
        }
      };
    } catch (error) {
      logger5.error("Error in CLEAR_GITHUB_ACTIVITY action:", error);
      const errorContent = {
        text: `Failed to clear GitHub activity: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "CLEAR_GITHUB_ACTIVITY"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          cleared: false
        },
        data: {
          github: {
            ...state?.github,
            lastActivityLog: [],
            activityStats: {
              total: 0,
              success: 0,
              failed: 0
            }
          }
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Clear my GitHub activity log"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub activity log has been cleared.",
          actions: [
            "CLEAR_GITHUB_ACTIVITY"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Clear the activity log and start fresh with listing my repositories"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub activity log has been cleared.\n\nNow let me list your repositories to start fresh...",
          actions: [
            "CLEAR_GITHUB_ACTIVITY",
            "LIST_GITHUB_REPOSITORIES"
          ]
        }
      }
    ]
  ]
};
var getGitHubRateLimitAction = {
  name: "GET_GITHUB_RATE_LIMIT",
  similes: [
    "CHECK_RATE_LIMIT",
    "RATE_LIMIT_STATUS",
    "API_LIMITS"
  ],
  description: "Shows current GitHub API rate limit status",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const rateLimit = await githubService.getRateLimit();
      const resetTime = new Date(rateLimit.reset * 1e3);
      const now = /* @__PURE__ */ new Date();
      const resetInMinutes = Math.ceil((resetTime.getTime() - now.getTime()) / (1e3 * 60));
      const responseContent = {
        text: `GitHub API Rate Limit Status:
Limit: ${rateLimit.limit} requests per hour
Used: ${rateLimit.used} requests
Remaining: ${rateLimit.remaining} requests
Reset Time: ${resetTime.toLocaleString()}
Reset In: ${resetInMinutes} minutes
Resource: ${rateLimit.resource}

Usage: ${Math.round(rateLimit.used / rateLimit.limit * 100)}%`,
        actions: [
          "GET_GITHUB_RATE_LIMIT"
        ],
        source: message.content.source,
        rateLimit,
        data: {
          ...state?.data,
          rateLimit
        }
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          rateLimit,
          remaining: rateLimit.remaining,
          resetInMinutes
        },
        data: {
          rateLimit,
          github: {
            ...state?.github,
            lastRateLimit: rateLimit
          }
        }
      };
    } catch (error) {
      logger5.error("Error in GET_GITHUB_RATE_LIMIT action:", error);
      const errorContent = {
        text: `Failed to get rate limit status: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_RATE_LIMIT"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        values: {
          cleared: false
        },
        data: {
          github: {
            ...state?.github,
            lastRateLimit: null
          }
        }
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Check my GitHub API rate limit"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub API Rate Limit Status:\nLimit: 5000 requests per hour\nUsed: 127 requests\nRemaining: 4873 requests\nReset Time: 3/21/2024, 3:45:00 PM\nReset In: 23 minutes\nResource: core\n\nUsage: 3%",
          actions: [
            "GET_GITHUB_RATE_LIMIT"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Check if I have enough API calls left to search through 100 repositories"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub API Rate Limit Status:\nLimit: 5000 requests per hour\nUsed: 2341 requests\nRemaining: 2659 requests\nReset Time: 3/21/2024, 4:00:00 PM\nReset In: 35 minutes\nResource: core\n\nUsage: 47%\n\nYou have 2659 requests remaining, which is more than enough to search through 100 repositories. Each search typically uses 1-2 API calls, so you should be fine. Let me start the repository search...",
          actions: [
            "GET_GITHUB_RATE_LIMIT",
            "SEARCH_GITHUB_REPOSITORIES"
          ]
        }
      }
    ]
  ]
};

// src/actions/search.ts
import { logger as logger6 } from "@elizaos/core";
var searchGitHubAction = {
  name: "SEARCH_GITHUB",
  similes: [
    "GITHUB_SEARCH",
    "FIND_ON_GITHUB",
    "SEARCH_ALL"
  ],
  description: "Comprehensive GitHub search across repositories, issues, and pull requests",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const queryMatch = text.match(/(?:search|find)\s+(?:for\s+)?["\']?([^"'\n]+?)["\']?(?:\s|$)/i);
      const query = options.query || queryMatch?.[1];
      if (!query) {
        throw new Error("Search query is required");
      }
      const searchType = options.type || (text.includes("issue") ? "issues" : text.includes("pr") || text.includes("pull request") ? "pull_requests" : text.includes("repo") ? "repositories" : "all");
      const results = {};
      let responseText = "";
      if (searchType === "all" || searchType === "repositories") {
        const repos = await githubService.searchRepositories(query, {
          sort: "stars",
          per_page: options.limit || 5
        });
        results.repositories = repos.items;
        if (repos.items.length > 0) {
          responseText += `**Repositories (${repos.total_count} total):**
`;
          responseText += repos.items.map((r) => `\u2022 ${r.full_name} - \u2B50 ${r.stargazers_count} - ${r.description || "No description"}`).join("\n");
          responseText += "\n\n";
        }
      }
      if (searchType === "all" || searchType === "issues") {
        const issues = await githubService.searchIssues(`${query} is:issue`, {
          sort: "updated",
          per_page: options.limit || 5
        });
        results.issues = issues.items;
        if (issues.items.length > 0) {
          responseText += `**Issues (${issues.total_count} total):**
`;
          responseText += issues.items.map((i) => {
            const repoName = i.html_url ? i.html_url.match(/github\.com\/([^\/]+\/[^\/]+)/)?.[1] : "unknown";
            return `\u2022 ${repoName}#${i.number}: ${i.title} (${i.state})`;
          }).join("\n");
          responseText += "\n\n";
        }
      }
      if (searchType === "all" || searchType === "pull_requests") {
        const prs = await githubService.searchIssues(`${query} is:pr`, {
          sort: "updated",
          per_page: options.limit || 5
        });
        results.pullRequests = prs.items;
        if (prs.items.length > 0) {
          responseText += `**Pull Requests (${prs.total_count} total):**
`;
          responseText += prs.items.map((pr) => {
            const repoName = pr.html_url ? pr.html_url.match(/github\.com\/([^\/]+\/[^\/]+)/)?.[1] : "unknown";
            return `\u2022 ${repoName}#${pr.number}: ${pr.title} (${pr.state})`;
          }).join("\n");
          responseText += "\n\n";
        }
      }
      if (!responseText) {
        responseText = `No results found for "${query}"`;
      } else {
        responseText = `Search results for "${query}":

${responseText.trim()}`;
      }
      const responseContent = {
        text: responseText,
        actions: [
          "SEARCH_GITHUB"
        ],
        source: message.content.source,
        // Include data for callbacks
        results,
        query,
        searchType
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          results,
          query,
          searchType
        },
        data: {
          searchResults: results,
          github: {
            ...state?.github,
            lastSearchResults: results,
            lastSearchQuery: query,
            lastSearchType: searchType
          }
        }
      };
    } catch (error) {
      logger6.error("Error in SEARCH_GITHUB action:", error);
      const errorContent = {
        text: `Failed to search GitHub: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "SEARCH_GITHUB"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: 'Search GitHub for "machine learning"'
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Search results for "machine learning":\n\n**Repositories (150,000 total):**\n\u2022 tensorflow/tensorflow - \u2B50 185000 - An Open Source Machine Learning Framework for Everyone\n\u2022 scikit-learn/scikit-learn - \u2B50 59000 - machine learning in Python\n\u2022 pytorch/pytorch - \u2B50 75000 - Tensors and Dynamic neural networks in Python\n\u2022 keras-team/keras - \u2B50 61000 - Deep Learning for humans\n\u2022 apache/spark - \u2B50 38000 - Apache Spark - A unified analytics engine\n\n**Issues (25,000 total):**\n\u2022 tensorflow/tensorflow#58432: Add support for new optimizer (open)\n\u2022 scikit-learn/scikit-learn#24567: Bug in RandomForest prediction (open)',
          actions: [
            "SEARCH_GITHUB"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: 'Find everything related to "GraphQL Apollo" on GitHub'
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Search results for "GraphQL Apollo":\n\n**Repositories (8,500 total):**\n\u2022 apollographql/apollo-server - \u2B50 13500 - \u{1F30D} Spec-compliant GraphQL server\n\u2022 apollographql/apollo-client - \u2B50 19000 - \u{1F680} A fully-featured GraphQL client\n\u2022 apollographql/apollo - \u2B50 2300 - \u{1F680} The Apollo GraphQL platform\n\n**Issues (2,100 total):**\n\u2022 apollographql/apollo-client#9876: Cache invalidation not working properly (open)\n\u2022 apollographql/apollo-server#5432: Federation v2 support (closed)\n\n**Pull Requests (890 total):**\n\u2022 apollographql/apollo-client#9890: Fix subscription memory leak (open)\n\u2022 apollographql/apollo-server#5445: Add custom scalar support (merged)\n\nWould you like me to dive deeper into any of these results?',
          actions: [
            "SEARCH_GITHUB"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Search for TypeScript issues in popular frameworks"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Search results for "TypeScript issues in popular frameworks":\n\n**Issues (12,345 total):**\n\u2022 microsoft/vscode#98765: TypeScript 5.0 support (open)\n\u2022 angular/angular#45678: Type inference regression in v15 (open)\n\u2022 vuejs/core#8901: TypeScript strict mode compatibility (closed)\n\u2022 facebook/react#23456: JSX transform TypeScript types (open)\n\u2022 nestjs/nest#7890: Decorator metadata issues with TS 5.0 (open)\n\n**Pull Requests (3,456 total):**\n\u2022 DefinitelyTyped/DefinitelyTyped#67890: Update React types for v18 (open)\n\u2022 microsoft/TypeScript#54321: Fix generic constraint inference (merged)\n\u2022 angular/angular#45679: Fix TypeScript 5.0 compatibility (open)\n\nThese results show active TypeScript-related development across major frameworks. Would you like me to search for something more specific?',
          actions: [
            "SEARCH_GITHUB"
          ]
        }
      }
    ]
  ]
};

// src/actions/users.ts
import { logger as logger7 } from "@elizaos/core";
var getUserProfileAction = {
  name: "GET_GITHUB_USER",
  similes: [
    "GET_USER",
    "USER_PROFILE",
    "CHECK_USER",
    "USER_INFO"
  ],
  description: "Retrieves detailed information about a GitHub user",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const usernameMatch = text.match(/@?([a-zA-Z0-9](?:[a-zA-Z0-9]|-(?=[a-zA-Z0-9])){0,38})/);
      const username = options.username || usernameMatch?.[1];
      if (!username) {
        logger7.info("No username provided, getting authenticated user");
        const user2 = await githubService.getCurrentUser();
        const responseContent2 = {
          text: `Your GitHub Profile:
Username: @${user2.login}
Name: ${user2.name || "Not set"}
Bio: ${user2.bio || "No bio"}
Company: ${user2.company || "Not specified"}
Location: ${user2.location || "Not specified"}
Email: ${user2.email || "Not public"}
Twitter: ${user2.twitter_username ? `@${user2.twitter_username}` : "Not linked"}
Blog: ${user2.blog || "No blog"}

Public Repos: ${user2.public_repos}
Public Gists: ${user2.public_gists}
Followers: ${user2.followers}
Following: ${user2.following}

Created: ${new Date(user2.created_at).toLocaleDateString()}
Updated: ${new Date(user2.updated_at).toLocaleDateString()}

Profile URL: ${user2.html_url}`,
          actions: [
            "GET_GITHUB_USER"
          ],
          source: message.content.source
        };
        if (callback) {
          await callback(responseContent2);
        }
        return {
          success: true,
          text: responseContent2.text,
          values: {
            user: user2,
            username: user2.login
          },
          data: {
            user: user2,
            github: {
              ...state?.github,
              lastUser: user2,
              currentUser: user2
            }
          }
        };
      }
      logger7.info(`Getting user information for ${username}`);
      const user = await githubService.getUser(username);
      const responseContent = {
        text: `GitHub User: @${user.login}
Name: ${user.name || "Not set"}
Bio: ${user.bio || "No bio"}
Company: ${user.company || "Not specified"}
Location: ${user.location || "Not specified"}
Email: ${user.email || "Not public"}
Twitter: ${user.twitter_username ? `@${user.twitter_username}` : "Not linked"}
Blog: ${user.blog || "No blog"}
Type: ${user.type}

Public Repos: ${user.public_repos}
Public Gists: ${user.public_gists}
Followers: ${user.followers}
Following: ${user.following}

Created: ${new Date(user.created_at).toLocaleDateString()}
Updated: ${new Date(user.updated_at).toLocaleDateString()}

Profile URL: ${user.html_url}`,
        actions: [
          "GET_GITHUB_USER"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          user,
          username: user.login
        },
        data: {
          user,
          github: {
            ...state?.github,
            lastUser: user,
            users: {
              ...state?.github?.users,
              [user.login]: user
            }
          }
        }
      };
    } catch (error) {
      logger7.error("Error in GET_GITHUB_USER action:", error);
      const errorContent = {
        text: `Failed to get user information: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_USER"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Get information about @octocat"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub User: @octocat\nName: The Octocat\nBio: GitHub mascot\nCompany: @github\nLocation: San Francisco\nEmail: Not public\nTwitter: Not linked\nBlog: https://github.blog\nType: User\n\nPublic Repos: 8\nPublic Gists: 8\nFollowers: 3938\nFollowing: 9\n\nCreated: 1/25/2011\nUpdated: 3/21/2024\n\nProfile URL: https://github.com/octocat",
          actions: [
            "GET_GITHUB_USER"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Check torvalds profile and see his top repositories"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub User: @torvalds\nName: Linus Torvalds\nBio: Creator of Linux\nCompany: Linux Foundation\nLocation: Portland, OR\nEmail: Not public\nTwitter: Not linked\nBlog: Not specified\nType: User\n\nPublic Repos: 6\nPublic Gists: 0\nFollowers: 171234\nFollowing: 0\n\nCreated: 9/3/2011\nUpdated: 3/21/2024\n\nProfile URL: https://github.com/torvalds\n\nNow let me check his repositories...",
          actions: [
            "GET_GITHUB_USER",
            "LIST_USER_REPOSITORIES"
          ]
        }
      }
    ]
  ]
};
var getUserStatsAction = {
  name: "GET_GITHUB_USER_STATS",
  similes: [
    "USER_STATS",
    "USER_ACTIVITY",
    "USER_CONTRIBUTIONS"
  ],
  description: "Gets comprehensive statistics about a GitHub user including contributions and language breakdown",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const usernameMatch = text.match(/@?([a-zA-Z0-9](?:[a-zA-Z0-9]|-(?=[a-zA-Z0-9])){0,38})/);
      const username = options.username || usernameMatch?.[1] || (await githubService.getCurrentUser()).login;
      logger7.info(`Getting stats for user ${username}`);
      const repos = await githubService.listUserRepositories(username, {
        type: "owner",
        sort: "updated",
        per_page: 100
      });
      const languageStats = {};
      let totalStars = 0;
      let totalForks = 0;
      let totalIssues = 0;
      for (const repo of repos) {
        if (repo.language) {
          languageStats[repo.language] = (languageStats[repo.language] || 0) + 1;
        }
        totalStars += repo.stargazers_count || 0;
        totalForks += repo.forks_count || 0;
        totalIssues += repo.open_issues_count || 0;
      }
      const sortedLanguages = Object.entries(languageStats).sort(([, a], [, b]) => b - a).slice(0, 5);
      const events = await githubService.listUserEvents(username, {
        per_page: 100
      });
      const eventTypes = {};
      for (const event of events) {
        eventTypes[event.type] = (eventTypes[event.type] || 0) + 1;
      }
      const recentCommits = events.filter((e) => e.type === "PushEvent").length;
      const recentPRs = events.filter((e) => e.type === "PullRequestEvent").length;
      const recentIssues = events.filter((e) => e.type === "IssuesEvent").length;
      const responseContent = {
        text: `GitHub Stats for @${username}:

**Repository Statistics:**
Total Repositories: ${repos.length}
Total Stars Received: \u2B50 ${totalStars}
Total Forks: \u{1F374} ${totalForks}
Total Open Issues: \u{1F4DD} ${totalIssues}

**Top Languages:**
${sortedLanguages.map(([lang, count]) => `\u2022 ${lang}: ${count} repos`).join("\n") || "No languages detected"}

**Recent Activity (last 100 events):**
Push Events (Commits): ${recentCommits}
Pull Request Events: ${recentPRs}
Issue Events: ${recentIssues}
Total Events: ${events.length}

**Most Popular Repositories:**
${repos.sort((a, b) => (b.stargazers_count || 0) - (a.stargazers_count || 0)).slice(0, 5).map((r) => `\u2022 ${r.name} - \u2B50 ${r.stargazers_count || 0} - ${r.description || "No description"}`).join("\n")}`,
        actions: [
          "GET_GITHUB_USER_STATS"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          username,
          stats: {
            totalRepos: repos.length,
            totalStars,
            totalForks,
            totalIssues,
            languages: languageStats,
            recentActivity: {
              commits: recentCommits,
              pullRequests: recentPRs,
              issues: recentIssues,
              totalEvents: events.length
            }
          }
        },
        data: {
          stats: {
            username,
            repositories: repos,
            languageStats,
            events,
            eventTypes
          },
          github: {
            ...state?.github,
            userStats: {
              ...state?.github?.userStats,
              [username]: {
                repos: repos.length,
                stars: totalStars,
                forks: totalForks,
                languages: languageStats,
                lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
              }
            }
          }
        }
      };
    } catch (error) {
      logger7.error("Error in GET_GITHUB_USER_STATS action:", error);
      const errorContent = {
        text: `Failed to get user stats: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_USER_STATS"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        ...errorContent
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Get stats for @gaearon"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub Stats for @gaearon:\n\n**Repository Statistics:**\nTotal Repositories: 245\nTotal Stars Received: \u2B50 89234\nTotal Forks: \u{1F374} 12456\nTotal Open Issues: \u{1F4DD} 234\n\n**Top Languages:**\n\u2022 JavaScript: 178 repos\n\u2022 TypeScript: 45 repos\n\u2022 HTML: 12 repos\n\u2022 CSS: 8 repos\n\u2022 Shell: 2 repos\n\n**Recent Activity (last 100 events):**\nPush Events (Commits): 34\nPull Request Events: 12\nIssue Events: 8\nTotal Events: 100\n\n**Most Popular Repositories:**\n\u2022 redux - \u2B50 60234 - Predictable state container for JavaScript apps\n\u2022 react-hot-loader - \u2B50 12456 - Live editing of React\n\u2022 overreacted.io - \u2B50 6789 - Personal blog by Dan Abramov\n\u2022 whatthefuck.is - \u2B50 4567 - An opinionated glossary of computer science terms\n\u2022 react-dnd - \u2B50 3456 - Drag and Drop for React",
          actions: [
            "GET_GITHUB_USER_STATS"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Show me my GitHub statistics and language breakdown"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "GitHub Stats for @user:\n\n**Repository Statistics:**\nTotal Repositories: 42\nTotal Stars Received: \u2B50 156\nTotal Forks: \u{1F374} 23\nTotal Open Issues: \u{1F4DD} 8\n\n**Top Languages:**\n\u2022 TypeScript: 15 repos\n\u2022 JavaScript: 12 repos\n\u2022 Python: 8 repos\n\u2022 Go: 4 repos\n\u2022 Rust: 3 repos\n\n**Recent Activity (last 100 events):**\nPush Events (Commits): 67\nPull Request Events: 8\nIssue Events: 5\nTotal Events: 100\n\n**Most Popular Repositories:**\n\u2022 awesome-project - \u2B50 45 - A really cool project\n\u2022 my-cli-tool - \u2B50 34 - Useful CLI tool for developers\n\u2022 react-components - \u2B50 28 - Reusable React components\n\u2022 api-wrapper - \u2B50 21 - API wrapper for various services\n\u2022 dotfiles - \u2B50 18 - My personal dotfiles\n\nYour most active language is TypeScript, and you've been quite active with 67 commits recently!",
          actions: [
            "GET_GITHUB_USER_STATS"
          ]
        }
      }
    ]
  ]
};
var listUserRepositoriesAction = {
  name: "LIST_USER_REPOSITORIES",
  similes: [
    "USER_REPOS",
    "USER_PROJECTS",
    "GET_USER_REPOS"
  ],
  description: "Lists repositories for a specific GitHub user",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const usernameMatch = text.match(/@?([a-zA-Z0-9](?:[a-zA-Z0-9]|-(?=[a-zA-Z0-9])){0,38})/);
      const username = options.username || usernameMatch?.[1] || state?.github?.lastUser?.login;
      if (!username) {
        throw new Error("Username is required. Please specify a GitHub username");
      }
      logger7.info(`Listing repositories for user ${username}`);
      const repos = await githubService.listUserRepositories(username, {
        type: options.type || "owner",
        sort: options.sort || "updated",
        per_page: options.limit || 10
      });
      const repoList = repos.map((repo) => `\u2022 ${repo.name} (${repo.language || "Unknown"}) - \u2B50 ${repo.stargazers_count}${repo.fork ? " (fork)" : ""}${repo.description ? `
  ${repo.description}` : ""}`).join("\n");
      const responseContent = {
        text: `Repositories for @${username} (${repos.length} shown):
${repoList}`,
        actions: [
          "LIST_USER_REPOSITORIES"
        ],
        source: message.content.source,
        // Include data for callbacks
        repositories: repos,
        username
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          repositories: repos,
          username,
          repositoryCount: repos.length
        },
        data: {
          repositories: repos,
          github: {
            ...state?.github,
            userRepositories: {
              ...state?.github?.userRepositories,
              [username]: repos
            }
          }
        }
      };
    } catch (error) {
      logger7.error("Error in LIST_USER_REPOSITORIES action:", error);
      const errorContent = {
        text: `Failed to list user repositories: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "LIST_USER_REPOSITORIES"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        ...errorContent
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "List repositories for @sindresorhus"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Repositories for @sindresorhus (10 shown):\n\u2022 awesome - (Unknown) - \u2B50 285234\n  \u{1F60E} Awesome lists about all kinds of interesting topics\n\u2022 awesome-nodejs - (Unknown) - \u2B50 54567\n  \u26A1 Delightful Node.js packages and resources\n\u2022 got - (TypeScript) - \u2B50 13456\n  \u{1F310} Human-friendly and powerful HTTP request library for Node.js\n\u2022 ora - (JavaScript) - \u2B50 8901\n  Elegant terminal spinner\n\u2022 execa - (JavaScript) - \u2B50 5678\n  Process execution for humans\n\u2022 p-limit - (JavaScript) - \u2B50 1234\n  Run multiple promise-returning & async functions with limited concurrency",
          actions: [
            "LIST_USER_REPOSITORIES"
          ]
        }
      }
    ]
  ]
};

// src/actions/branches.ts
import { logger as logger8 } from "@elizaos/core";
var listBranchesAction = {
  name: "LIST_GITHUB_BRANCHES",
  similes: [
    "LIST_BRANCHES",
    "SHOW_BRANCHES",
    "GET_BRANCHES",
    "BRANCH_LIST"
  ],
  description: "Lists branches in a GitHub repository, sorted by last commit date",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options?.owner || ownerRepoMatch?.[1] || state?.data?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options?.repo || ownerRepoMatch?.[2] || state?.data?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      logger8.info(`Listing branches for ${owner}/${repo}`);
      const allBranches = [];
      let page = 1;
      const perPage = 100;
      while (true) {
        const branches = await githubService.listBranches(owner, repo);
        allBranches.push(...branches);
        if (branches.length < perPage) {
          break;
        }
        page++;
      }
      const branchesWithDetails = await Promise.all(allBranches.slice(0, options?.limit || 20).map(async (branch) => {
        try {
          const branchData = await githubService.getBranch(owner, repo, branch.name);
          return {
            name: branch.name,
            protected: branch.protected,
            commit: {
              sha: branchData.commit.sha,
              message: branchData.commit.commit.message.split("\n")[0],
              author: branchData.commit.commit.author?.name || "Unknown",
              date: branchData.commit.commit.author?.date || (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          return {
            name: branch.name,
            protected: branch.protected,
            commit: {
              sha: branch.commit.sha,
              message: "Unable to fetch commit details",
              author: "Unknown",
              date: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        }
      }));
      branchesWithDetails.sort((a, b) => new Date(b.commit.date).getTime() - new Date(a.commit.date).getTime());
      const filteredBranches = options?.protected !== void 0 ? branchesWithDetails.filter((b) => b.protected === options?.protected) : branchesWithDetails;
      const branchList = filteredBranches.map((branch) => {
        const date = new Date(branch.commit.date);
        const timeAgo = getTimeAgo(date);
        return `\u2022 ${branch.name}${branch.protected ? " \u{1F512}" : ""}
  Last commit: ${timeAgo} by ${branch.commit.author}
  "${branch.commit.message}"
  SHA: ${branch.commit.sha.substring(0, 7)}`;
      }).join("\n\n");
      const responseContent = {
        text: `Branches for ${owner}/${repo} (${filteredBranches.length} shown, ${allBranches.length} total):

${branchList}`,
        actions: [
          "LIST_GITHUB_BRANCHES"
        ],
        source: message.content.source,
        // Include data for callbacks
        branches: filteredBranches,
        repository: `${owner}/${repo}`,
        totalBranches: allBranches.length
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          branches: filteredBranches,
          repository: `${owner}/${repo}`,
          branchCount: filteredBranches.length,
          totalBranches: allBranches.length
        },
        data: {
          branches: filteredBranches,
          github: {
            ...state?.github,
            lastBranches: filteredBranches,
            branches: {
              ...state?.github?.branches,
              [`${owner}/${repo}`]: filteredBranches
            }
          }
        }
      };
    } catch (error) {
      logger8.error("Error in LIST_GITHUB_BRANCHES action:", error);
      const errorContent = {
        text: `Failed to list branches: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "LIST_GITHUB_BRANCHES"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "List branches for facebook/react"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Branches for facebook/react (20 shown, 145 total):\n\n\u2022 main \u{1F512}\n  Last commit: 2 hours ago by React Bot\n  "Update experimental API docs"\n  SHA: abc1234\n\n\u2022 18.x \u{1F512}\n  Last commit: 3 days ago by Dan Abramov\n  "Backport fix for hydration warning"\n  SHA: def5678\n\n\u2022 experimental\n  Last commit: 5 days ago by Andrew Clark\n  "Experimental: Add new Suspense features"\n  SHA: ghi9012',
          actions: [
            "LIST_GITHUB_BRANCHES"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Show me the most recently updated branches in my project repo and check for stale branches"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Branches for user/project (15 shown, 23 total):\n\n\u2022 feature/new-api\n  Last commit: 1 hour ago by You\n  "Add REST API endpoints"\n  SHA: abc1234\n\n\u2022 main \u{1F512}\n  Last commit: 2 days ago by GitHub Actions\n  "Merge pull request #45 from user/feature/auth"\n  SHA: def5678\n\n\u2022 feature/auth\n  Last commit: 3 days ago by You\n  "Implement JWT authentication"\n  SHA: ghi9012\n\n\u2022 bugfix/memory-leak\n  Last commit: 2 weeks ago by Contributor\n  "Fix memory leak in service worker"\n  SHA: jkl3456\n\n\u2022 feature/old-feature\n  Last commit: 3 months ago by Former Contributor\n  "WIP: Started new feature"\n  SHA: mno7890\n\nI notice you have some potentially stale branches:\n- feature/old-feature: Last updated 3 months ago\n- Several other branches not shown are over 6 months old\n\nWould you like me to help identify which branches can be safely deleted?',
          actions: [
            "LIST_GITHUB_BRANCHES"
          ]
        }
      }
    ]
  ]
};
var createBranchAction = {
  name: "CREATE_GITHUB_BRANCH",
  similes: [
    "NEW_BRANCH",
    "MAKE_BRANCH",
    "BRANCH_FROM"
  ],
  description: "Creates a new branch in a GitHub repository",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const branchMatch = text.match(/(?:branch|called|named)\s+["\']?([a-zA-Z0-9._\/-]+)["\']?/i);
      const fromMatch = text.match(/(?:from|based on|off)\s+["\']?([a-zA-Z0-9._\/-]+)["\']?/i);
      const owner = options?.owner || ownerRepoMatch?.[1] || state?.data?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options?.repo || ownerRepoMatch?.[2] || state?.data?.github?.lastRepository?.name;
      const branch = options.branch || branchMatch?.[1];
      const from = options.from || fromMatch?.[1] || "main";
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      if (!branch) {
        throw new Error("Branch name is required. Please specify the name for the new branch");
      }
      logger8.info(`Creating branch ${branch} from ${from} in ${owner}/${repo}`);
      const refData = await githubService.getRef(owner, repo, `heads/${from}`);
      const _newBranch = await githubService.createBranch(owner, repo, branch, refData.object.sha);
      const responseContent = {
        text: `Successfully created branch "${branch}" from "${from}" in ${owner}/${repo}
Branch: ${branch}
Based on: ${from} (${refData.object.sha.substring(0, 7)})
Created at: ${(/* @__PURE__ */ new Date()).toLocaleString()}`,
        actions: [
          "CREATE_GITHUB_BRANCH"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          branch,
          from,
          repository: `${owner}/${repo}`,
          sha: refData.object.sha
        },
        data: {
          newBranch: {
            name: branch,
            sha: refData.object.sha,
            from
          },
          github: {
            ...state?.github,
            lastCreatedBranch: branch
          }
        }
      };
    } catch (error) {
      logger8.error("Error in CREATE_GITHUB_BRANCH action:", error);
      const errorContent = {
        text: `Failed to create branch: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "CREATE_GITHUB_BRANCH"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Create a new branch called feature/payment-integration from main in my project repo"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Successfully created branch "feature/payment-integration" from "main" in user/project\nBranch: feature/payment-integration\nBased on: main (abc1234)\nCreated at: 3/21/2024, 2:30:45 PM',
          actions: [
            "CREATE_GITHUB_BRANCH"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Create a bugfix branch for issue #123 based on the release-v2 branch"
        }
      },
      {
        name: "Assistant",
        content: {
          text: `I'll create a bugfix branch for issue #123. Let me first check the issue details...

Issue #123: Fix user authentication timeout
Repository: user/api-server
State: open
Labels: bug, priority-high

Now creating the branch...

Successfully created branch "bugfix/issue-123-auth-timeout" from "release-v2" in user/api-server
Branch: bugfix/issue-123-auth-timeout
Based on: release-v2 (def5678)
Created at: 3/21/2024, 2:35:15 PM

The branch is ready for your fix. Would you like me to create a pull request draft for this issue?`,
          actions: [
            "GET_GITHUB_ISSUE",
            "CREATE_GITHUB_BRANCH"
          ]
        }
      }
    ]
  ]
};
var getBranchProtectionAction = {
  name: "GET_BRANCH_PROTECTION",
  similes: [
    "CHECK_PROTECTION",
    "BRANCH_RULES",
    "PROTECTION_STATUS"
  ],
  description: "Gets branch protection rules for a GitHub repository branch",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const branchMatch = text.match(/(?:branch\s+)?["\']?([a-zA-Z0-9._\/-]+)["\']?/i);
      const owner = options?.owner || ownerRepoMatch?.[1] || state?.data?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options?.repo || ownerRepoMatch?.[2] || state?.data?.github?.lastRepository?.name;
      const branch = options.branch || branchMatch?.[1] || state?.github?.lastCreatedBranch || "main";
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      logger8.info(`Getting branch protection for ${branch} in ${owner}/${repo}`);
      try {
        const protection = await githubService.getBranchProtection(owner, repo, branch);
        const requiredChecks = protection.required_status_checks?.contexts || [];
        const requiredReviews = protection.required_pull_request_reviews;
        const restrictions = protection.restrictions;
        const responseContent = {
          text: `Branch Protection for "${branch}" in ${owner}/${repo}:

**Status Checks:**
${protection.required_status_checks ? `\u2705 Required checks: ${requiredChecks.join(", ") || "None specified"}` : "\u274C No required status checks"}

**Pull Request Reviews:**
${requiredReviews ? `\u2705 Required approvals: ${requiredReviews.required_approving_review_count || 1}
\u2705 Dismiss stale reviews: ${requiredReviews.dismiss_stale_reviews ? "Yes" : "No"}
\u2705 Require code owner reviews: ${requiredReviews.require_code_owner_reviews ? "Yes" : "No"}` : "\u274C No review requirements"}

**Restrictions:**
${restrictions ? `\u2705 Restricted to: ${restrictions.users?.map((u) => `@${u.login}`).join(", ") || "No users"}, ${restrictions.teams?.map((t) => t.name).join(", ") || "No teams"}` : "\u274C No push restrictions"}

**Other Settings:**
\u2022 Enforce admins: ${protection.enforce_admins?.enabled ? "Yes" : "No"}
\u2022 Allow force pushes: ${protection.allow_force_pushes?.enabled ? "Yes" : "No"}
\u2022 Allow deletions: ${protection.allow_deletions?.enabled ? "Yes" : "No"}
\u2022 Required linear history: ${protection.required_linear_history?.enabled ? "Yes" : "No"}`,
          actions: [
            "GET_BRANCH_PROTECTION"
          ],
          source: message.content.source
        };
        if (callback) {
          await callback(responseContent);
        }
        return {
          success: true,
          text: responseContent.text,
          values: {
            protection,
            branch,
            repository: `${owner}/${repo}`
          },
          data: {
            protection,
            github: {
              ...state?.github,
              branchProtection: {
                ...state?.github?.branchProtection,
                [`${owner}/${repo}:${branch}`]: protection
              }
            }
          }
        };
      } catch (error) {
        if (error.status === 404) {
          const responseContent = {
            text: `Branch "${branch}" in ${owner}/${repo} has no protection rules configured.`,
            actions: [
              "GET_BRANCH_PROTECTION"
            ],
            source: message.content.source
          };
          if (callback) {
            await callback(responseContent);
          }
          return {
            success: true,
            text: responseContent.text,
            values: {
              protected: false,
              branch,
              repository: `${owner}/${repo}`
            },
            data: {
              github: state?.github || {}
            }
          };
        }
        throw error;
      }
    } catch (error) {
      logger8.error("Error in GET_BRANCH_PROTECTION action:", error);
      const errorContent = {
        text: `Failed to get branch protection: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_BRANCH_PROTECTION"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Check branch protection for main branch in facebook/react"
        }
      },
      {
        name: "Assistant",
        content: {
          text: 'Branch Protection for "main" in facebook/react:\n\n**Status Checks:**\n\u2705 Required checks: ci/circleci, continuous-integration/travis-ci\n\n**Pull Request Reviews:**\n\u2705 Required approvals: 2\n\u2705 Dismiss stale reviews: Yes\n\u2705 Require code owner reviews: Yes\n\n**Restrictions:**\n\u2705 Restricted to: @react-core-team\n\n**Other Settings:**\n\u2022 Enforce admins: No\n\u2022 Allow force pushes: No\n\u2022 Allow deletions: No\n\u2022 Required linear history: Yes',
          actions: [
            "GET_BRANCH_PROTECTION"
          ]
        }
      }
    ]
  ]
};
function getTimeAgo(date) {
  const now = /* @__PURE__ */ new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 6e4);
  const diffHours = Math.floor(diffMs / 36e5);
  const diffDays = Math.floor(diffMs / 864e5);
  const diffWeeks = Math.floor(diffMs / 6048e5);
  const diffMonths = Math.floor(diffMs / 2592e6);
  if (diffMins < 1) {
    return "just now";
  }
  if (diffMins < 60) {
    return `${diffMins} minute${diffMins === 1 ? "" : "s"} ago`;
  }
  if (diffHours < 24) {
    return `${diffHours} hour${diffHours === 1 ? "" : "s"} ago`;
  }
  if (diffDays < 7) {
    return `${diffDays} day${diffDays === 1 ? "" : "s"} ago`;
  }
  if (diffWeeks < 4) {
    return `${diffWeeks} week${diffWeeks === 1 ? "" : "s"} ago`;
  }
  return `${diffMonths} month${diffMonths === 1 ? "" : "s"} ago`;
}
__name(getTimeAgo, "getTimeAgo");

// src/actions/stats.ts
import { logger as logger9 } from "@elizaos/core";
var getRepositoryStatsAction = {
  name: "GET_GITHUB_REPO_STATS",
  similes: [
    "REPO_STATS",
    "REPOSITORY_STATS",
    "PROJECT_STATS",
    "REPO_METRICS"
  ],
  description: "Gets comprehensive statistics about a GitHub repository including contributors, commits, and activity",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      logger9.info(`Getting stats for repository ${owner}/${repo}`);
      const repository = await githubService.getRepository(owner, repo);
      const contributors = await githubService.getContributorsStats(owner, repo);
      const commitActivity = await githubService.getCommitActivityStats(owner, repo);
      const codeFrequency = await githubService.getCodeFrequencyStats(owner, repo);
      const languages = await githubService.getLanguages(owner, repo);
      const totalCommits = contributors?.reduce((sum, c) => sum + (c.total || 0), 0) || 0;
      const topContributors = (contributors || []).sort((a, b) => (b.total || 0) - (a.total || 0)).slice(0, 5);
      const recentWeeks = (commitActivity || []).slice(-4);
      const recentCommits = recentWeeks.reduce((sum, week) => sum + (week.total || 0), 0);
      const codeFreqArray = Array.isArray(codeFrequency) ? codeFrequency : [];
      const lastWeekCode = codeFreqArray[codeFreqArray.length - 1] || [
        0,
        0,
        0
      ];
      const [, additions, deletions] = lastWeekCode;
      const totalBytes = Object.values(languages || {}).reduce((sum, bytes) => sum + bytes, 0);
      const languagePercentages = Object.entries(languages || {}).map(([lang, bytes]) => ({
        language: lang,
        percentage: (Number(bytes) / Number(totalBytes) * 100).toFixed(1)
      })).sort((a, b) => parseFloat(b.percentage) - parseFloat(a.percentage)).slice(0, 5);
      const responseContent = {
        text: `Repository Stats for ${owner}/${repo}:

**Basic Info:**
\u2022 Created: ${new Date(repository.created_at).toLocaleDateString()}
\u2022 Last Updated: ${new Date(repository.updated_at).toLocaleDateString()}
\u2022 Stars: \u2B50 ${repository.stargazers_count}
\u2022 Forks: \u{1F374} ${repository.forks_count}
\u2022 Open Issues: \u{1F4DD} ${repository.open_issues_count}
\u2022 Size: ${(repository.size / 1024).toFixed(1)} MB

**Contributors:**
Total Contributors: ${contributors?.length || 0}
Total Commits: ${totalCommits}

Top Contributors:
${topContributors.map((c) => `\u2022 @${c.author?.login || "unknown"} - ${c.total} commits`).join("\n")}

**Recent Activity (Last 4 weeks):**
Total Commits: ${recentCommits}
Last Week: +${Math.abs(additions)} lines, -${Math.abs(deletions)} lines

**Languages:**
${languagePercentages.map((l) => `\u2022 ${l.language}: ${l.percentage}%`).join("\n")}`,
        actions: [
          "GET_GITHUB_REPO_STATS"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(responseContent);
      }
      return {
        success: true,
        text: responseContent.text,
        values: {
          repository: `${owner}/${repo}`,
          stats: {
            basic: {
              stars: repository.stargazers_count,
              forks: repository.forks_count,
              issues: repository.open_issues_count,
              size: repository.size
            },
            contributors: {
              total: contributors?.length || 0,
              commits: totalCommits,
              top: topContributors
            },
            activity: {
              recentCommits,
              additions,
              deletions
            },
            languages: languagePercentages
          }
        },
        data: {
          repository,
          stats: {
            contributors,
            commitActivity,
            codeFrequency,
            languages
          },
          github: {
            ...state?.github,
            repositoryStats: {
              ...state?.github?.repositoryStats,
              [`${owner}/${repo}`]: {
                repository,
                contributors: contributors?.length || 0,
                totalCommits,
                languages: languagePercentages,
                lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
              }
            }
          }
        }
      };
    } catch (error) {
      logger9.error("Error in GET_GITHUB_REPO_STATS action:", error);
      const errorContent = {
        text: `Failed to get repository stats: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_REPO_STATS"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        text: errorContent.text,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Get stats for facebook/react repository"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Repository Stats for facebook/react:\n\n**Basic Info:**\n\u2022 Created: 5/29/2013\n\u2022 Last Updated: 3/21/2024\n\u2022 Stars: \u2B50 223456\n\u2022 Forks: \u{1F374} 45678\n\u2022 Open Issues: \u{1F4DD} 1234\n\u2022 Size: 234.5 MB\n\n**Contributors:**\nTotal Contributors: 1584\nTotal Commits: 15234\n\nTop Contributors:\n\u2022 @gaearon - 892 commits\n\u2022 @sophiebits - 765 commits\n\u2022 @sebmarkbage - 654 commits\n\u2022 @acdlite - 543 commits\n\u2022 @zpao - 432 commits\n\n**Recent Activity (Last 4 weeks):**\nTotal Commits: 234\nLast Week: +1234 lines, -567 lines\n\n**Languages:**\n\u2022 JavaScript: 68.2%\n\u2022 TypeScript: 25.3%\n\u2022 CSS: 3.8%\n\u2022 HTML: 2.1%\n\u2022 Other: 0.6%",
          actions: [
            "GET_GITHUB_REPO_STATS"
          ]
        }
      }
    ],
    [
      {
        name: "User",
        content: {
          text: "Analyze the activity and health of my project repository"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Repository Stats for user/project:\n\n**Basic Info:**\n\u2022 Created: 1/15/2024\n\u2022 Last Updated: 3/21/2024\n\u2022 Stars: \u2B50 42\n\u2022 Forks: \u{1F374} 8\n\u2022 Open Issues: \u{1F4DD} 5\n\u2022 Size: 12.3 MB\n\n**Contributors:**\nTotal Contributors: 3\nTotal Commits: 234\n\nTop Contributors:\n\u2022 @user - 189 commits\n\u2022 @contributor1 - 34 commits\n\u2022 @contributor2 - 11 commits\n\n**Recent Activity (Last 4 weeks):**\nTotal Commits: 45\nLast Week: +892 lines, -234 lines\n\n**Languages:**\n\u2022 TypeScript: 72.5%\n\u2022 JavaScript: 15.2%\n\u2022 CSS: 8.3%\n\u2022 HTML: 4.0%\n\nThe repository shows healthy activity with consistent commits. Consider addressing the 5 open issues to improve project health.",
          actions: [
            "GET_GITHUB_REPO_STATS"
          ]
        }
      }
    ]
  ]
};
var getRepositoryTrafficAction = {
  name: "GET_GITHUB_REPO_TRAFFIC",
  similes: [
    "REPO_TRAFFIC",
    "VISITOR_STATS",
    "TRAFFIC_ANALYTICS"
  ],
  description: "Gets traffic statistics for a GitHub repository (requires push access)",
  validate: /* @__PURE__ */ __name(async (runtime, message, state) => {
    const githubService = runtime.getService("github");
    return !!githubService;
  }, "validate"),
  handler: /* @__PURE__ */ __name(async (runtime, message, state, options = {}, callback) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service not available");
      }
      const text = message.content.text || "";
      const ownerRepoMatch = text.match(/(?:github\.com\/)?([^\/\s]+)\/([^\/\s]+)/);
      const owner = options.owner || ownerRepoMatch?.[1] || state?.github?.lastRepository?.owner?.login || runtime.getSetting("GITHUB_OWNER");
      const repo = options.repo || ownerRepoMatch?.[2] || state?.github?.lastRepository?.name;
      if (!owner || !repo) {
        throw new Error('Repository owner and name are required. Please specify as "owner/repo" or provide them in options');
      }
      logger9.info(`Getting traffic stats for repository ${owner}/${repo}`);
      try {
        const views = await githubService.getTrafficViews(owner, repo);
        const clones = await githubService.getTrafficClones(owner, repo);
        const paths = await githubService.getTopPaths(owner, repo);
        const referrers = await githubService.getTopReferrers(owner, repo);
        const responseContent = {
          text: `Traffic Stats for ${owner}/${repo}:

**Views (Last 14 days):**
\u2022 Total Views: ${views.count}
\u2022 Unique Visitors: ${views.uniques}

**Clones (Last 14 days):**
\u2022 Total Clones: ${clones.count}
\u2022 Unique Cloners: ${clones.uniques}

**Popular Content:**
${paths.slice(0, 5).map((p) => `\u2022 ${p.path} - ${p.count} views (${p.uniques} unique)`).join("\n")}

**Top Referrers:**
${referrers.slice(0, 5).map((r) => `\u2022 ${r.referrer} - ${r.count} views (${r.uniques} unique)`).join("\n")}`,
          actions: [
            "GET_GITHUB_REPO_TRAFFIC"
          ],
          source: message.content.source
        };
        if (callback) {
          await callback(responseContent);
        }
        return {
          success: true,
          text: responseContent.text,
          values: {
            repository: `${owner}/${repo}`,
            traffic: {
              views: {
                total: views.count,
                unique: views.uniques
              },
              clones: {
                total: clones.count,
                unique: clones.uniques
              },
              paths: paths.slice(0, 5),
              referrers: referrers.slice(0, 5)
            }
          },
          data: {
            traffic: {
              views,
              clones,
              paths,
              referrers
            },
            github: {
              ...state?.github,
              repositoryTraffic: {
                ...state?.github?.repositoryTraffic,
                [`${owner}/${repo}`]: {
                  views,
                  clones,
                  lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
                }
              }
            }
          }
        };
      } catch (error) {
        if (error.status === 403) {
          const responseContent = {
            text: `Traffic statistics are not available for ${owner}/${repo}. This feature requires push access to the repository.`,
            actions: [
              "GET_GITHUB_REPO_TRAFFIC"
            ],
            source: message.content.source
          };
          if (callback) {
            await callback(responseContent);
          }
          return {
            success: false,
            text: responseContent.text,
            values: {
              repository: `${owner}/${repo}`,
              available: false
            },
            data: {
              github: state?.github || {}
            }
          };
        }
        throw error;
      }
    } catch (error) {
      logger9.error("Error in GET_GITHUB_REPO_TRAFFIC action:", error);
      const errorContent = {
        text: `Failed to get repository traffic: ${error instanceof Error ? error.message : String(error)}`,
        actions: [
          "GET_GITHUB_REPO_TRAFFIC"
        ],
        source: message.content.source
      };
      if (callback) {
        await callback(errorContent);
      }
      return {
        success: false,
        ...errorContent
      };
    }
  }, "handler"),
  examples: [
    [
      {
        name: "User",
        content: {
          text: "Show traffic stats for my awesome-project repository"
        }
      },
      {
        name: "Assistant",
        content: {
          text: "Traffic Stats for user/awesome-project:\n\n**Views (Last 14 days):**\n\u2022 Total Views: 1,234\n\u2022 Unique Visitors: 456\n\n**Clones (Last 14 days):**\n\u2022 Total Clones: 89\n\u2022 Unique Cloners: 34\n\n**Popular Content:**\n\u2022 /README.md - 456 views (234 unique)\n\u2022 /docs/getting-started.md - 123 views (89 unique)\n\u2022 /src/index.js - 78 views (45 unique)\n\u2022 /package.json - 56 views (34 unique)\n\u2022 /LICENSE - 45 views (23 unique)\n\n**Top Referrers:**\n\u2022 google.com - 234 views (123 unique)\n\u2022 github.com - 189 views (98 unique)\n\u2022 stackoverflow.com - 78 views (45 unique)\n\u2022 reddit.com - 56 views (34 unique)\n\u2022 twitter.com - 45 views (23 unique)",
          actions: [
            "GET_GITHUB_REPO_TRAFFIC"
          ]
        }
      }
    ]
  ]
};

// src/actions/webhooks.ts
import { logger as logger10, ModelType } from "@elizaos/core";
import { z as z2 } from "zod";
var WebhookIntentSchema = z2.object({
  intent: z2.enum([
    "create_webhook",
    "list_webhooks",
    "delete_webhook",
    "ping_webhook",
    "unclear"
  ]),
  confidence: z2.number().min(0).max(1),
  reasoning: z2.string(),
  parameters: z2.object({
    owner: z2.string().optional(),
    repo: z2.string().optional(),
    webhookId: z2.number().optional(),
    events: z2.array(z2.string()).optional()
  }).optional()
});
async function analyzeWebhookIntent(runtime, message, state) {
  const prompt = `Analyze this message to determine if the user wants to perform a webhook-related action:

Message: "${message.content.text}"

Context from state:
${state.data?.github?.lastRepository ? `Current repository: ${state.data.github.lastRepository.full_name}` : "No repository context"}

Determine:
1. What webhook action they want (create, list, delete, ping, or unclear)
2. Confidence level (0-1)
3. Your reasoning
4. Extract parameters (owner, repo, webhookId, events)

Format as JSON matching this schema:
{
  "intent": "create_webhook" | "list_webhooks" | "delete_webhook" | "ping_webhook" | "unclear",
  "confidence": 0.8,
  "reasoning": "User is asking to...",
  "parameters": {
    "owner": "extracted_owner",
    "repo": "extracted_repo", 
    "webhookId": 123,
    "events": ["issues", "pull_request"]
  }
}`;
  try {
    const response = await runtime.useModel(ModelType.TEXT_LARGE, {
      prompt,
      temperature: 0.1,
      max_tokens: 500
    });
    const parsed = WebhookIntentSchema.parse(JSON.parse(response));
    return parsed;
  } catch (error) {
    logger10.warn("Failed to analyze webhook intent:", error);
    return {
      intent: "unclear",
      confidence: 0,
      reasoning: "Failed to parse intent"
    };
  }
}
__name(analyzeWebhookIntent, "analyzeWebhookIntent");
var createWebhookAction = {
  name: "CREATE_GITHUB_WEBHOOK",
  similes: [
    "SETUP_WEBHOOK",
    "ADD_WEBHOOK",
    "CONFIGURE_WEBHOOK"
  ],
  description: "Create a GitHub webhook for real-time event processing using Ngrok tunnel",
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Create a webhook for owner/repo to listen for issues and pull requests"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll create a webhook for the repository with the appropriate events configured.",
          actions: [
            "CREATE_GITHUB_WEBHOOK"
          ]
        }
      }
    ]
  ],
  async validate(runtime, message, state) {
    const intent = await analyzeWebhookIntent(runtime, message, state || {
      values: {},
      data: {},
      text: ""
    });
    return intent.intent === "create_webhook" && intent.confidence > 0.7;
  },
  async handler(runtime, message, state = {
    values: {},
    data: {},
    text: ""
  }, options = {}, callback = async () => []) {
    try {
      const githubService = runtime.getService("github");
      const tunnelService = runtime.getService("tunnel");
      if (!githubService) {
        throw new Error("GitHub service is not available");
      }
      if (!tunnelService || !tunnelService.isActive()) {
        throw new Error("Ngrok tunnel service is not available. Please start the tunnel service first.");
      }
      const intent = await analyzeWebhookIntent(runtime, message, state || {
        values: {},
        data: {},
        text: ""
      });
      if (intent.intent !== "create_webhook") {
        await callback({
          text: "I understand you want to work with webhooks, but I'm not sure exactly what you want to create. Could you be more specific?",
          thought: `Intent analysis: ${intent.reasoning}`
        });
        return;
      }
      let owner = intent.parameters?.owner;
      let repo = intent.parameters?.repo;
      if (!owner || !repo) {
        if (state.github?.lastRepository) {
          owner = owner || state.data?.github?.lastRepository?.owner?.login;
          repo = repo || state.data?.github?.lastRepository?.name;
        } else {
          const clarificationPrompt = `The user wants to create a webhook but didn't specify the repository clearly. 
          
Message: "${message.content.text}"

Please extract or ask for the missing information. If you can reasonably infer the repository, provide it. If not, ask for clarification.

Format as JSON:
{
  "needsClarification": true/false,
  "clarificationMessage": "What repository would you like...",
  "inferredOwner": "possible_owner",
  "inferredRepo": "possible_repo"
}`;
          const clarificationResponse = await runtime.useModel(ModelType.TEXT_LARGE, {
            prompt: clarificationPrompt,
            temperature: 0.3,
            max_tokens: 200
          });
          const clarification = JSON.parse(clarificationResponse);
          if (clarification.needsClarification) {
            await callback({
              text: clarification.clarificationMessage,
              thought: "Need repository clarification for webhook creation"
            });
            return;
          }
          owner = clarification.inferredOwner;
          repo = clarification.inferredRepo;
        }
      }
      if (!owner || !repo) {
        await callback({
          text: "I need to know which repository you want to create a webhook for. Please specify the owner and repository name.",
          thought: "Missing repository information"
        });
        return;
      }
      const tunnelUrl = await tunnelService.getUrl();
      const webhookUrl = `${tunnelUrl}/api/github/webhook`;
      const webhookSecret = runtime.getSetting("GITHUB_WEBHOOK_SECRET");
      if (!webhookSecret) {
        logger10.warn("No webhook secret configured - webhook will be created without signature verification");
      }
      const events = intent.parameters?.events || [
        "issues",
        "issue_comment",
        "pull_request",
        "pull_request_review",
        "push"
      ];
      const webhook = await githubService.createWebhook(owner, repo, {
        url: webhookUrl,
        content_type: "json",
        secret: webhookSecret
      }, events);
      await githubService.pingWebhook(owner, repo, webhook.id);
      await callback({
        text: `\u2705 Successfully created webhook for ${owner}/${repo}!

**Webhook Details:**
- ID: ${webhook.id}
- URL: ${webhookUrl}
- Events: ${events.join(", ")}
- Secret: ${webhookSecret ? "Configured \u2705" : "Not configured \u26A0\uFE0F"}

The webhook has been tested with a ping and is ready to receive events.`,
        thought: `Created webhook ${webhook.id} for ${owner}/${repo}`,
        actions: [
          "CREATE_GITHUB_WEBHOOK"
        ]
      });
      if (!state.data?.github) {
        if (!state.data) {
          state.data = {};
        }
        state.data.github = {};
      }
      state.data.github.lastWebhook = {
        id: webhook.id,
        owner,
        repo,
        url: webhookUrl,
        events
      };
    } catch (error) {
      logger10.error("Failed to create GitHub webhook:", error);
      await callback({
        text: `\u274C Failed to create webhook: ${error instanceof Error ? error.message : String(error)}

Common issues:
- Make sure you have admin access to the repository
- Verify your GitHub token has webhook permissions
- Check that the Ngrok tunnel is active`,
        thought: "Error creating webhook"
      });
    }
  }
};
var listWebhooksAction = {
  name: "LIST_GITHUB_WEBHOOKS",
  similes: [
    "SHOW_WEBHOOKS",
    "GET_WEBHOOKS",
    "VIEW_WEBHOOKS"
  ],
  description: "List all webhooks configured for a GitHub repository",
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "List webhooks for owner/repo"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll show you all the webhooks configured for that repository.",
          actions: [
            "LIST_GITHUB_WEBHOOKS"
          ]
        }
      }
    ]
  ],
  async validate(runtime, message, state) {
    const intent = await analyzeWebhookIntent(runtime, message, state || {
      values: {},
      data: {},
      text: ""
    });
    return intent.intent === "list_webhooks" && intent.confidence > 0.7;
  },
  async handler(runtime, message, state = {
    values: {},
    data: {},
    text: ""
  }, options = {}, callback = async () => []) {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service is not available");
      }
      const intent = await analyzeWebhookIntent(runtime, message, state || {
        values: {},
        data: {},
        text: ""
      });
      let owner = intent.parameters?.owner;
      let repo = intent.parameters?.repo;
      if (!owner || !repo) {
        if (state.github?.lastRepository) {
          owner = owner || state.data?.github?.lastRepository?.owner?.login;
          repo = repo || state.data?.github?.lastRepository?.name;
        } else {
          await callback({
            text: "I need to know which repository you want to list webhooks for. Please specify the owner and repository name.",
            thought: "Missing repository information"
          });
          return;
        }
      }
      const webhooks = await githubService.listWebhooks(owner, repo);
      if (webhooks.length === 0) {
        await callback({
          text: `No webhooks found for ${owner}/${repo}.`,
          thought: `No webhooks in ${owner}/${repo}`
        });
        return;
      }
      let responseText = `**Webhooks for ${owner}/${repo}:**

`;
      webhooks.forEach((webhook, index) => {
        responseText += `**${index + 1}. Webhook #${webhook.id}**
`;
        responseText += `- URL: ${webhook.config.url}
`;
        responseText += `- Events: ${webhook.events.join(", ")}
`;
        responseText += `- Active: ${webhook.active ? "\u2705" : "\u274C"}
`;
        responseText += `- Last Response: ${webhook.last_response?.code || "N/A"}
`;
        responseText += `- Created: ${new Date(webhook.created_at).toLocaleDateString()}

`;
      });
      await callback({
        text: responseText,
        thought: `Listed ${webhooks.length} webhooks for ${owner}/${repo}`,
        actions: [
          "LIST_GITHUB_WEBHOOKS"
        ]
      });
      if (!state.data?.github) {
        if (!state.data) {
          state.data = {};
        }
        state.data.github = {};
      }
      state.data.github.lastWebhooks = webhooks;
    } catch (error) {
      logger10.error("Failed to list GitHub webhooks:", error);
      await callback({
        text: `\u274C Failed to list webhooks: ${error instanceof Error ? error.message : String(error)}`,
        thought: "Error listing webhooks"
      });
    }
  }
};
var deleteWebhookAction = {
  name: "DELETE_GITHUB_WEBHOOK",
  similes: [
    "REMOVE_WEBHOOK",
    "DESTROY_WEBHOOK"
  ],
  description: "Delete a specific GitHub webhook from a repository",
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Delete webhook 12345 from owner/repo"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll delete that webhook from the repository.",
          actions: [
            "DELETE_GITHUB_WEBHOOK"
          ]
        }
      }
    ]
  ],
  async validate(runtime, message, state) {
    const intent = await analyzeWebhookIntent(runtime, message, state || {
      values: {},
      data: {},
      text: ""
    });
    return intent.intent === "delete_webhook" && intent.confidence > 0.7;
  },
  async handler(runtime, message, state = {
    values: {},
    data: {},
    text: ""
  }, options = {}, callback = async () => []) {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service is not available");
      }
      const intent = await analyzeWebhookIntent(runtime, message, state || {
        values: {},
        data: {},
        text: ""
      });
      let owner = intent.parameters?.owner;
      let repo = intent.parameters?.repo;
      const webhookId = intent.parameters?.webhookId;
      if (!webhookId) {
        await callback({
          text: 'I need the webhook ID to delete. Please specify which webhook you want to delete (e.g., "delete webhook 12345").',
          thought: "Missing webhook ID"
        });
        return;
      }
      if (!owner || !repo) {
        if (state.github?.lastRepository) {
          owner = owner || state.data?.github?.lastRepository?.owner?.login;
          repo = repo || state.data?.github?.lastRepository?.name;
        } else {
          await callback({
            text: "I need to know which repository the webhook belongs to. Please specify the owner and repository name.",
            thought: "Missing repository information"
          });
          return;
        }
      }
      const webhooks = await githubService.listWebhooks(owner, repo);
      const webhook = webhooks.find((w) => w.id === webhookId);
      if (!webhook) {
        await callback({
          text: `\u274C Webhook #${webhookId} not found in ${owner}/${repo}. 

Available webhooks: ${webhooks.map((w) => `#${w.id}`).join(", ") || "None"}`,
          thought: `Webhook ${webhookId} not found`
        });
        return;
      }
      await githubService.deleteWebhook(owner, repo, webhookId);
      await callback({
        text: `\u2705 Successfully deleted webhook #${webhookId} from ${owner}/${repo}.

**Deleted webhook details:**
- URL: ${webhook.config.url}
- Events: ${webhook.events.join(", ")}`,
        thought: `Deleted webhook ${webhookId} from ${owner}/${repo}`,
        actions: [
          "DELETE_GITHUB_WEBHOOK"
        ]
      });
    } catch (error) {
      logger10.error("Failed to delete GitHub webhook:", error);
      await callback({
        text: `\u274C Failed to delete webhook: ${error instanceof Error ? error.message : String(error)}`,
        thought: "Error deleting webhook"
      });
    }
  }
};
var pingWebhookAction = {
  name: "PING_GITHUB_WEBHOOK",
  similes: [
    "TEST_WEBHOOK",
    "CHECK_WEBHOOK"
  ],
  description: "Send a ping to test a GitHub webhook",
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "Ping webhook 12345 on owner/repo"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll send a test ping to that webhook.",
          actions: [
            "PING_GITHUB_WEBHOOK"
          ]
        }
      }
    ]
  ],
  async validate(runtime, message, state) {
    const intent = await analyzeWebhookIntent(runtime, message, state || {
      values: {},
      data: {},
      text: ""
    });
    return intent.intent === "ping_webhook" && intent.confidence > 0.7;
  },
  async handler(runtime, message, state = {
    values: {},
    data: {},
    text: ""
  }, options = {}, callback = async () => []) {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service is not available");
      }
      const intent = await analyzeWebhookIntent(runtime, message, state || {
        values: {},
        data: {},
        text: ""
      });
      let owner = intent.parameters?.owner;
      let repo = intent.parameters?.repo;
      const webhookId = intent.parameters?.webhookId;
      if (!webhookId) {
        await callback({
          text: 'I need the webhook ID to ping. Please specify which webhook you want to test (e.g., "ping webhook 12345").',
          thought: "Missing webhook ID"
        });
        return;
      }
      if (!owner || !repo) {
        if (state.github?.lastRepository) {
          owner = owner || state.data?.github?.lastRepository?.owner?.login;
          repo = repo || state.data?.github?.lastRepository?.name;
        } else {
          await callback({
            text: "I need to know which repository the webhook belongs to. Please specify the owner and repository name.",
            thought: "Missing repository information"
          });
          return;
        }
      }
      const result = await githubService.pingWebhook(owner, repo, webhookId);
      await callback({
        text: `\u2705 Successfully sent ping to webhook #${webhookId} on ${owner}/${repo}.

The webhook should receive a test payload. Check your webhook endpoint logs or GitHub's webhook delivery logs to verify it was received.`,
        thought: `Pinged webhook ${webhookId} on ${owner}/${repo}`,
        actions: [
          "PING_GITHUB_WEBHOOK"
        ]
      });
    } catch (error) {
      logger10.error("Failed to ping GitHub webhook:", error);
      await callback({
        text: `\u274C Failed to ping webhook: ${error instanceof Error ? error.message : String(error)}

Common issues:
- Webhook ID doesn't exist
- Network connectivity problems
- GitHub API rate limits`,
        thought: "Error pinging webhook"
      });
    }
  }
};

// src/actions/autoCoder.ts
import { logger as logger11, ModelType as ModelType2 } from "@elizaos/core";
import { z as z3 } from "zod";
var IssueAnalysisSchema = z3.object({
  canAutomate: z3.boolean(),
  complexity: z3.enum([
    "simple",
    "medium",
    "complex"
  ]),
  confidence: z3.number().min(0).max(1),
  reasoning: z3.string(),
  issueType: z3.enum([
    "bug",
    "feature",
    "documentation",
    "refactor",
    "other"
  ]),
  summary: z3.string(),
  requiredFiles: z3.array(z3.string()),
  estimatedChanges: z3.number().min(0),
  riskLevel: z3.enum([
    "low",
    "medium",
    "high"
  ]),
  dependencies: z3.array(z3.string()).optional()
});
var CodeChangeSchema = z3.object({
  file: z3.string(),
  action: z3.enum([
    "create",
    "update",
    "delete"
  ]),
  content: z3.string().optional(),
  reasoning: z3.string(),
  lineNumbers: z3.object({
    start: z3.number().optional(),
    end: z3.number().optional()
  }).optional()
});
var CodeGenerationSchema = z3.object({
  canGenerate: z3.boolean(),
  confidence: z3.number().min(0).max(1),
  reasoning: z3.string(),
  changes: z3.array(CodeChangeSchema),
  testingNeeded: z3.boolean(),
  deploymentNotes: z3.string().optional()
});
async function shouldAutoCode(runtime, issue, repository) {
  const prompt = `Analyze this GitHub issue to determine if it's suitable for automated coding:

Repository: ${repository.full_name}
Issue #${issue.number}: ${issue.title}
Body: ${issue.body || "No description provided"}
Labels: ${issue.labels.map((l) => l.name).join(", ") || "None"}
Author: ${issue.user.login}

Consider:
1. Is this a request that can be automated?
2. Does it involve code changes?
3. Is the scope clear and limited?
4. Would automation be safe and helpful?

Respond with JSON:
{
  "shouldAutoCode": true/false,
  "confidence": 0.0-1.0,
  "reasoning": "explanation of decision"
}`;
  try {
    const response = await runtime.useModel(ModelType2.TEXT_LARGE, {
      prompt,
      temperature: 0.2,
      max_tokens: 300
    });
    const result = JSON.parse(response);
    return result.shouldAutoCode && result.confidence > 0.7;
  } catch (_error) {
    logger11.warn("Failed to evaluate auto-coding suitability:", _error);
    return false;
  }
}
__name(shouldAutoCode, "shouldAutoCode");
var autoCodeIssueAction = {
  name: "AUTO_CODE_ISSUE",
  similes: [
    "FIX_ISSUE",
    "SOLVE_ISSUE",
    "AUTO_FIX_ISSUE"
  ],
  description: "Intelligently analyze a GitHub issue and create a pull request with a real code fix",
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "@agent please fix this issue"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll analyze this issue using AI and create a pull request with a real fix.",
          actions: [
            "AUTO_CODE_ISSUE"
          ]
        }
      }
    ]
  ],
  async validate(runtime, message, state) {
    const githubService = runtime.getService("github");
    if (!githubService) {
      return false;
    }
    const { issue, repository } = state?.data || {};
    if (issue && repository) {
      return await shouldAutoCode(runtime, issue, repository);
    }
    return true;
  },
  async handler(runtime, message, state = {
    values: {},
    data: {},
    text: ""
  }, options, callback) {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service is not available");
      }
      const { issue, repository, action: eventAction } = options || {};
      if (!issue || !repository) {
        await callback?.({
          text: "This action requires issue and repository information from a GitHub webhook event.",
          thought: "Missing required webhook data"
        });
        return;
      }
      logger11.info(`Intelligent auto-coding for issue #${issue.number} in ${repository.full_name}`);
      if (issue.assignee && issue.assignee.login !== runtime.character.name) {
        await callback?.({
          text: `Issue #${issue.number} is already assigned to ${issue.assignee.login}. I won't interfere.`,
          thought: "Issue already assigned to someone else"
        });
        return;
      }
      const analysisPrompt = `Analyze this GitHub issue comprehensively:

Repository: ${repository.full_name}
Language: ${repository.language || "Unknown"}
Description: ${repository.description || "No description"}

Issue #${issue.number}: ${issue.title}
Body: ${issue.body || "No description provided"}
Labels: ${issue.labels.map((l) => l.name).join(", ") || "None"}
Author: ${issue.user.login}

Provide a detailed analysis as JSON:
{
  "canAutomate": boolean,
  "complexity": "simple" | "medium" | "complex",
  "confidence": 0.0-1.0,
  "reasoning": "detailed explanation",
  "issueType": "bug" | "feature" | "documentation" | "refactor" | "other",
  "summary": "what needs to be done",
  "requiredFiles": ["file1.js", "file2.py"],
  "estimatedChanges": 5,
  "riskLevel": "low" | "medium" | "high",
  "dependencies": ["optional array of dependencies"]
}`;
      const analysisResponse = await runtime.useModel(ModelType2.TEXT_LARGE, {
        prompt: analysisPrompt,
        temperature: 0.2,
        max_tokens: 1e3
      });
      let analysis;
      try {
        analysis = IssueAnalysisSchema.parse(JSON.parse(analysisResponse));
      } catch (error) {
        logger11.error("Failed to parse issue analysis:", error);
        await callback?.({
          text: `I analyzed issue #${issue.number} but the analysis was inconclusive. This likely indicates the issue is too complex or ambiguous for automated fixing.`,
          thought: "Failed to parse structured analysis"
        });
        return;
      }
      if (!analysis.canAutomate || analysis.confidence < 0.6 || analysis.riskLevel === "high") {
        await callback?.({
          text: `Issue #${issue.number} analysis complete:

**Complexity**: ${analysis.complexity}
**Risk Level**: ${analysis.riskLevel}
**Confidence**: ${Math.round(analysis.confidence * 100)}%

**Reasoning**: ${analysis.reasoning}

This issue requires human intervention due to its complexity or risk level. I recommend reviewing the requirements and breaking it down into smaller, more specific tasks.`,
          thought: `Issue too complex/risky for automation: ${analysis.reasoning}`
        });
        return;
      }
      const repoStructure = await analyzeRepositoryStructure(githubService, repository);
      const codeGenPrompt = `Generate specific code changes for this issue:

Repository: ${repository.full_name}
Issue: ${issue.title}
Type: ${analysis.issueType}
Files to modify: ${analysis.requiredFiles.join(", ")}

Repository structure context:
${repoStructure}

Issue details:
${issue.body || "No description provided"}

Generate actual code changes as JSON:
{
  "canGenerate": boolean,
  "confidence": 0.0-1.0,
  "reasoning": "explanation",
  "changes": [
    {
      "file": "path/to/file.js",
      "action": "create" | "update" | "delete",
      "content": "actual file content or changes",
      "reasoning": "why this change is needed",
      "lineNumbers": {"start": 10, "end": 20}
    }
  ],
  "testingNeeded": boolean,
  "deploymentNotes": "any deployment considerations"
}`;
      const codeResponse = await runtime.useModel(ModelType2.TEXT_LARGE, {
        prompt: codeGenPrompt,
        temperature: 0.1,
        max_tokens: 3e3
      });
      let codeGeneration;
      try {
        codeGeneration = CodeGenerationSchema.parse(JSON.parse(codeResponse));
      } catch (error) {
        logger11.error("Failed to parse code generation:", error);
        await callback?.({
          text: `I understand what needs to be done for issue #${issue.number}, but I couldn't generate the specific code changes reliably. This suggests the changes are too complex for automated implementation.`,
          thought: "Failed to generate code changes"
        });
        return;
      }
      if (!codeGeneration.canGenerate || codeGeneration.confidence < 0.7) {
        await callback?.({
          text: `While I can analyze issue #${issue.number}, I'm not confident enough (${Math.round(codeGeneration.confidence * 100)}%) to generate the code changes automatically.

**Reasoning**: ${codeGeneration.reasoning}

I recommend having a human developer review this issue.`,
          thought: `Low confidence in code generation: ${codeGeneration.reasoning}`
        });
        return;
      }
      const defaultBranch = await githubService.getDefaultBranch(repository.owner.login, repository.name);
      const branchName = `auto-fix/issue-${issue.number}`;
      const defaultBranchRef = await githubService.getRef(repository.owner.login, repository.name, `heads/${defaultBranch}`);
      await githubService.createBranch(repository.owner.login, repository.name, branchName, defaultBranchRef.object.sha);
      logger11.info(`Created branch ${branchName} for issue #${issue.number}`);
      const changedFiles = [];
      for (const change of codeGeneration.changes) {
        try {
          if (change.action === "create") {
            await githubService.createOrUpdateFile(repository.owner.login, repository.name, change.file, change.content || "", `Auto-fix: Create ${change.file} for issue #${issue.number}`, branchName);
          } else if (change.action === "update") {
            let existingContent = "";
            let fileSha;
            try {
              const fileData = await githubService.getFileContent(repository.owner.login, repository.name, change.file, defaultBranch);
              existingContent = fileData.content;
              fileSha = fileData.sha;
            } catch (error) {
              logger11.warn(`File ${change.file} not found, will create new file`);
            }
            const updatedContent = change.content || existingContent;
            await githubService.createOrUpdateFile(repository.owner.login, repository.name, change.file, updatedContent, `Auto-fix: Update ${change.file} for issue #${issue.number}`, branchName, fileSha);
          } else if (change.action === "delete") {
            const fileData = await githubService.getFileContent(repository.owner.login, repository.name, change.file, defaultBranch);
            await githubService.deleteFile(repository.owner.login, repository.name, change.file, `Auto-fix: Delete ${change.file} for issue #${issue.number}`, fileData.sha, branchName);
          }
          changedFiles.push(change.file);
          logger11.info(`${change.action} ${change.file} in branch ${branchName}`);
        } catch (error) {
          logger11.error(`Failed to ${change.action} file ${change.file}:`, error);
        }
      }
      if (changedFiles.length === 0) {
        await callback?.({
          text: `I analyzed issue #${issue.number} and generated a solution, but encountered errors applying the changes to the repository. This may be due to file permissions or repository structure changes.`,
          thought: "No files were successfully changed"
        });
        return;
      }
      const prBody = `## \u{1F916} Automated Fix for Issue #${issue.number}

**Analysis Summary**: ${analysis.summary}

**Issue Type**: ${analysis.issueType}
**Complexity**: ${analysis.complexity}
**Risk Level**: ${analysis.riskLevel}
**AI Confidence**: ${Math.round(codeGeneration.confidence * 100)}%

### \u{1F527} Changes Made

${codeGeneration.changes.map((change) => `- **${change.action.toUpperCase()}** \`${change.file}\`: ${change.reasoning}`).join("\n")}

### \u{1F9EA} Testing ${codeGeneration.testingNeeded ? "Required" : "Recommended"}

${codeGeneration.testingNeeded ? "\u26A0\uFE0F **Testing is required** before merging these changes." : "\u2705 Changes are low-risk but testing is still recommended."}

${codeGeneration.deploymentNotes ? `### \u{1F4CB} Deployment Notes
${codeGeneration.deploymentNotes}` : ""}

### \u{1F50D} Review Checklist

- [ ] Code changes implement the requested functionality
- [ ] No unintended side effects introduced
- [ ] Documentation updated if necessary
- [ ] Tests pass (if applicable)

---
*This PR was automatically generated using AI analysis. Generated with confidence level: ${Math.round(codeGeneration.confidence * 100)}%*

Fixes #${issue.number}`;
      const pr = await githubService.createPullRequest(repository.owner.login, repository.name, {
        title: `\u{1F916} Auto-fix: ${issue.title}`,
        body: prBody,
        head: branchName,
        base: defaultBranch
      });
      logger11.info(`Created intelligent PR #${pr.number} for issue #${issue.number}`);
      await githubService.createIssueComment(repository.owner.login, repository.name, issue.number, `\u{1F916} **Automated Analysis Complete**

I've analyzed this issue and created an automated fix: **PR #${pr.number}**

**Analysis Results:**
- **Type**: ${analysis.issueType}
- **Complexity**: ${analysis.complexity}
- **Risk Level**: ${analysis.riskLevel}
- **AI Confidence**: ${Math.round(codeGeneration.confidence * 100)}%

**Files Modified**: ${changedFiles.join(", ")}

${codeGeneration.testingNeeded ? "\u26A0\uFE0F **Testing is required** before merging." : "\u2705 Changes appear safe but review is recommended."}

Please review the PR and let me know if adjustments are needed!`);
      await callback?.({
        text: `\u{1F916} **Automated fix created for issue #${issue.number}**

**Analysis**: ${analysis.issueType} (${analysis.complexity} complexity)
**Solution**: PR #${pr.number} with ${changedFiles.length} file changes
**Confidence**: ${Math.round(codeGeneration.confidence * 100)}%

The solution has been implemented based on AI analysis of the repository structure and issue requirements.`,
        thought: `Created intelligent automated fix with ${changedFiles.length} changes`,
        actions: [
          "AUTO_CODE_ISSUE"
        ]
      });
    } catch (error) {
      logger11.error("Failed to auto-code issue:", error);
      await callback?.({
        text: `\u274C Failed to create automated fix: ${error instanceof Error ? error.message : String(error)}

This could be due to:
- Repository access permissions
- Complex code requirements
- API rate limits
- File structure changes`,
        thought: "Error in intelligent auto-coding process"
      });
    }
  }
};
async function analyzeRepositoryStructure(githubService, repository) {
  try {
    const tree = await githubService.getRepositoryTree(repository.owner.login, repository.name);
    const keyFiles = tree.filter((item) => item.type === "blob" && (item.path.endsWith(".js") || item.path.endsWith(".ts") || item.path.endsWith(".py") || item.path.endsWith(".java") || item.path.endsWith(".md") || item.path === "package.json" || item.path === "requirements.txt" || item.path === "pom.xml")).slice(0, 20);
    return `Key files found:
${keyFiles.map((f) => `- ${f.path}`).join("\n")}

Total files: ${tree.length}
Primary language: ${repository.language || "Unknown"}`;
  } catch (error) {
    logger11.warn("Could not analyze repository structure:", error);
    return `Repository: ${repository.full_name}
Language: ${repository.language || "Unknown"}
Structure analysis unavailable`;
  }
}
__name(analyzeRepositoryStructure, "analyzeRepositoryStructure");
var MentionAnalysisSchema = z3.object({
  requestType: z3.enum([
    "code_fix",
    "question",
    "review",
    "clarification",
    "other"
  ]),
  confidence: z3.number().min(0).max(1),
  reasoning: z3.string(),
  shouldAutoCode: z3.boolean(),
  suggestedResponse: z3.string(),
  urgency: z3.enum([
    "low",
    "medium",
    "high"
  ]),
  requiresHuman: z3.boolean()
});
async function analyzeMention(runtime, mentionText, issue, repository, isComment) {
  const prompt = `Analyze this GitHub mention to understand what the user wants:

Repository: ${repository.full_name}
Context: ${isComment ? "Comment on existing issue" : "New issue"}
Issue: #${issue.number} - ${issue.title}
Mention text: "${mentionText}"

User profile: ${issue.user?.login || "unknown"}
Issue labels: ${issue.labels?.map((l) => l.name).join(", ") || "none"}

Analyze what they're asking for and how I should respond:

{
  "requestType": "code_fix" | "question" | "review" | "clarification" | "other",
  "confidence": 0.0-1.0,
  "reasoning": "detailed explanation of what they want",
  "shouldAutoCode": boolean,
  "suggestedResponse": "my response message",
  "urgency": "low" | "medium" | "high",
  "requiresHuman": boolean
}`;
  try {
    const response = await runtime.useModel(ModelType2.TEXT_LARGE, {
      prompt,
      temperature: 0.3,
      max_tokens: 800
    });
    return MentionAnalysisSchema.parse(JSON.parse(response));
  } catch (error) {
    logger11.warn("Failed to analyze mention:", error);
    return {
      requestType: "other",
      confidence: 0.1,
      reasoning: "Failed to parse mention intent",
      shouldAutoCode: false,
      suggestedResponse: "I see you've mentioned me! Could you please clarify what you'd like me to help with?",
      urgency: "low",
      requiresHuman: false
    };
  }
}
__name(analyzeMention, "analyzeMention");
var respondToMentionAction = {
  name: "RESPOND_TO_GITHUB_MENTION",
  similes: [
    "HANDLE_GITHUB_MENTION",
    "REPLY_TO_MENTION"
  ],
  description: "Intelligently respond when the agent is mentioned in a GitHub issue or comment",
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "@agent can you help fix this bug?"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "I'll analyze this issue and see if I can provide an automated fix.",
          actions: [
            "RESPOND_TO_GITHUB_MENTION"
          ]
        }
      }
    ]
  ],
  async validate(runtime, message, state) {
    const githubService = runtime.getService("github");
    if (!githubService) {
      return false;
    }
    const { issue, comment, repository } = state?.data || {};
    if (!issue || !repository) {
      return false;
    }
    const mentionText = comment?.body || issue?.body || "";
    const agentName = runtime.character.name;
    const mentionPatterns = [
      new RegExp(`@${agentName}\\b`, "i"),
      new RegExp(`@${agentName.toLowerCase()}\\b`, "i"),
      new RegExp(`${agentName}\\b.*help`, "i"),
      new RegExp(`${agentName}\\b.*fix`, "i")
    ];
    return mentionPatterns.some((pattern) => pattern.test(mentionText));
  },
  async handler(runtime, message, state = {
    values: {},
    data: {},
    text: ""
  }, options, callback) {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        throw new Error("GitHub service is not available");
      }
      const { issue, comment, repository, action: eventAction } = options || {};
      if (!repository || !issue) {
        throw new Error("Repository and issue information is required");
      }
      logger11.info(`Intelligent mention response in ${repository.full_name}#${issue.number}`);
      const isIssueComment = !!comment;
      const mentionText = isIssueComment ? comment.body : issue.body;
      const analysis = await analyzeMention(runtime, mentionText, issue, repository, isIssueComment);
      let responseText = analysis.suggestedResponse;
      if (analysis.confidence < 0.5) {
        responseText += `

*Note: I'm ${Math.round(analysis.confidence * 100)}% confident in understanding your request. Please feel free to clarify if needed.*`;
      }
      if (analysis.urgency === "high") {
        responseText = `\u{1F6A8} **High Priority Request Detected**

${responseText}`;
      }
      if (analysis.requiresHuman) {
        responseText += `

\u26A0\uFE0F **Human Review Recommended**: ${analysis.reasoning}`;
      }
      await githubService.createIssueComment(repository.owner.login, repository.name, issue.number, responseText);
      if (analysis.shouldAutoCode && analysis.confidence > 0.6 && analysis.requestType === "code_fix" && !analysis.requiresHuman) {
        logger11.info(`Triggering auto-code for mention with confidence ${analysis.confidence}`);
        try {
          const autoCodeAction = runtime.actions.find((a) => a.name === "AUTO_CODE_ISSUE");
          if (autoCodeAction) {
            await autoCodeAction.handler(runtime, message, state, {
              issue,
              repository,
              action: eventAction
            }, callback);
          }
        } catch (error) {
          logger11.error("Failed to trigger auto-coding:", error);
          await githubService.createIssueComment(repository.owner.login, repository.name, issue.number, "I attempted to create an automated fix but encountered an issue. A human developer should review this request.");
        }
      }
      await callback?.({
        text: `\u{1F916} **Intelligent mention response generated**

**Analysis**: ${analysis.requestType} (confidence: ${Math.round(analysis.confidence * 100)}%)
**Auto-coding**: ${analysis.shouldAutoCode ? "Triggered" : "Not suitable"}
**Urgency**: ${analysis.urgency}

**Reasoning**: ${analysis.reasoning}`,
        thought: `Intelligent mention handling: ${analysis.requestType} with ${Math.round(analysis.confidence * 100)}% confidence`,
        actions: [
          "RESPOND_TO_GITHUB_MENTION"
        ]
      });
    } catch (error) {
      logger11.error("Failed to handle GitHub mention intelligently:", error);
      try {
        const { issue, repository } = options || {};
        if (issue && repository) {
          const githubService = runtime.getService("github");
          await githubService?.createIssueComment(repository.owner.login, repository.name, issue.number, "I see you've mentioned me, but I encountered an error processing your request. Please try again or contact a human developer.");
        }
      } catch (fallbackError) {
        logger11.error("Fallback response also failed:", fallbackError);
      }
      await callback?.({
        text: `\u274C Failed to handle mention intelligently: ${error instanceof Error ? error.message : String(error)}`,
        thought: "Error in intelligent mention handling"
      });
    }
  }
};

// src/providers/github.ts
import { logger as logger12 } from "@elizaos/core";
var githubRepositoryProvider = {
  name: "GITHUB_REPOSITORY_CONTEXT",
  description: "Provides context about GitHub repositories from current state",
  get: /* @__PURE__ */ __name(async (runtime, message, state) => {
    try {
      const githubState = state?.github;
      if (!githubState) {
        return {
          text: "GitHub Repository context is available. I can help you search for repositories, get repository details, and manage repository-related tasks.",
          values: {},
          data: {}
        };
      }
      let contextText = "";
      const values = {};
      const data = {};
      if (githubState.lastRepository) {
        const repo = githubState.lastRepository;
        contextText += `Current Repository: ${repo.full_name}
`;
        contextText += `Description: ${repo.description || "No description"}
`;
        contextText += `Language: ${repo.language || "Unknown"}
`;
        contextText += `Stars: ${repo.stargazers_count}
`;
        contextText += `Forks: ${repo.forks_count}
`;
        contextText += `Open Issues: ${repo.open_issues_count}
`;
        contextText += `Private: ${repo.private ? "Yes" : "No"}
`;
        values.currentRepository = repo.full_name;
        values.repositoryOwner = repo.owner.login;
        values.repositoryName = repo.name;
        values.repositoryLanguage = repo.language;
        values.repositoryStars = repo.stargazers_count;
        values.repositoryForks = repo.forks_count;
        values.repositoryOpenIssues = repo.open_issues_count;
        values.repositoryPrivate = repo.private;
        data.lastRepository = repo;
      }
      if (githubState.repositories && Object.keys(githubState.repositories).length > 0) {
        const recentRepos = Object.values(githubState.repositories).sort((a, b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()).slice(0, 5);
        contextText += "\nRecent Repositories:\n";
        recentRepos.forEach((repo) => {
          contextText += `- ${repo.full_name} (${repo.language || "Unknown"})
`;
        });
        values.recentRepositories = recentRepos.map((r) => r.full_name);
        data.repositories = githubState.repositories;
      }
      if (githubState.lastCreatedRepository) {
        const repo = githubState.lastCreatedRepository;
        contextText += `
Last Created Repository: ${repo.full_name}
`;
        contextText += `Created: ${new Date(repo.created_at).toLocaleDateString()}
`;
        values.lastCreatedRepository = repo.full_name;
        data.lastCreatedRepository = repo;
      }
      if (!contextText) {
        contextText = "GitHub Repository context is available. I can help you search for repositories, get repository details, and manage repository-related tasks.";
      }
      return {
        text: contextText,
        values,
        data
      };
    } catch (error) {
      logger12.error("Error in GitHub repository provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }, "get")
};
var githubIssuesProvider = {
  name: "GITHUB_ISSUES_CONTEXT",
  description: "Provides context about GitHub issues from current state",
  get: /* @__PURE__ */ __name(async (runtime, message, state) => {
    try {
      const githubState = state?.github;
      if (!githubState) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      let contextText = "";
      const values = {};
      const data = {};
      if (githubState.lastIssue) {
        const issue = githubState.lastIssue;
        contextText += `Current Issue: #${issue.number} - ${issue.title}
`;
        contextText += `State: ${issue.state}
`;
        contextText += `Author: @${issue.user.login}
`;
        contextText += `Created: ${new Date(issue.created_at).toLocaleDateString()}
`;
        contextText += `Comments: ${issue.comments}
`;
        if (issue.labels.length > 0) {
          contextText += `Labels: ${issue.labels.map((l) => l.name).join(", ")}
`;
        }
        if (issue.assignees.length > 0) {
          contextText += `Assignees: ${issue.assignees.map((a) => `@${a.login}`).join(", ")}
`;
        }
        values.currentIssue = issue.number;
        values.issueTitle = issue.title;
        values.issueState = issue.state;
        values.issueAuthor = issue.user.login;
        values.issueLabels = issue.labels.map((l) => l.name);
        values.issueAssignees = issue.assignees.map((a) => a.login);
        values.issueComments = issue.comments;
        data.lastIssue = issue;
      }
      if (githubState.issues && Object.keys(githubState.issues).length > 0) {
        const recentIssues = Object.values(githubState.issues).sort((a, b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()).slice(0, 5);
        contextText += "\nRecent Issues:\n";
        recentIssues.forEach((issue) => {
          const repoMatch = Object.keys(githubState.issues || {}).find((key) => githubState.issues[key].id === issue.id);
          const repoName = repoMatch?.split("#")[0] || "unknown";
          contextText += `- ${repoName}#${issue.number}: ${issue.title} (${issue.state})
`;
        });
        values.recentIssues = recentIssues.map((i) => `#${i.number}: ${i.title}`);
        data.issues = githubState.issues;
      }
      if (githubState.lastCreatedIssue) {
        const issue = githubState.lastCreatedIssue;
        contextText += `
Last Created Issue: #${issue.number} - ${issue.title}
`;
        contextText += `Created: ${new Date(issue.created_at).toLocaleDateString()}
`;
        values.lastCreatedIssue = issue.number;
        values.lastCreatedIssueTitle = issue.title;
        data.lastCreatedIssue = issue;
      }
      if (githubState.lastIssueSearchResults) {
        const searchResults = githubState.lastIssueSearchResults;
        contextText += `
Last Issue Search: "${githubState.lastIssueSearchQuery}"
`;
        contextText += `Found: ${searchResults.total_count} issues
`;
        values.lastIssueSearchQuery = githubState.lastIssueSearchQuery;
        values.lastIssueSearchCount = searchResults.total_count;
        data.lastIssueSearchResults = searchResults;
      }
      return {
        text: contextText,
        values,
        data
      };
    } catch (error) {
      logger12.error("Error in GitHub issues provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }, "get")
};
var githubPullRequestsProvider = {
  name: "GITHUB_PULL_REQUESTS_CONTEXT",
  description: "Provides context about GitHub pull requests from current state",
  get: /* @__PURE__ */ __name(async (runtime, message, state) => {
    try {
      const githubState = state?.github;
      if (!githubState) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      let contextText = "";
      const values = {};
      const data = {};
      if (githubState.lastPullRequest) {
        const pr = githubState.lastPullRequest;
        contextText += `Current Pull Request: #${pr.number} - ${pr.title}
`;
        contextText += `State: ${pr.state}${pr.merged ? " (merged)" : ""}
`;
        contextText += `Draft: ${pr.draft ? "Yes" : "No"}
`;
        contextText += `Author: @${pr.user.login}
`;
        contextText += `Created: ${new Date(pr.created_at).toLocaleDateString()}
`;
        contextText += `Head: ${pr.head.ref} \u2192 Base: ${pr.base.ref}
`;
        contextText += `Files Changed: ${pr.changed_files}
`;
        contextText += `Additions: +${pr.additions}, Deletions: -${pr.deletions}
`;
        if (pr.labels.length > 0) {
          contextText += `Labels: ${pr.labels.map((l) => l.name).join(", ")}
`;
        }
        if (pr.assignees.length > 0) {
          contextText += `Assignees: ${pr.assignees.map((a) => `@${a.login}`).join(", ")}
`;
        }
        values.currentPullRequest = pr.number;
        values.pullRequestTitle = pr.title;
        values.pullRequestState = pr.state;
        values.pullRequestDraft = pr.draft;
        values.pullRequestMerged = pr.merged;
        values.pullRequestAuthor = pr.user.login;
        values.pullRequestHead = pr.head.ref;
        values.pullRequestBase = pr.base.ref;
        values.pullRequestFilesChanged = pr.changed_files;
        values.pullRequestAdditions = pr.additions;
        values.pullRequestDeletions = pr.deletions;
        values.pullRequestLabels = pr.labels.map((l) => l.name);
        values.pullRequestAssignees = pr.assignees.map((a) => a.login);
        data.lastPullRequest = pr;
      }
      if (githubState.pullRequests && Object.keys(githubState.pullRequests).length > 0) {
        const recentPRs = Object.values(githubState.pullRequests).sort((a, b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()).slice(0, 5);
        contextText += "\nRecent Pull Requests:\n";
        recentPRs.forEach((pr) => {
          const repoMatch = Object.keys(githubState.pullRequests || {}).find((key) => githubState.pullRequests[key].id === pr.id);
          const repoName = repoMatch?.split("#")[0] || "unknown";
          const status = pr.merged ? "merged" : pr.state;
          contextText += `- ${repoName}#${pr.number}: ${pr.title} (${status})
`;
        });
        values.recentPullRequests = recentPRs.map((pr) => `#${pr.number}: ${pr.title}`);
        data.pullRequests = githubState.pullRequests;
      }
      if (githubState.lastCreatedPullRequest) {
        const pr = githubState.lastCreatedPullRequest;
        contextText += `
Last Created Pull Request: #${pr.number} - ${pr.title}
`;
        contextText += `Created: ${new Date(pr.created_at).toLocaleDateString()}
`;
        contextText += `Head: ${pr.head.ref} \u2192 Base: ${pr.base.ref}
`;
        values.lastCreatedPullRequest = pr.number;
        values.lastCreatedPullRequestTitle = pr.title;
        values.lastCreatedPullRequestHead = pr.head.ref;
        values.lastCreatedPullRequestBase = pr.base.ref;
        data.lastCreatedPullRequest = pr;
      }
      if (githubState.lastMergedPullRequest) {
        const merged = githubState.lastMergedPullRequest;
        contextText += `
Last Merged Pull Request: ${merged.owner}/${merged.repo}#${merged.pull_number}
`;
        contextText += `Commit SHA: ${merged.sha}
`;
        values.lastMergedPullRequest = `${merged.owner}/${merged.repo}#${merged.pull_number}`;
        values.lastMergedCommitSha = merged.sha;
        data.lastMergedPullRequest = merged;
      }
      return {
        text: contextText,
        values,
        data
      };
    } catch (error) {
      logger12.error("Error in GitHub pull requests provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }, "get")
};
var githubActivityProvider = {
  name: "GITHUB_ACTIVITY_CONTEXT",
  description: "Provides context about recent GitHub activity and statistics",
  get: /* @__PURE__ */ __name(async (runtime, message, state) => {
    try {
      const githubService = runtime.getService("github");
      const githubState = state?.github;
      if (!githubService && !githubState) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      let contextText = "";
      const values = {};
      const data = {};
      if (githubState?.activityStats) {
        const stats = githubState.activityStats;
        contextText += "GitHub Activity Summary:\n";
        contextText += `Total Actions: ${stats.total}
`;
        contextText += `Successful: ${stats.success}
`;
        contextText += `Failed: ${stats.failed}
`;
        contextText += `Success Rate: ${stats.total > 0 ? Math.round(stats.success / stats.total * 100) : 0}%
`;
        values.totalActions = stats.total;
        values.successfulActions = stats.success;
        values.failedActions = stats.failed;
        values.successRate = stats.total > 0 ? Math.round(stats.success / stats.total * 100) : 0;
        data.activityStats = stats;
      } else {
        contextText += "GitHub activity context:\n";
      }
      if (githubService) {
        try {
          const recentActivity = githubService.getActivityLog(10);
          if (recentActivity.length > 0) {
            contextText += "\nRecent Activity (last 10 actions):\n";
            recentActivity.forEach((activity) => {
              const time = new Date(activity.timestamp).toLocaleTimeString();
              const status = activity.success ? "\u2705" : "\u274C";
              const action = activity.action.replace(/_/g, " ").toLowerCase();
              contextText += `- ${time} ${status} ${action} ${activity.resource_type}
`;
            });
            values.recentActivityCount = recentActivity.length;
            values.lastActivity = recentActivity[0];
            data.recentActivity = recentActivity;
          }
        } catch (error) {
          logger12.warn("Could not fetch recent activity from service:", error);
        }
      }
      if (githubState?.rateLimit) {
        const rateLimit = githubState.rateLimit;
        const usage = Math.round(rateLimit.used / rateLimit.limit * 100);
        contextText += "\nAPI Rate Limit:\n";
        contextText += `Used: ${rateLimit.used}/${rateLimit.limit} (${usage}%)
`;
        contextText += `Remaining: ${rateLimit.remaining}
`;
        if (githubState.rateLimitCheckedAt) {
          contextText += `Last Checked: ${new Date(githubState.rateLimitCheckedAt).toLocaleString()}
`;
        }
        values.rateLimitUsed = rateLimit.used;
        values.rateLimitLimit = rateLimit.limit;
        values.rateLimitRemaining = rateLimit.remaining;
        values.rateLimitUsage = usage;
        data.rateLimit = rateLimit;
      }
      return {
        text: contextText,
        values,
        data
      };
    } catch (error) {
      logger12.error("Error in GitHub activity provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }, "get")
};
var githubUserProvider = {
  name: "GITHUB_USER_CONTEXT",
  description: "Provides context about the authenticated GitHub user",
  get: /* @__PURE__ */ __name(async (runtime, message, state) => {
    try {
      const githubService = runtime.getService("github");
      if (!githubService) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      try {
        const user = await githubService.getCurrentUser();
        const contextText = `GitHub User: @${user.login}
Name: ${user.name || "Not specified"}
Email: ${user.email || "Not public"}
Bio: ${user.bio || "No bio"}
Company: ${user.company || "Not specified"}
Location: ${user.location || "Not specified"}
Public Repos: ${user.public_repos}
Followers: ${user.followers}
Following: ${user.following}
Account Created: ${new Date(user.created_at).toLocaleDateString()}
Profile: ${user.html_url}`;
        const values = {
          githubUsername: user.login,
          githubName: user.name,
          githubEmail: user.email,
          githubBio: user.bio,
          githubCompany: user.company,
          githubLocation: user.location,
          githubPublicRepos: user.public_repos,
          githubFollowers: user.followers,
          githubFollowing: user.following,
          githubAccountType: user.type,
          githubProfileUrl: user.html_url
        };
        const data = {
          currentUser: user
        };
        return {
          text: contextText,
          values,
          data
        };
      } catch (error) {
        logger12.warn("Could not fetch GitHub user information:", error);
        return {
          text: "GitHub user information unavailable",
          values: {},
          data: {}
        };
      }
    } catch (error) {
      logger12.error("Error in GitHub user provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }, "get")
};

// src/index.ts
var WebhookEventAnalysisSchema = z4.object({
  isAgentMentioned: z4.boolean(),
  confidence: z4.number().min(0).max(1),
  reasoning: z4.string(),
  mentionContext: z4.string().optional(),
  actionRequired: z4.boolean(),
  urgency: z4.enum([
    "low",
    "medium",
    "high"
  ]),
  mentionType: z4.enum([
    "direct_mention",
    "implicit_request",
    "false_positive",
    "none"
  ])
});
var MessageRelevanceSchema = z4.object({
  isGitHubRelated: z4.boolean(),
  confidence: z4.number().min(0).max(1),
  reasoning: z4.string(),
  context: z4.enum([
    "repository",
    "issue",
    "pull_request",
    "general",
    "none"
  ]),
  requiresAction: z4.boolean()
});
async function analyzeWebhookMention(runtime, content, agentName, context) {
  const prompt = `Analyze this GitHub content to determine if the agent "${agentName}" is being mentioned or requested:

Content: "${content}"
Context: ${context}

Consider:
1. Direct mentions like @${agentName}
2. Implicit requests for help or automation
3. Context clues that suggest the agent should respond
4. False positives (just mentioning the name without intent)

Respond with JSON:
{
  "isAgentMentioned": boolean,
  "confidence": 0.0-1.0,
  "reasoning": "detailed explanation",
  "mentionContext": "relevant context around the mention",
  "actionRequired": boolean,
  "urgency": "low" | "medium" | "high",
  "mentionType": "direct_mention" | "implicit_request" | "false_positive" | "none"
}`;
  try {
    const response = await runtime.useModel(ModelType3.TEXT_LARGE, {
      prompt,
      temperature: 0.2,
      max_tokens: 400
    });
    let jsonText = response;
    if (typeof response === "string") {
      jsonText = response.replace(/```json\s*|\s*```/g, "").trim();
      const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        jsonText = jsonMatch[0];
      }
    }
    return WebhookEventAnalysisSchema.parse(JSON.parse(jsonText));
  } catch (_error) {
    logger13.warn("Failed to analyze webhook mention:", _error);
    return {
      isAgentMentioned: false,
      confidence: 0,
      reasoning: "Failed to parse mention analysis",
      actionRequired: false,
      urgency: "low",
      mentionType: "none"
    };
  }
}
__name(analyzeWebhookMention, "analyzeWebhookMention");
async function analyzeMessageRelevance(runtime, text) {
  const prompt = `Analyze this message to determine if it's related to GitHub or requires GitHub plugin functionality:

Message: "${text}"

Consider:
1. Mentions of GitHub, repositories, issues, pull requests
2. Git commands or operations
3. Repository names (owner/repo format)
4. Issue/PR numbers (#123)
5. GitHub URLs
6. Development workflows that might involve GitHub

Respond with JSON:
{
  "isGitHubRelated": boolean,
  "confidence": 0.0-1.0,
  "reasoning": "detailed explanation",
  "context": "repository" | "issue" | "pull_request" | "general" | "none",
  "requiresAction": boolean
}`;
  try {
    const response = await runtime.useModel(ModelType3.TEXT_LARGE, {
      prompt,
      temperature: 0.2,
      max_tokens: 300
    });
    let jsonText = response;
    if (typeof response === "string") {
      jsonText = response.replace(/```json\s*|\s*```/g, "").trim();
      const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        jsonText = jsonMatch[0];
      }
    }
    return MessageRelevanceSchema.parse(JSON.parse(jsonText));
  } catch (error) {
    logger13.warn("Failed to analyze message relevance:", error);
    return {
      isGitHubRelated: false,
      confidence: 0,
      reasoning: "Failed to parse relevance analysis",
      context: "none",
      requiresAction: false
    };
  }
}
__name(analyzeMessageRelevance, "analyzeMessageRelevance");
function verifyWebhookSignature(payload, signature, secret) {
  if (!signature || !secret) {
    return false;
  }
  const hmac = crypto.createHmac("sha256", secret);
  const digest = `sha256=${hmac.update(JSON.stringify(payload)).digest("hex")}`;
  if (signature.length !== digest.length) {
    return false;
  }
  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));
}
__name(verifyWebhookSignature, "verifyWebhookSignature");
async function processWebhookEvent(runtime, event, payload) {
  await runtime.emitEvent(`github:${event}`, {
    runtime,
    payload,
    repository: payload.repository,
    sender: payload.sender
  });
  switch (event) {
    case "issues":
      if (payload.action === "opened" || payload.action === "edited") {
        const issue = payload.issue;
        const body = issue.body || "";
        const title = issue.title || "";
        const agentName = runtime.character.name;
        const content = `${title}
${body}`;
        const context = `Issue #${issue.number} in ${payload.repository.full_name}`;
        const analysis = await analyzeWebhookMention(runtime, content, agentName, context);
        if (analysis.isAgentMentioned && analysis.confidence > 0.6) {
          logger13.info(`Agent ${agentName} intelligently detected in issue #${issue.number} (confidence: ${Math.round(analysis.confidence * 100)}%)`);
          logger13.debug(`Mention analysis: ${analysis.reasoning}`);
          await runtime.emitEvent("github:agent_mentioned", {
            runtime,
            issue,
            repository: payload.repository,
            action: payload.action,
            analysis
          });
        } else if (analysis.confidence > 0.3) {
          logger13.debug(`Possible mention detected but below threshold: ${analysis.reasoning}`);
        }
      }
      break;
    case "issue_comment":
      if (payload.action === "created" || payload.action === "edited") {
        const comment = payload.comment;
        const body = comment.body || "";
        const agentName = runtime.character.name;
        const context = `Comment on issue #${payload.issue.number} in ${payload.repository.full_name}`;
        const analysis = await analyzeWebhookMention(runtime, body, agentName, context);
        if (analysis.isAgentMentioned && analysis.confidence > 0.6) {
          logger13.info(`Agent ${agentName} intelligently detected in issue comment (confidence: ${Math.round(analysis.confidence * 100)}%)`);
          logger13.debug(`Mention analysis: ${analysis.reasoning}`);
          await runtime.emitEvent("github:agent_mentioned_comment", {
            runtime,
            issue: payload.issue,
            comment,
            repository: payload.repository,
            action: payload.action,
            analysis
          });
        } else if (analysis.confidence > 0.3) {
          logger13.debug(`Possible mention in comment detected but below threshold: ${analysis.reasoning}`);
        }
      }
      break;
    case "pull_request":
      if (payload.action === "opened") {
        await runtime.emitEvent("github:pr_opened", {
          runtime,
          pullRequest: payload.pull_request,
          repository: payload.repository
        });
      }
      break;
    default:
      logger13.debug(`Received GitHub webhook event: ${event}`);
  }
}
__name(processWebhookEvent, "processWebhookEvent");
var githubActions = [
  // Repository actions - read actions enabled, create disabled
  getRepositoryAction,
  listRepositoriesAction,
  createRepositoryAction,
  searchRepositoriesAction,
  // Issue actions - read/list enabled, create disabled by default
  getIssueAction,
  listIssuesAction,
  createIssueAction,
  searchIssuesAction,
  // Pull request actions - view enabled, modify disabled
  getPullRequestAction,
  listPullRequestsAction,
  createPullRequestAction,
  mergePullRequestAction,
  // Activity actions - all enabled for monitoring
  getGitHubActivityAction,
  clearGitHubActivityAction,
  getGitHubRateLimitAction,
  // Search actions - enabled for information gathering
  searchGitHubAction,
  // User actions - all enabled for information
  getUserProfileAction,
  getUserStatsAction,
  listUserRepositoriesAction,
  // Branch actions - list enabled, create/modify disabled
  listBranchesAction,
  createBranchAction,
  getBranchProtectionAction,
  // Stats actions - all enabled for monitoring
  getRepositoryStatsAction,
  getRepositoryTrafficAction,
  // Webhook actions - disabled by default (infrastructure changes)
  createWebhookAction,
  listWebhooksAction,
  deleteWebhookAction,
  pingWebhookAction,
  // Auto-coder actions - enabled for productivity
  autoCodeIssueAction,
  respondToMentionAction
];
var githubProviders = [
  githubRepositoryProvider,
  githubIssuesProvider,
  githubPullRequestsProvider,
  githubActivityProvider,
  githubUserProvider
];
var githubPlugin = {
  name: "plugin-github",
  description: "Comprehensive GitHub integration plugin for ElizaOS with repository management, issue tracking, and PR workflows",
  dependencies: [
    "ngrok"
  ],
  config: {
    GITHUB_TOKEN: process.env.GITHUB_TOKEN,
    GITHUB_OWNER: process.env.GITHUB_OWNER,
    GITHUB_WEBHOOK_SECRET: process.env.GITHUB_WEBHOOK_SECRET
  },
  async init(config, runtime) {
    logger13.info("Initializing GitHub plugin...");
    try {
      const token = runtime?.getSetting("GITHUB_TOKEN") || runtime?.getSetting("GITHUB_TOKEN") || config.GITHUB_TOKEN || config.GITHUB_TOKEN || process.env.GITHUB_TOKEN || process.env.GITHUB_TOKEN;
      const isTestEnv = process.env.NODE_ENV === "test" || process.env.VITEST === "true" || process.env.JEST_WORKER_ID !== void 0 || process.argv.some((arg) => arg.includes("test") || arg.includes("spec")) || typeof globalThis.describe !== "undefined" || // Vitest globals
      typeof globalThis.it !== "undefined" || typeof globalThis.expect !== "undefined" || token && (token.startsWith("test-") || token.startsWith("dummy-") || token === "dummy-token-for-testing") || // Additional test environment detection for benchmarks and scenarios
      process.argv.some((arg) => arg.includes("benchmark") || arg.includes("scenario")) || process.cwd().includes("scenarios");
      if (token && token.includes("dummy")) {
        console.log(`GitHub Plugin Debug: isTestEnv=${isTestEnv}, token=${token}, NODE_ENV=${process.env.NODE_ENV}`);
      }
      const owner = runtime?.getSetting("GITHUB_OWNER") || config.GITHUB_OWNER || process.env.GITHUB_OWNER;
      const webhookSecret = runtime?.getSetting("GITHUB_WEBHOOK_SECRET") || config.GITHUB_WEBHOOK_SECRET || process.env.GITHUB_WEBHOOK_SECRET;
      const validatedConfig = {
        GITHUB_TOKEN: token,
        GITHUB_OWNER: owner,
        GITHUB_WEBHOOK_SECRET: webhookSecret
      };
      const configSchema = isTestEnv ? githubConfigSchemaFlexible : githubConfigSchema;
      if (isTestEnv) {
        try {
          await configSchema.parseAsync(validatedConfig);
        } catch (validationError) {
          logger13.warn("Test mode: Config validation failed but continuing with mock config:", validationError);
        }
      } else {
        if (!token) {
          throw new Error("GitHub token is required");
        }
        await configSchema.parseAsync(validatedConfig);
      }
      if (runtime) {
        runtime.character.settings = runtime.character.settings || {};
        runtime.character.settings.githubConfig = validatedConfig;
      }
      logger13.info("GitHub plugin configuration validated successfully");
      if (validatedConfig.GITHUB_TOKEN) {
        logger13.info(`GitHub token type: ${validatedConfig.GITHUB_TOKEN.startsWith("ghp_") ? "Personal Access Token" : validatedConfig.GITHUB_TOKEN.startsWith("github_pat_") ? "Fine-grained Token" : "Other"}`);
      } else if (isTestEnv) {
        logger13.info("Running in test mode without GitHub token");
      }
      if (runtime && !isTestEnv) {
        setTimeout(async () => {
          try {
            const tunnelService = runtime.getService("tunnel");
            if (tunnelService && tunnelService.isActive()) {
              const tunnelUrl = await tunnelService.getUrl();
              if (tunnelUrl) {
                logger13.info(`GitHub webhook endpoint available at: ${tunnelUrl}/api/github/webhook`);
                if (validatedConfig.GITHUB_WEBHOOK_SECRET) {
                  logger13.info("GitHub webhook secret is configured - signatures will be verified");
                } else {
                  logger13.warn("GitHub webhook secret is NOT configured - webhooks will be accepted without verification");
                }
              }
            } else {
              logger13.info("Ngrok service not available - webhooks will only work with public URLs");
            }
          } catch (error) {
            logger13.debug("Could not check Ngrok service status:", error);
          }
        }, 1e3);
      }
    } catch (error) {
      logger13.error("GitHub plugin configuration validation failed:", error);
      const isTestEnvInCatch = process.env.NODE_ENV === "test" || process.env.VITEST === "true" || process.argv.some((arg) => arg.includes("test")) || typeof globalThis.describe !== "undefined" || typeof globalThis.it !== "undefined" || typeof globalThis.expect !== "undefined";
      if (isTestEnvInCatch) {
        logger13.warn("Running in test mode with invalid GitHub configuration");
        return;
      }
      throw new Error(`Invalid GitHub plugin configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  },
  routes: [
    {
      name: "github-status",
      path: "/api/github/status",
      type: "GET",
      handler: /* @__PURE__ */ __name(async (req, res) => {
        try {
          const runtime = req.runtime;
          const config = runtime?.character?.settings?.githubConfig;
          res.json({
            status: "active",
            plugin: "plugin-github",
            version: "1.0.0",
            authenticated: !!config?.GITHUB_TOKEN,
            tokenType: config?.GITHUB_TOKEN?.startsWith("ghp_") ? "pat" : config?.GITHUB_TOKEN?.startsWith("github_pat_") ? "fine-grained" : "unknown",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (error) {
          res.status(500).json({
            status: "error",
            error: error instanceof Error ? error.message : String(error),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }, "handler")
    },
    {
      name: "github-activity",
      path: "/api/github/activity",
      type: "GET",
      handler: /* @__PURE__ */ __name(async (req, res) => {
        try {
          const runtime = req.runtime;
          const githubService = runtime?.getService("github");
          if (!githubService) {
            return res.status(503).json({
              error: "GitHub service not available",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
          }
          const limit = parseInt(req.query.limit, 10) || 50;
          const activityLog = githubService.getActivityLog(limit);
          const stats = {
            total: activityLog.length,
            success: activityLog.filter((a) => a.success).length,
            failed: activityLog.filter((a) => !a.success).length
          };
          res.json({
            status: "success",
            stats,
            activity: activityLog,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (error) {
          res.status(500).json({
            status: "error",
            error: error instanceof Error ? error.message : String(error),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }, "handler")
    },
    {
      name: "github-rate-limit",
      path: "/api/github/rate-limit",
      type: "GET",
      handler: /* @__PURE__ */ __name(async (req, res) => {
        try {
          const runtime = req.runtime;
          const githubService = runtime?.getService("github");
          if (!githubService) {
            return res.status(503).json({
              error: "GitHub service not available",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
          }
          const rateLimit = await githubService.getRateLimit();
          res.json({
            status: "success",
            rateLimit,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (error) {
          res.status(500).json({
            status: "error",
            error: error instanceof Error ? error.message : String(error),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }, "handler")
    },
    {
      name: "github-webhook",
      path: "/api/github/webhook",
      type: "POST",
      handler: /* @__PURE__ */ __name(async (req, res) => {
        try {
          const runtime = req.runtime;
          const config = runtime?.character?.settings?.githubConfig;
          const secret = config?.GITHUB_WEBHOOK_SECRET;
          const event = req.headers["x-github-event"];
          const signature = req.headers["x-hub-signature-256"];
          const payload = req.body;
          logger13.info(`Received GitHub webhook event: ${event}`);
          if (!secret) {
            logger13.error("GitHub webhook secret not configured - rejecting webhook for security");
            res.statusCode = 401;
            return res.end("Webhook secret required for security");
          }
          if (!signature) {
            logger13.error("GitHub webhook signature missing");
            res.statusCode = 401;
            return res.end("Webhook signature required");
          }
          if (!verifyWebhookSignature(payload, signature, secret)) {
            logger13.error("GitHub webhook signature verification failed");
            res.statusCode = 401;
            return res.end("Invalid webhook signature");
          }
          logger13.debug("GitHub webhook signature verified successfully");
          if (runtime) {
            await processWebhookEvent(runtime, event, payload);
          } else {
            logger13.warn("Runtime not available for webhook processing");
          }
          res.statusCode = 200;
          res.end("OK");
        } catch (error) {
          logger13.error("Error processing GitHub webhook:", error);
          res.statusCode = 500;
          res.end("Internal Server Error");
        }
      }, "handler")
    }
  ],
  events: {
    MESSAGE_RECEIVED: [
      async (params) => {
        const { runtime, message } = params;
        if (message.content.text && runtime) {
          try {
            const relevance = await analyzeMessageRelevance(runtime, message.content.text);
            if (relevance.isGitHubRelated && relevance.confidence > 0.7) {
              logger13.debug("GitHub-related message intelligently detected", {
                messageId: message.id,
                confidence: Math.round(relevance.confidence * 100),
                context: relevance.context,
                reasoning: relevance.reasoning,
                requiresAction: relevance.requiresAction
              });
              if (relevance.requiresAction && relevance.confidence > 0.8) {
                logger13.info(`High-confidence GitHub action required: ${relevance.reasoning}`);
              }
            }
          } catch (error) {
            const text = message.content.text.toLowerCase();
            const hasBasicGithubPattern = /github\.com|@[\w-]+\/[\w-]+|#\d+/.test(text);
            if (hasBasicGithubPattern) {
              logger13.debug("GitHub-related message detected via fallback pattern matching", {
                messageId: message.id,
                note: "LLM analysis failed, using basic patterns"
              });
            }
          }
        }
      }
    ],
    "github:agent_mentioned": [
      async (params) => {
        const { runtime, issue, repository, action } = params;
        logger13.info(`Agent mentioned in issue #${issue.number} in ${repository.full_name}`);
        await runtime.processAction("RESPOND_TO_GITHUB_MENTION", {
          issue,
          repository,
          action
        });
      }
    ],
    "github:agent_mentioned_comment": [
      async (params) => {
        const { runtime, issue, comment, repository, action } = params;
        logger13.info(`Agent mentioned in comment on issue #${issue.number}`);
        await runtime.processAction("RESPOND_TO_GITHUB_MENTION", {
          issue,
          comment,
          repository,
          action
        });
      }
    ],
    "github:issues": [
      async (params) => {
        const { runtime, payload } = params;
        logger13.info(`GitHub issue event: ${payload.action} on issue #${payload.issue.number}`);
        if (payload.action === "opened") {
          logger13.info(`New issue opened: #${payload.issue.number} - ${payload.issue.title}`);
        }
      }
    ],
    "github:pull_request": [
      async (params) => {
        const { runtime, payload } = params;
        logger13.info(`GitHub PR event: ${payload.action} on PR #${payload.pull_request.number}`);
        if (payload.action === "opened") {
          logger13.info(`New PR opened: #${payload.pull_request.number} - ${payload.pull_request.title}`);
        }
      }
    ]
  },
  services: [
    GitHubService
  ],
  actions: githubActions,
  providers: githubProviders,
  // Tests are loaded separately to avoid bundling test framework code in production
  tests: []
};
var index_default = githubPlugin;
export {
  GitHubAPIError2 as GitHubAPIError,
  GitHubAuthenticationError2 as GitHubAuthenticationError,
  GitHubRateLimitError2 as GitHubRateLimitError,
  GitHubService,
  createIssueSchema,
  createPullRequestSchema,
  createRepositorySchema,
  index_default as default,
  githubActions,
  githubConfigSchema,
  githubConfigSchemaFlexible,
  githubPlugin,
  githubProviders
};
//# sourceMappingURL=index.js.map