{
  "version": 3,
  "sources": ["../src/tool-compatibility/providers/openai.ts", "../src/tool-compatibility/providers/anthropic.ts", "../src/tool-compatibility/providers/google.ts", "../src/tool-compatibility/index.ts", "../src/index.ts", "../src/actions/callToolAction.ts", "../src/types.ts", "../src/utils/error.ts", "../src/templates/errorAnalysisPrompt.ts", "../src/utils/processing.ts", "../src/templates/resourceAnalysisTemplate.ts", "../src/templates/toolReasoningTemplate.ts", "../src/utils/mcp.ts", "../src/utils/selection.ts", "../src/utils/json.ts", "../src/utils/wrapper.ts", "../src/templates/toolSelectionTemplate.ts", "../src/utils/schemas.ts", "../src/utils/validation.ts", "../src/utils/handler.ts", "../src/actions/readResourceAction.ts", "../src/templates/resourceSelectionTemplate.ts", "../src/provider.ts", "../src/service.ts"],
  "sourcesContent": [
    "import { McpToolCompatibility, type ModelInfo } from '../index';\n\nexport class OpenAIMcpCompatibility extends McpToolCompatibility {\n  constructor(modelInfo: ModelInfo) {\n    super(modelInfo);\n  }\n\n  shouldApply(): boolean {\n    // Apply for OpenAI models that don't support structured outputs\n    // or for reasoning models that need special handling\n    return (\n      this.modelInfo.provider === 'openai' &&\n      (!this.modelInfo.supportsStructuredOutputs || this.modelInfo.isReasoningModel === true)\n    );\n  }\n\n  protected getUnsupportedStringProperties(): string[] {\n    const baseUnsupported = ['format']; // OpenAI models often reject format constraints\n    \n    // Reasoning models (o1, o3) have additional limitations\n    if (this.modelInfo.isReasoningModel === true) {\n      return [...baseUnsupported, 'pattern'];\n    }\n    \n    // Some older OpenAI models don't handle regex patterns well\n    if (this.modelInfo.modelId.includes('gpt-3.5') || this.modelInfo.modelId.includes('davinci')) {\n      return [...baseUnsupported, 'pattern'];\n    }\n    \n    return baseUnsupported;\n  }\n\n  protected getUnsupportedNumberProperties(): string[] {\n    // Reasoning models have more limitations\n    if (this.modelInfo.isReasoningModel === true) {\n      return ['exclusiveMinimum', 'exclusiveMaximum', 'multipleOf'];\n    }\n    \n    // Regular OpenAI models generally handle number constraints well\n    return [];\n  }\n\n  protected getUnsupportedArrayProperties(): string[] {\n    // Most OpenAI models handle array constraints well\n    if (this.modelInfo.isReasoningModel === true) {\n      return ['uniqueItems']; // Reasoning models may ignore uniqueItems\n    }\n    \n    return [];\n  }\n\n  protected getUnsupportedObjectProperties(): string[] {\n    // OpenAI models often ignore these object-level constraints\n    return ['minProperties', 'maxProperties'];\n  }\n}\n\nexport class OpenAIReasoningMcpCompatibility extends McpToolCompatibility {\n  constructor(modelInfo: ModelInfo) {\n    super(modelInfo);\n  }\n\n  shouldApply(): boolean {\n    return (\n      this.modelInfo.provider === 'openai' &&\n      this.modelInfo.isReasoningModel === true\n    );\n  }\n\n  protected getUnsupportedStringProperties(): string[] {\n    // Reasoning models are very strict - remove most constraints\n    return ['format', 'pattern', 'minLength', 'maxLength'];\n  }\n\n  protected getUnsupportedNumberProperties(): string[] {\n    // Keep only basic min/max, remove complex constraints\n    return ['exclusiveMinimum', 'exclusiveMaximum', 'multipleOf'];\n  }\n\n  protected getUnsupportedArrayProperties(): string[] {\n    // Remove array-specific constraints that reasoning models ignore\n    return ['uniqueItems', 'minItems', 'maxItems'];\n  }\n\n  protected getUnsupportedObjectProperties(): string[] {\n    // Remove all object-level constraints for reasoning models\n    return ['minProperties', 'maxProperties', 'additionalProperties'];\n  }\n\n  // Override the mergeDescription for reasoning models to be more explicit\n  protected mergeDescription(originalDescription: string | undefined, constraints: any): string {\n    const constraintText = this.formatConstraintsForReasoningModel(constraints);\n    if (originalDescription) {\n      return `${originalDescription}\\n\\nIMPORTANT: ${constraintText}`;\n    }\n    return `IMPORTANT: ${constraintText}`;\n  }\n\n  private formatConstraintsForReasoningModel(constraints: any): string {\n    const rules: string[] = [];\n    \n    if (constraints.minLength) {\n      rules.push(`minimum ${constraints.minLength} characters`);\n    }\n    if (constraints.maxLength) {\n      rules.push(`maximum ${constraints.maxLength} characters`);\n    }\n    if (constraints.minimum !== undefined) {\n      rules.push(`must be >= ${constraints.minimum}`);\n    }\n    if (constraints.maximum !== undefined) {\n      rules.push(`must be <= ${constraints.maximum}`);\n    }\n    if (constraints.format === 'email') {\n      rules.push(`must be a valid email address`);\n    }\n    if (constraints.format === 'uri' || constraints.format === 'url') {\n      rules.push(`must be a valid URL`);\n    }\n    if (constraints.format === 'uuid') {\n      rules.push(`must be a valid UUID`);\n    }\n    if (constraints.pattern) {\n      rules.push(`must match pattern: ${constraints.pattern}`);\n    }\n    if (constraints.enum) {\n      rules.push(`must be one of: ${constraints.enum.join(', ')}`);\n    }\n    if (constraints.minItems) {\n      rules.push(`array must have at least ${constraints.minItems} items`);\n    }\n    if (constraints.maxItems) {\n      rules.push(`array must have at most ${constraints.maxItems} items`);\n    }\n    \n    return rules.length > 0 ? rules.join(', ') : JSON.stringify(constraints);\n  }\n} ",
    "import { McpToolCompatibility, type ModelInfo } from '../index';\n\nexport class AnthropicMcpCompatibility extends McpToolCompatibility {\n  constructor(modelInfo: ModelInfo) {\n    super(modelInfo);\n  }\n\n  shouldApply(): boolean {\n    // Anthropic models generally handle JSON schema well, but we still\n    // apply light compatibility for edge cases\n    return this.modelInfo.provider === 'anthropic';\n  }\n\n  protected getUnsupportedStringProperties(): string[] {\n    // Anthropic models handle most string constraints well\n    // Only remove very specific edge cases\n    return [];\n  }\n\n  protected getUnsupportedNumberProperties(): string[] {\n    // Anthropic models handle number constraints very well\n    return [];\n  }\n\n  protected getUnsupportedArrayProperties(): string[] {\n    // Anthropic models handle array constraints well\n    return [];\n  }\n\n  protected getUnsupportedObjectProperties(): string[] {\n    // Anthropic models handle object constraints reasonably well\n    // Only remove constraints that are commonly ignored\n    return ['additionalProperties'];\n  }\n\n  // Override to provide a cleaner description format for Anthropic\n  protected mergeDescription(originalDescription: string | undefined, constraints: any): string {\n    // Since Anthropic handles most constraints natively, we use a lighter touch\n    const constraintHints = this.formatConstraintsForAnthropic(constraints);\n    if (originalDescription && constraintHints) {\n      return `${originalDescription}. ${constraintHints}`;\n    } else if (constraintHints) {\n      return constraintHints;\n    }\n    return originalDescription || '';\n  }\n\n  private formatConstraintsForAnthropic(constraints: any): string {\n    const hints: string[] = [];\n    \n    // Only add hints for constraints that might benefit from clarification\n    if (constraints.additionalProperties === false) {\n      hints.push('Only use the specified properties');\n    }\n    if (constraints.format === 'date-time') {\n      hints.push('Use ISO 8601 date-time format');\n    }\n    if (constraints.pattern) {\n      hints.push(`Must match the pattern: ${constraints.pattern}`);\n    }\n    \n    return hints.join('. ');\n  }\n} ",
    "import { McpToolCompatibility, type ModelInfo } from '../index';\n\nexport class GoogleMcpCompatibility extends McpToolCompatibility {\n  constructor(modelInfo: ModelInfo) {\n    super(modelInfo);\n  }\n\n  shouldApply(): boolean {\n    // Google models support schema properties but often ignore constraints\n    // We need to embed constraints in descriptions for them to be respected\n    return this.modelInfo.provider === 'google';\n  }\n\n  protected getUnsupportedStringProperties(): string[] {\n    // Google models support these properties but often ignore them\n    // So we move them to descriptions instead\n    return ['minLength', 'maxLength', 'pattern', 'format'];\n  }\n\n  protected getUnsupportedNumberProperties(): string[] {\n    // Google models support these but often ignore the constraints\n    return ['minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum', 'multipleOf'];\n  }\n\n  protected getUnsupportedArrayProperties(): string[] {\n    // Google models ignore array length constraints\n    return ['minItems', 'maxItems', 'uniqueItems'];\n  }\n\n  protected getUnsupportedObjectProperties(): string[] {\n    // Google models ignore object-level constraints\n    return ['minProperties', 'maxProperties', 'additionalProperties'];\n  }\n\n  // Override to provide Google-optimized constraint descriptions\n  protected mergeDescription(originalDescription: string | undefined, constraints: any): string {\n    const constraintText = this.formatConstraintsForGoogle(constraints);\n    if (originalDescription && constraintText) {\n      return `${originalDescription}\\n\\nConstraints: ${constraintText}`;\n    } else if (constraintText) {\n      return `Constraints: ${constraintText}`;\n    }\n    return originalDescription || '';\n  }\n\n  private formatConstraintsForGoogle(constraints: any): string {\n    const rules: string[] = [];\n    \n    // Format constraints in a way that Google models understand better\n    if (constraints.minLength) {\n      rules.push(`text must be at least ${constraints.minLength} characters long`);\n    }\n    if (constraints.maxLength) {\n      rules.push(`text must be no more than ${constraints.maxLength} characters long`);\n    }\n    if (constraints.minimum !== undefined) {\n      rules.push(`number must be at least ${constraints.minimum}`);\n    }\n    if (constraints.maximum !== undefined) {\n      rules.push(`number must be no more than ${constraints.maximum}`);\n    }\n    if (constraints.exclusiveMinimum !== undefined) {\n      rules.push(`number must be greater than ${constraints.exclusiveMinimum}`);\n    }\n    if (constraints.exclusiveMaximum !== undefined) {\n      rules.push(`number must be less than ${constraints.exclusiveMaximum}`);\n    }\n    if (constraints.multipleOf) {\n      rules.push(`number must be a multiple of ${constraints.multipleOf}`);\n    }\n    if (constraints.format === 'email') {\n      rules.push(`must be a valid email address`);\n    }\n    if (constraints.format === 'uri' || constraints.format === 'url') {\n      rules.push(`must be a valid URL starting with http:// or https://`);\n    }\n    if (constraints.format === 'uuid') {\n      rules.push(`must be a valid UUID in the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`);\n    }\n    if (constraints.format === 'date-time') {\n      rules.push(`must be a valid ISO 8601 date-time (e.g., 2023-12-25T10:30:00Z)`);\n    }\n    if (constraints.pattern) {\n      rules.push(`must match the regular expression pattern: ${constraints.pattern}`);\n    }\n    if (constraints.enum && Array.isArray(constraints.enum)) {\n      rules.push(`must be exactly one of these values: ${constraints.enum.join(', ')}`);\n    }\n    if (constraints.minItems) {\n      rules.push(`array must contain at least ${constraints.minItems} items`);\n    }\n    if (constraints.maxItems) {\n      rules.push(`array must contain no more than ${constraints.maxItems} items`);\n    }\n    if (constraints.uniqueItems === true) {\n      rules.push(`array items must all be unique (no duplicates)`);\n    }\n    if (constraints.minProperties) {\n      rules.push(`object must have at least ${constraints.minProperties} properties`);\n    }\n    if (constraints.maxProperties) {\n      rules.push(`object must have no more than ${constraints.maxProperties} properties`);\n    }\n    if (constraints.additionalProperties === false) {\n      rules.push(`object must only contain the specified properties, no additional properties allowed`);\n    }\n    \n    return rules.join('; ');\n  }\n} ",
    "import type { JSONSchema7 } from 'json-schema';\n\n// Constraint types for embedding in descriptions\nexport interface StringConstraints {\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n  format?: string;\n  enum?: string[];\n}\n\nexport interface NumberConstraints {\n  minimum?: number;\n  maximum?: number;\n  exclusiveMinimum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n}\n\nexport interface ArrayConstraints {\n  minItems?: number;\n  maxItems?: number;\n  uniqueItems?: boolean;\n}\n\nexport interface ObjectConstraints {\n  minProperties?: number;\n  maxProperties?: number;\n  additionalProperties?: boolean;\n}\n\nexport type SchemaConstraints = StringConstraints | NumberConstraints | ArrayConstraints | ObjectConstraints;\n\n// Model provider detection\nexport type ModelProvider = 'openai' | 'anthropic' | 'google' | 'openrouter' | 'unknown';\n\nexport interface ModelInfo {\n  provider: ModelProvider;\n  modelId: string;\n  supportsStructuredOutputs?: boolean;\n  isReasoningModel?: boolean;\n}\n\n// Abstract base class for tool compatibility\nexport abstract class McpToolCompatibility {\n  protected modelInfo: ModelInfo;\n\n  constructor(modelInfo: ModelInfo) {\n    this.modelInfo = modelInfo;\n  }\n\n  // Determine if this compatibility layer should be applied\n  abstract shouldApply(): boolean;\n\n  // Transform a complete tool schema\n  public transformToolSchema(toolSchema: JSONSchema7): JSONSchema7 {\n    if (!this.shouldApply()) {\n      return toolSchema;\n    }\n\n    return this.processSchema(toolSchema);\n  }\n\n  // Process any JSON schema recursively\n  protected processSchema(schema: JSONSchema7): JSONSchema7 {\n    const processed = { ...schema };\n\n    // Handle different schema types\n    switch (processed.type) {\n      case 'string':\n        return this.processStringSchema(processed);\n      case 'number':\n      case 'integer':\n        return this.processNumberSchema(processed);\n      case 'array':\n        return this.processArraySchema(processed);\n      case 'object':\n        return this.processObjectSchema(processed);\n      default:\n        return this.processGenericSchema(processed);\n    }\n  }\n\n  // String schema processing\n  protected processStringSchema(schema: JSONSchema7): JSONSchema7 {\n    const constraints: StringConstraints = {};\n    const processed = { ...schema };\n\n    // Extract constraints that might not be supported\n    if (typeof schema.minLength === 'number') {\n      constraints.minLength = schema.minLength;\n    }\n    if (typeof schema.maxLength === 'number') {\n      constraints.maxLength = schema.maxLength;\n    }\n    if (typeof schema.pattern === 'string') {\n      constraints.pattern = schema.pattern;\n    }\n    if (typeof schema.format === 'string') {\n      constraints.format = schema.format;\n    }\n    if (Array.isArray(schema.enum)) {\n      constraints.enum = schema.enum as string[];\n    }\n\n    // Remove unsupported properties and embed in description\n    const unsupportedProps = this.getUnsupportedStringProperties();\n    for (const prop of unsupportedProps) {\n      if (prop in processed) {\n        delete (processed as any)[prop];\n      }\n    }\n\n    // Embed constraints in description if any were found\n    if (Object.keys(constraints).length > 0) {\n      processed.description = this.mergeDescription(schema.description, constraints);\n    }\n\n    return processed;\n  }\n\n  // Number schema processing\n  protected processNumberSchema(schema: JSONSchema7): JSONSchema7 {\n    const constraints: NumberConstraints = {};\n    const processed = { ...schema };\n\n    // Extract numerical constraints\n    if (typeof schema.minimum === 'number') {\n      constraints.minimum = schema.minimum;\n    }\n    if (typeof schema.maximum === 'number') {\n      constraints.maximum = schema.maximum;\n    }\n    if (typeof schema.exclusiveMinimum === 'number') {\n      constraints.exclusiveMinimum = schema.exclusiveMinimum;\n    }\n    if (typeof schema.exclusiveMaximum === 'number') {\n      constraints.exclusiveMaximum = schema.exclusiveMaximum;\n    }\n    if (typeof schema.multipleOf === 'number') {\n      constraints.multipleOf = schema.multipleOf;\n    }\n\n    // Remove unsupported properties\n    const unsupportedProps = this.getUnsupportedNumberProperties();\n    for (const prop of unsupportedProps) {\n      if (prop in processed) {\n        delete (processed as any)[prop];\n      }\n    }\n\n    // Embed constraints in description\n    if (Object.keys(constraints).length > 0) {\n      processed.description = this.mergeDescription(schema.description, constraints);\n    }\n\n    return processed;\n  }\n\n  // Array schema processing\n  protected processArraySchema(schema: JSONSchema7): JSONSchema7 {\n    const constraints: ArrayConstraints = {};\n    const processed = { ...schema };\n\n    // Extract array constraints\n    if (typeof schema.minItems === 'number') {\n      constraints.minItems = schema.minItems;\n    }\n    if (typeof schema.maxItems === 'number') {\n      constraints.maxItems = schema.maxItems;\n    }\n    if (typeof schema.uniqueItems === 'boolean') {\n      constraints.uniqueItems = schema.uniqueItems;\n    }\n\n    // Process items schema recursively\n    if (schema.items && typeof schema.items === 'object' && !Array.isArray(schema.items)) {\n      processed.items = this.processSchema(schema.items as JSONSchema7);\n    }\n\n    // Remove unsupported properties\n    const unsupportedProps = this.getUnsupportedArrayProperties();\n    for (const prop of unsupportedProps) {\n      if (prop in processed) {\n        delete (processed as any)[prop];\n      }\n    }\n\n    // Embed constraints in description\n    if (Object.keys(constraints).length > 0) {\n      processed.description = this.mergeDescription(schema.description, constraints);\n    }\n\n    return processed;\n  }\n\n  // Object schema processing\n  protected processObjectSchema(schema: JSONSchema7): JSONSchema7 {\n    const constraints: ObjectConstraints = {};\n    const processed = { ...schema };\n\n    // Extract object constraints\n    if (typeof schema.minProperties === 'number') {\n      constraints.minProperties = schema.minProperties;\n    }\n    if (typeof schema.maxProperties === 'number') {\n      constraints.maxProperties = schema.maxProperties;\n    }\n    if (typeof schema.additionalProperties === 'boolean') {\n      constraints.additionalProperties = schema.additionalProperties;\n    }\n\n    // Process properties recursively\n    if (schema.properties && typeof schema.properties === 'object') {\n      processed.properties = {};\n      for (const [key, prop] of Object.entries(schema.properties)) {\n        if (typeof prop === 'object' && !Array.isArray(prop)) {\n          processed.properties[key] = this.processSchema(prop as JSONSchema7);\n        } else {\n          processed.properties[key] = prop;\n        }\n      }\n    }\n\n    // Remove unsupported properties\n    const unsupportedProps = this.getUnsupportedObjectProperties();\n    for (const prop of unsupportedProps) {\n      if (prop in processed) {\n        delete (processed as any)[prop];\n      }\n    }\n\n    // Embed constraints in description\n    if (Object.keys(constraints).length > 0) {\n      processed.description = this.mergeDescription(schema.description, constraints);\n    }\n\n    return processed;\n  }\n\n  // Generic schema processing (for union types, etc.)\n  protected processGenericSchema(schema: JSONSchema7): JSONSchema7 {\n    const processed = { ...schema };\n\n    // Handle oneOf, anyOf, allOf recursively\n    if (Array.isArray(schema.oneOf)) {\n      processed.oneOf = schema.oneOf.map(s => typeof s === 'object' ? this.processSchema(s as JSONSchema7) : s);\n    }\n    if (Array.isArray(schema.anyOf)) {\n      processed.anyOf = schema.anyOf.map(s => typeof s === 'object' ? this.processSchema(s as JSONSchema7) : s);\n    }\n    if (Array.isArray(schema.allOf)) {\n      processed.allOf = schema.allOf.map(s => typeof s === 'object' ? this.processSchema(s as JSONSchema7) : s);\n    }\n\n    return processed;\n  }\n\n  // Merge constraints into description\n  protected mergeDescription(originalDescription: string | undefined, constraints: SchemaConstraints): string {\n    const constraintJson = JSON.stringify(constraints);\n    if (originalDescription) {\n      return `${originalDescription}\\n${constraintJson}`;\n    }\n    return constraintJson;\n  }\n\n  // Abstract methods that subclasses must implement\n  protected abstract getUnsupportedStringProperties(): string[];\n  protected abstract getUnsupportedNumberProperties(): string[];\n  protected abstract getUnsupportedArrayProperties(): string[];\n  protected abstract getUnsupportedObjectProperties(): string[];\n}\n\n// Model detection utilities\nexport function detectModelProvider(runtime: any): ModelInfo {\n  // Try to extract model info from ElizaOS runtime\n  const modelString = runtime?.modelProvider || runtime?.model || '';\n  const modelId = String(modelString).toLowerCase();\n\n  let provider: ModelProvider = 'unknown';\n  let supportsStructuredOutputs = false;\n  let isReasoningModel = false;\n\n  // Detect provider based on model string\n  if (modelId.includes('openai') || modelId.includes('gpt-') || modelId.includes('o1-') || modelId.includes('o3-')) {\n    provider = 'openai';\n    supportsStructuredOutputs = modelId.includes('gpt-4') || modelId.includes('o1') || modelId.includes('o3');\n    isReasoningModel = modelId.includes('o1') || modelId.includes('o3');\n  } else if (modelId.includes('anthropic') || modelId.includes('claude')) {\n    provider = 'anthropic';\n    supportsStructuredOutputs = true;\n  } else if (modelId.includes('google') || modelId.includes('gemini')) {\n    provider = 'google';\n    supportsStructuredOutputs = true;\n  } else if (modelId.includes('openrouter')) {\n    provider = 'openrouter';\n    // OpenRouter depends on the underlying model\n    supportsStructuredOutputs = false;\n  }\n\n  return {\n    provider,\n    modelId,\n    supportsStructuredOutputs,\n    isReasoningModel,\n  };\n}\n\n// Factory function to get the appropriate compatibility layer\nexport async function createMcpToolCompatibility(runtime: any): Promise<McpToolCompatibility | null> {\n  const modelInfo = detectModelProvider(runtime);\n  \n  // Import and instantiate the appropriate compatibility layer\n  try {\n    switch (modelInfo.provider) {\n      case 'openai':\n        // Use dynamic ES module imports\n        const { OpenAIMcpCompatibility } = await import('./providers/openai.js');\n        return new OpenAIMcpCompatibility(modelInfo);\n      case 'anthropic':\n        const { AnthropicMcpCompatibility } = await import('./providers/anthropic.js');\n        return new AnthropicMcpCompatibility(modelInfo);\n      case 'google':\n        const { GoogleMcpCompatibility } = await import('./providers/google.js');\n        return new GoogleMcpCompatibility(modelInfo);\n      default:\n        return null; // No compatibility layer needed\n    }\n  } catch (error) {\n    console.warn('Failed to load compatibility provider:', error);\n    return null;\n  }\n}\n\n// Synchronous version for environments that need it (like service.ts)\nexport function createMcpToolCompatibilitySync(runtime: any): McpToolCompatibility | null {\n  const modelInfo = detectModelProvider(runtime);\n  \n  // Use synchronous requires for CommonJS environments\n  try {\n    switch (modelInfo.provider) {\n      case 'openai':\n        // Use eval to avoid bundlers trying to process this\n        const OpenAIModule = eval('require')('./providers/openai');\n        const { OpenAIMcpCompatibility } = OpenAIModule;\n        return new OpenAIMcpCompatibility(modelInfo);\n      case 'anthropic':\n        const AnthropicModule = eval('require')('./providers/anthropic');\n        const { AnthropicMcpCompatibility } = AnthropicModule;\n        return new AnthropicMcpCompatibility(modelInfo);\n      case 'google':\n        const GoogleModule = eval('require')('./providers/google');\n        const { GoogleMcpCompatibility } = GoogleModule;\n        return new GoogleMcpCompatibility(modelInfo);\n      default:\n        return null; // No compatibility layer needed\n    }\n  } catch (error) {\n    console.warn('Failed to load compatibility provider:', error);\n    return null;\n  }\n} ",
    "import { type IAgentRuntime, type Plugin, logger } from \"@elizaos/core\";\nimport { callToolAction } from \"./actions/callToolAction\";\nimport { readResourceAction } from \"./actions/readResourceAction\";\nimport { provider } from \"./provider\";\nimport { McpService } from \"./service\";\n\n// Re-export all types for consumers\nexport * from \"./types\";\n\n// Re-export McpService class\nexport { McpService } from \"./service\";\n\n// Re-export tool compatibility utilities\nexport {\n  createMcpToolCompatibilitySync,\n  createMcpToolCompatibility,\n  detectModelProvider,\n  McpToolCompatibility,\n  type ModelInfo,\n  type ModelProvider,\n  type StringConstraints,\n  type NumberConstraints,\n  type ArrayConstraints,\n  type ObjectConstraints,\n  type SchemaConstraints,\n} from \"./tool-compatibility\";\n\nconst mcpPlugin: Plugin = {\n  name: \"mcp\",\n  description: \"Plugin for connecting to MCP (Model Context Protocol) servers\",\n\n  init: async (_config: Record<string, string>, _runtime: IAgentRuntime) => {\n    logger.info(\"Initializing MCP plugin...\");\n  },\n\n  services: [McpService],\n  actions: [callToolAction, readResourceAction],\n  providers: [provider],\n};\n\nexport default mcpPlugin;\n",
    "import {\n  type Action,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  type ActionResult,\n} from '@elizaos/core';\nimport type { McpService } from '../service';\nimport { MCP_SERVICE_NAME, type McpServer } from '../types';\nimport { handleMcpError } from '../utils/error';\nimport { handleToolResponse, processToolResult } from '../utils/processing';\nimport { createToolSelectionArgument, createToolSelectionName } from '../utils/selection';\nimport { handleNoToolAvailable } from '../utils/handler';\n\nexport const callToolAction: Action = {\n  name: 'CALL_MCP_TOOL',\n  similes: [\n    'CALL_TOOL',\n    'CALL_MCP_TOOL',\n    'USE_TOOL',\n    'USE_MCP_TOOL',\n    'EXECUTE_TOOL',\n    'EXECUTE_MCP_TOOL',\n    'RUN_TOOL',\n    'RUN_MCP_TOOL',\n    'INVOKE_TOOL',\n    'INVOKE_MCP_TOOL',\n  ],\n  description: 'Calls a tool from an MCP server to perform a specific task',\n\n  validate: async (runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<boolean> => {\n    const mcpService = runtime.getService<McpService>(MCP_SERVICE_NAME);\n    if (!mcpService) return false;\n\n    const servers = mcpService.getServers();\n    return (\n      servers.length > 0 &&\n      servers.some(\n        (server: McpServer) => server.status === 'connected' && server.tools && server.tools.length > 0\n      )\n    );\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state?: State,\n    _options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<ActionResult> => {\n    const composedState = await runtime.composeState(message, ['RECENT_MESSAGES', 'MCP']);\n    const mcpService = runtime.getService<McpService>(MCP_SERVICE_NAME);\n    if (!mcpService) {\n      throw new Error('MCP service not available');\n    }\n    const mcpProvider = mcpService.getProviderData();\n\n    try {\n      // Select the tool with this servername and toolname\n      const toolSelectionName = await createToolSelectionName({\n        runtime,\n        state: composedState,\n        message,\n        callback,\n        mcpProvider,\n      });\n      if (!toolSelectionName || toolSelectionName.noToolAvailable) {\n        logger.warn('[NO_TOOL_AVAILABLE] No appropriate tool available for the request');\n        return await handleNoToolAvailable(callback, toolSelectionName);\n      }\n      const { serverName, toolName, reasoning } = toolSelectionName;\n      logger.info(\n        `[CALLING] Calling tool \"${serverName}/${toolName}\" on server with reasoning: \"${reasoning}\"`\n      );\n\n      // Create the tool selection \"argument\" based on the selected tool name\n      const toolSelectionArgument = await createToolSelectionArgument({\n        runtime,\n        state: composedState,\n        message,\n        callback,\n        mcpProvider,\n        toolSelectionName,\n      });\n      if (!toolSelectionArgument) {\n        logger.warn(\n          '[NO_TOOL_SELECTION_ARGUMENT] No appropriate tool selection argument available'\n        );\n        return await handleNoToolAvailable(callback, toolSelectionName);\n      }\n      logger.info(\n        `[SELECTED] Tool Selection result:\\n${JSON.stringify(toolSelectionArgument, null, 2)}`\n      );\n\n      const result = await mcpService.callTool(\n        serverName,\n        toolName,\n        toolSelectionArgument.toolArguments\n      );\n\n      const { toolOutput, hasAttachments, attachments } = processToolResult(\n        result,\n        serverName,\n        toolName,\n        runtime,\n        message.entityId\n      );\n\n      const replyMemory = await handleToolResponse(\n        runtime,\n        message,\n        serverName,\n        toolName,\n        toolSelectionArgument.toolArguments,\n        toolOutput,\n        hasAttachments,\n        attachments,\n        composedState,\n        mcpProvider,\n        callback\n      );\n\n      return {\n        text: `Successfully called tool: ${serverName}/${toolName}. Reasoned response: ${replyMemory.content.text}`,\n        values: {\n          success: true,\n          toolExecuted: true,\n          serverName,\n          toolName,\n          hasAttachments,\n          output: toolOutput,\n        },\n        data: {\n          actionName: 'CALL_MCP_TOOL',\n          serverName,\n          toolName,\n          toolArguments: toolSelectionArgument.toolArguments,\n          reasoning: toolSelectionName.reasoning,\n          output: toolOutput,\n          attachments: attachments || [],\n        },\n        success: true,\n      };\n    } catch (error) {\n      return await handleMcpError(\n        composedState,\n        mcpProvider,\n        error,\n        runtime,\n        message,\n        'tool',\n        callback\n      );\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: '{{user}}',\n        content: {\n          text: 'Can you search for information about climate change?',\n        },\n      },\n      {\n        name: '{{assistant}}',\n        content: {\n          text: \"I'll help you with that request. Let me access the right tool...\",\n          actions: ['CALL_MCP_TOOL'],\n        },\n      },\n      {\n        name: '{{assistant}}',\n        content: {\n          text: 'I found the following information about climate change:\\n\\nClimate change refers to long-term shifts in temperatures and weather patterns. These shifts may be natural, but since the 1800s, human activities have been the main driver of climate change, primarily due to the burning of fossil fuels like coal, oil, and gas, which produces heat-trapping gases.',\n          actions: ['CALL_MCP_TOOL'],\n        },\n      },\n    ],\n  ],\n};\n",
    "import type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport type {\n  EmbeddedResource,\n  ImageContent,\n  Resource,\n  ResourceTemplate,\n  TextContent,\n  Tool,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nexport const MCP_SERVICE_NAME = \"mcp\";\nexport const DEFAULT_MCP_TIMEOUT_SECONDS = 60000;\nexport const MIN_MCP_TIMEOUT_SECONDS = 1;\nexport const DEFAULT_MAX_RETRIES = 2;\n\nexport interface PingConfig {\n  enabled: boolean;\n  intervalMs: number;\n  timeoutMs: number;\n  failuresBeforeDisconnect: number;\n}\n\nexport interface ConnectionState {\n  status: \"connecting\" | \"connected\" | \"disconnected\" | \"failed\";\n  pingInterval?: NodeJS.Timer;\n  reconnectTimeout?: NodeJS.Timer;\n  reconnectAttempts: number;\n  lastConnected?: Date;\n  lastError?: Error;\n  consecutivePingFailures: number;\n}\n\nexport type StdioMcpServerConfig = {\n  type: \"stdio\";\n  command?: string;\n  args?: string[];\n  env?: Record<string, string>;\n  cwd?: string;\n  timeoutInMillis?: number;\n};\n\nexport type HttpMcpServerConfig = {\n  type: \"http\" | \"streamable-http\" | \"sse\"; // Support modern and legacy naming\n  url: string;\n  timeout?: number;\n};\n\nexport type McpServerConfig = StdioMcpServerConfig | HttpMcpServerConfig;\n\nexport type McpSettings = {\n  servers: Record<string, McpServerConfig>;\n  maxRetries?: number;\n};\n\nexport type McpServerStatus = \"connecting\" | \"connected\" | \"disconnected\";\n\nexport interface McpServer {\n  name: string;\n  status: McpServerStatus;\n  config: string;\n  error?: string;\n  disabled?: boolean;\n  tools?: Tool[];\n  resources?: Resource[];\n  resourceTemplates?: ResourceTemplate[];\n}\n\nexport interface McpConnection {\n  server: McpServer;\n  client: Client;\n  transport: StdioClientTransport | SSEClientTransport;\n}\n\nexport interface McpToolResult {\n  content: Array<TextContent | ImageContent | EmbeddedResource>;\n  isError?: boolean;\n}\n\nexport interface McpToolCallResponse {\n  content: Array<TextContent | ImageContent | EmbeddedResource>;\n  isError?: boolean;\n}\n\nexport interface McpResourceResponse {\n  contents: Array<{\n    uri: string;\n    mimeType?: string;\n    text?: string;\n    blob?: string;\n  }>;\n}\n\nexport interface McpToolInfo {\n  description: string;\n  inputSchema?: {\n    properties?: Record<string, unknown>;\n    required?: string[];\n    [key: string]: unknown;\n  };\n}\n\nexport interface McpResourceInfo {\n  name: string;\n  description: string;\n  mimeType?: string;\n}\n\nexport interface McpServerInfo {\n  status: string;\n  tools: Record<string, McpToolInfo>;\n  resources: Record<string, McpResourceInfo>;\n}\n\nexport type McpProvider = {\n  values: { mcp: McpProviderData, mcpText?: string };\n  data: { mcp: McpProviderData };\n  text: string;\n};\n\nexport interface McpProviderData {\n  [serverName: string]: McpServerInfo;\n}\n\nexport const ToolSelectionSchema = {\n  type: \"object\",\n  required: [\"serverName\", \"toolName\", \"arguments\"],\n  properties: {\n    serverName: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"serverName must not be empty\",\n    },\n    toolName: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"toolName must not be empty\",\n    },\n    arguments: {\n      type: \"object\",\n    },\n    reasoning: {\n      type: \"string\",\n    },\n    noToolAvailable: {\n      type: \"boolean\",\n    },\n  },\n};\n\nexport const ResourceSelectionSchema = {\n  type: \"object\",\n  required: [\"serverName\", \"uri\"],\n  properties: {\n    serverName: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"serverName must not be empty\",\n    },\n    uri: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"uri must not be empty\",\n    },\n    reasoning: {\n      type: \"string\",\n    },\n    noResourceAvailable: {\n      type: \"boolean\",\n    },\n  },\n};\n\nexport const DEFAULT_PING_CONFIG: PingConfig = {\n  enabled: true,\n  intervalMs: 10000, // 10 seconds\n  timeoutMs: 5000, // 5 seconds\n  failuresBeforeDisconnect: 3,\n};\n\nexport const MAX_RECONNECT_ATTEMPTS = 5;\nexport const BACKOFF_MULTIPLIER = 2;\nexport const INITIAL_RETRY_DELAY = 2000; // 2 seconds\n\ninterface SuccessResult<T> {\n  success: true;\n  data: T;\n}\n\ninterface ErrorResult {\n  success: false;\n  error: string;\n}\n\nexport type ValidationResult<T> = SuccessResult<T> | ErrorResult;\n",
    "import {\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  composePromptFromState,\n  logger,\n  type ActionResult,\n} from '@elizaos/core';\nimport type { State } from '@elizaos/core';\nimport { errorAnalysisPrompt } from '../templates/errorAnalysisPrompt';\nimport type { McpProvider } from '../types';\n\nexport async function handleMcpError(\n  state: State,\n  mcpProvider: McpProvider,\n  error: unknown,\n  runtime: IAgentRuntime,\n  message: Memory,\n  type: 'tool' | 'resource',\n  callback?: HandlerCallback\n): Promise<ActionResult> {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n\n  logger.error({ error, mcpType: type }, `Error executing MCP ${type}: ${errorMessage}`);\n\n  let responseText = `I'm sorry, I wasn't able to get the information you requested. There seems to be an issue with the ${type} right now. Is there something else I can help you with?`;\n  let thoughtText = `Error calling MCP ${type} and failed to generate a custom response. Providing a generic fallback response.`;\n\n  if (callback) {\n    const enhancedState: State = {\n      ...state,\n      values: {\n        ...state.values,\n        mcpProvider,\n        userMessage: message.content.text || '',\n        error: errorMessage,\n      },\n    };\n\n    const prompt = composePromptFromState({\n      state: enhancedState,\n      template: errorAnalysisPrompt,\n    });\n\n    try {\n      const errorResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n\n      responseText = errorResponse;\n      thoughtText = `Error calling MCP ${type}: ${errorMessage}. Providing a helpful response to the user.`;\n\n      await callback({\n        thought: thoughtText,\n        text: responseText,\n        actions: ['REPLY'],\n      });\n    } catch (modelError) {\n      logger.error(\n        { error: modelError instanceof Error ? modelError.message : String(modelError) },\n        'Failed to generate error response'\n      );\n\n      await callback({\n        thought: thoughtText,\n        text: responseText,\n        actions: ['REPLY'],\n      });\n    }\n  }\n\n  return {\n    text: `Failed to execute MCP ${type}`,\n    values: {\n      success: false,\n      error: errorMessage,\n      errorType: type,\n    },\n    data: {\n      actionName: type === 'tool' ? 'CALL_MCP_TOOL' : 'READ_MCP_RESOURCE',\n      error: errorMessage,\n      mcpType: type,\n    },\n    success: false,\n    error: error instanceof Error ? error : new Error(errorMessage),\n  };\n}\n\nexport class McpError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string = 'UNKNOWN'\n  ) {\n    super(message);\n    this.name = 'McpError';\n  }\n\n  static connectionError(serverName: string, details?: string): McpError {\n    return new McpError(\n      `Failed to connect to server '${serverName}'${details ? `: ${details}` : ''}`,\n      'CONNECTION_ERROR'\n    );\n  }\n\n  static toolNotFound(toolName: string, serverName: string): McpError {\n    return new McpError(`Tool '${toolName}' not found on server '${serverName}'`, 'TOOL_NOT_FOUND');\n  }\n\n  static resourceNotFound(uri: string, serverName: string): McpError {\n    return new McpError(\n      `Resource '${uri}' not found on server '${serverName}'`,\n      'RESOURCE_NOT_FOUND'\n    );\n  }\n\n  static validationError(details: string): McpError {\n    return new McpError(`Validation error: ${details}`, 'VALIDATION_ERROR');\n  }\n\n  static serverError(serverName: string, details?: string): McpError {\n    return new McpError(\n      `Server error from '${serverName}'${details ? `: ${details}` : ''}`,\n      'SERVER_ERROR'\n    );\n  }\n}\n",
    "export const errorAnalysisPrompt = `\n{{{mcpProvider.text}}}\n\n{{{recentMessages}}}\n\n# Prompt\n\nYou're an assistant helping a user, but there was an error accessing the resource you tried to use.\n\nUser request: \"{{{userMessage}}}\"\nError message: {{{error}}}\n\nCreate a helpful response that:\n1. Acknowledges the issue in user-friendly terms\n2. Offers alternative approaches to help if possible\n3. Doesn't expose technical error details unless they're truly helpful\n4. Maintains a helpful, conversational tone\n\nYour response:\n`;\n",
    "import {\n  type Content,\n  ContentType,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Media,\n  type Memory,\n  ModelType,\n  createUniqueUuid,\n  logger,\n} from '@elizaos/core';\nimport { type State, composePromptFromState } from '@elizaos/core';\nimport { resourceAnalysisTemplate } from '../templates/resourceAnalysisTemplate';\nimport { toolReasoningTemplate } from '../templates/toolReasoningTemplate';\nimport { createMcpMemory } from './mcp';\n\nfunction getMimeTypeToContentType(mimeType?: string): ContentType | undefined {\n  if (!mimeType) return undefined;\n\n  if (mimeType.startsWith('image/')) return ContentType.IMAGE;\n  if (mimeType.startsWith('video/')) return ContentType.VIDEO;\n  if (mimeType.startsWith('audio/')) return ContentType.AUDIO;\n  if (mimeType.includes('pdf') || mimeType.includes('document')) return ContentType.DOCUMENT;\n\n  return undefined;\n}\n\nexport function processResourceResult(\n  result: {\n    contents: Array<{\n      uri: string;\n      mimeType?: string;\n      text?: string;\n      blob?: string;\n    }>;\n  },\n  uri: string\n): { resourceContent: string; resourceMeta: string } {\n  let resourceContent = '';\n  let resourceMeta = '';\n\n  for (const content of result.contents) {\n    if (content.text) {\n      resourceContent += content.text;\n    } else if (content.blob) {\n      resourceContent += `[Binary data - ${content.mimeType || 'unknown type'}]`;\n    }\n\n    resourceMeta += `Resource: ${content.uri || uri}\\n`;\n    if (content.mimeType) {\n      resourceMeta += `Type: ${content.mimeType}\\n`;\n    }\n  }\n\n  return { resourceContent, resourceMeta };\n}\n\nexport function processToolResult(\n  result: {\n    content: Array<{\n      type: string;\n      text?: string;\n      mimeType?: string;\n      data?: string;\n      resource?: {\n        uri: string;\n        text?: string;\n        blob?: string;\n      };\n    }>;\n    isError?: boolean;\n  },\n  serverName: string,\n  toolName: string,\n  runtime: IAgentRuntime,\n  messageEntityId: string\n): { toolOutput: string; hasAttachments: boolean; attachments: Media[] } {\n  let toolOutput = '';\n  let hasAttachments = false;\n  const attachments: Media[] = [];\n\n  for (const content of result.content) {\n    if (content.type === 'text') {\n      toolOutput += content.text;\n    } else if (content.type === 'image') {\n      hasAttachments = true;\n      attachments.push({\n        contentType: getMimeTypeToContentType(content.mimeType),\n        url: `data:${content.mimeType};base64,${content.data}`,\n        id: createUniqueUuid(runtime, messageEntityId),\n        title: 'Generated image',\n        source: `${serverName}/${toolName}`,\n        description: 'Tool-generated image',\n        text: 'Generated image',\n      });\n    } else if (content.type === 'resource') {\n      const resource = content.resource;\n      if (resource && 'text' in resource) {\n        toolOutput += `\\n\\nResource (${resource.uri}):\\n${resource.text}`;\n      } else if (resource && 'blob' in resource) {\n        toolOutput += `\\n\\nResource (${resource.uri}): [Binary data]`;\n      }\n    }\n  }\n\n  return { toolOutput, hasAttachments, attachments };\n}\n\nexport async function handleResourceAnalysis(\n  runtime: IAgentRuntime,\n  message: Memory,\n  uri: string,\n  serverName: string,\n  resourceContent: string,\n  resourceMeta: string,\n  callback?: HandlerCallback\n): Promise<void> {\n  await createMcpMemory(runtime, message, 'resource', serverName, resourceContent, {\n    uri,\n    isResourceAccess: true,\n  });\n\n  const analysisPrompt = createAnalysisPrompt(\n    uri,\n    message.content.text || '',\n    resourceContent,\n    resourceMeta\n  );\n\n  const analyzedResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n    prompt: analysisPrompt,\n  });\n\n  if (callback) {\n    await callback({\n      text: analyzedResponse,\n      thought: `I analyzed the content from the ${uri} resource on ${serverName} and crafted a thoughtful response that addresses the user's request while maintaining my conversational style.`,\n      actions: ['READ_MCP_RESOURCE'],\n    });\n  }\n}\n\nexport async function handleToolResponse(\n  runtime: IAgentRuntime,\n  message: Memory,\n  serverName: string,\n  toolName: string,\n  toolArgs: Record<string, unknown>,\n  toolOutput: string,\n  hasAttachments: boolean,\n  attachments: Media[],\n  state: State,\n  mcpProvider: {\n    values: { mcp: unknown };\n    data: { mcp: unknown };\n    text: string;\n  },\n  callback?: HandlerCallback\n): Promise<Memory> {\n  await createMcpMemory(runtime, message, 'tool', serverName, toolOutput, {\n    toolName,\n    arguments: toolArgs,\n    isToolCall: true,\n  });\n\n  const reasoningPrompt = createReasoningPrompt(\n    state,\n    mcpProvider,\n    toolName,\n    serverName,\n    message.content.text || '',\n    toolOutput,\n    hasAttachments\n  );\n\n  logger.info({ reasoningPrompt }, 'reasoning prompt');\n\n  const reasonedResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n    prompt: reasoningPrompt,\n  });\n\n  const agentId = message.agentId || runtime.agentId;\n  const replyMemory: Memory = {\n    entityId: agentId,\n    roomId: message.roomId,\n    worldId: message.worldId,\n    content: {\n      text: reasonedResponse,\n      thought: `I analyzed the output from the ${toolName} tool on ${serverName} and crafted a thoughtful response that addresses the user's request while maintaining my conversational style.`,\n      actions: ['CALL_MCP_TOOL'],\n      attachments: hasAttachments && attachments.length > 0 ? attachments : undefined,\n    },\n  };\n\n  await runtime.createMemory(replyMemory, 'messages');\n\n  if (callback) {\n    await callback({\n      text: reasonedResponse,\n      thought: `I analyzed the output from the ${toolName} tool on ${serverName} and crafted a thoughtful response that addresses the user's request while maintaining my conversational style.`,\n      actions: ['CALL_MCP_TOOL'],\n      attachments: hasAttachments && attachments.length > 0 ? attachments : undefined,\n    });\n  }\n\n  return replyMemory;\n}\n\nexport async function sendInitialResponse(callback?: HandlerCallback): Promise<void> {\n  if (callback) {\n    const responseContent: Content = {\n      thought:\n        'The user is asking for information that can be found in an MCP resource. I will retrieve and analyze the appropriate resource.',\n      text: \"I'll retrieve that information for you. Let me access the resource...\",\n      actions: ['READ_MCP_RESOURCE'],\n    };\n    await callback(responseContent);\n  }\n}\n\nfunction createAnalysisPrompt(\n  uri: string,\n  userMessage: string,\n  resourceContent: string,\n  resourceMeta: string\n): string {\n  const enhancedState: State = {\n    data: {},\n    text: '',\n    values: {\n      uri,\n      userMessage,\n      resourceContent,\n      resourceMeta,\n    },\n  };\n\n  return composePromptFromState({\n    state: enhancedState,\n    template: resourceAnalysisTemplate,\n  });\n}\n\nfunction createReasoningPrompt(\n  state: State,\n  mcpProvider: {\n    values: { mcp: unknown };\n    data: { mcp: unknown };\n    text: string;\n  },\n  toolName: string,\n  serverName: string,\n  userMessage: string,\n  toolOutput: string,\n  hasAttachments: boolean\n): string {\n  const enhancedState: State = {\n    ...state,\n    values: {\n      ...state.values,\n      mcpProvider,\n      toolName,\n      serverName,\n      userMessage,\n      toolOutput,\n      hasAttachments,\n    },\n  };\n\n  return composePromptFromState({\n    state: enhancedState,\n    template: toolReasoningTemplate,\n  });\n}\n",
    "export const resourceAnalysisTemplate = `\n{{{mcpProvider.text}}}\n\n{{{recentMessages}}}\n\n# Prompt\n\nYou are a helpful assistant responding to a user's request. You've just accessed the resource \"{{{uri}}}\" to help answer this request.\n\nOriginal user request: \"{{{userMessage}}}\"\n\nResource metadata: \n{{{resourceMeta}}\n\nResource content: \n{{{resourceContent}}\n\nInstructions:\n1. Analyze how well the resource's content addresses the user's specific question or need\n2. Identify the most relevant information from the resource\n3. Create a natural, conversational response that incorporates this information\n4. If the resource content is insufficient, acknowledge its limitations and explain what you can determine\n5. Do not start with phrases like \"According to the resource\" or \"Here's what I found\" - instead, integrate the information naturally\n6. Maintain your helpful, intelligent assistant personality while presenting the information\n\nYour response (written as if directly to the user):\n`;\n",
    "export const toolReasoningTemplate = `\n{{{mcpProvider.text}}}\n\n{{{recentMessages}}}\n\n# Prompt\n\nYou are a helpful assistant responding to a user's request. You've just used the \"{{{toolName}}}\" tool from the \"{{{serverName}}}\" server to help answer this request.\n\nOriginal user request: \"{{{userMessage}}}\"\n\nTool response:\n{{{toolOutput}}}\n\n{{#if hasAttachments}}\nThe tool also returned images or other media that will be shared with the user.\n{{/if}}\n\nInstructions:\n1. Analyze how well the tool's response addresses the user's specific question or need\n2. Identify the most relevant information from the tool's output\n3. Create a natural, conversational response that incorporates this information\n4. If the tool's response is insufficient, acknowledge its limitations and explain what you can determine\n5. Do not start with phrases like \"I used the X tool\" or \"Here's what I found\" - instead, integrate the information naturally\n6. Maintain your helpful, intelligent assistant personality while presenting the information\n\nYour response (written as if directly to the user):\n`;\n",
    "import type { IAgentRuntime, Memory } from \"@elizaos/core\";\nimport type {\n  McpProvider,\n  McpProviderData,\n  McpResourceInfo,\n  McpServer,\n  McpToolInfo,\n} from \"../types\";\n\nexport async function createMcpMemory(\n  runtime: IAgentRuntime,\n  message: Memory,\n  type: string,\n  serverName: string,\n  content: string,\n  metadata: Record<string, unknown>\n): Promise<void> {\n  const memory = await runtime.addEmbeddingToMemory({\n    entityId: message.entityId,\n    agentId: runtime.agentId,\n    roomId: message.roomId,\n    content: {\n      text: `Used the \"${type}\" from \"${serverName}\" server. \n        Content: ${content}`,\n      metadata: {\n        ...metadata,\n        serverName,\n      },\n    },\n  });\n\n  await runtime.createMemory(memory, type === \"resource\" ? \"resources\" : \"tools\", true);\n}\n\nexport function buildMcpProviderData(servers: McpServer[]): McpProvider {\n  const mcpData: McpProviderData = {};\n  let textContent = \"\";\n\n  if (servers.length === 0) {\n    return {\n      values: { mcp: {} },\n      data: { mcp: {} },\n      text: \"No MCP servers are currently connected.\",\n    };\n  }\n\n  for (const server of servers) {\n    mcpData[server.name] = {\n      status: server.status,\n      tools: {} as Record<string, McpToolInfo>,\n      resources: {} as Record<string, McpResourceInfo>,\n    };\n\n    textContent += `## Server: ${server.name} (${server.status})\\n\\n`;\n\n    if (server.tools && server.tools.length > 0) {\n      textContent += \"### Tools:\\n\\n\";\n\n      for (const tool of server.tools) {\n        mcpData[server.name].tools[tool.name] = {\n          description: tool.description || \"No description available\",\n          inputSchema: tool.inputSchema || {},\n        };\n\n        textContent += `- **${tool.name}**: ${tool.description || \"No description available\"}\\n`;\n      }\n      textContent += \"\\n\";\n    }\n\n    if (server.resources && server.resources.length > 0) {\n      textContent += \"### Resources:\\n\\n\";\n\n      for (const resource of server.resources) {\n        mcpData[server.name].resources[resource.uri] = {\n          name: resource.name,\n          description: resource.description || \"No description available\",\n          mimeType: resource.mimeType,\n        };\n\n        textContent += `- **${resource.name}** (${resource.uri}): ${\n          resource.description || \"No description available\"\n        }\\n`;\n      }\n      textContent += \"\\n\";\n    }\n  }\n\n  return {\n    values: { mcp: mcpData, mcpText: `# MCP Configuration\\n\\n${textContent}` },\n    data: { mcp: mcpData },\n    text: `# MCP Configuration\\n\\n${textContent}`,\n  };\n}\n",
    "import {\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  logger,\n} from \"@elizaos/core\";\nimport { withModelRetry } from \"./wrapper\";\nimport type { McpProvider, McpProviderData } from \"../types\";\nimport type { ToolSelectionName, ToolSelectionArgument } from \"./schemas\";\nimport {\n  toolSelectionArgumentTemplate,\n  toolSelectionNameTemplate,\n} from \"../templates/toolSelectionTemplate\";\nimport { validateToolSelectionArgument, validateToolSelectionName } from \"./validation\";\n\nexport interface CreateToolSelectionOptions {\n  runtime: IAgentRuntime;\n  state: State;\n  message: Memory;\n  callback?: HandlerCallback;\n  mcpProvider: McpProvider;\n  toolSelectionName?: ToolSelectionName;\n}\n\n/**\n *  Creates a tool selection name based on the current state and MCP provider.\n * @returns A tool selection name object or null if the selection is invalid.\n * ```json\n * {\n *  \"serverName\": \"github\",\n *  \"toolName\": \"get_file_contents\",\n *  \"reasoning\": \"The user wants to see the README from the facebook/react repository based on our conversation.\"\n *  \"noToolSelection\": false\n * }\n * ```\n */\nexport async function createToolSelectionName({\n  runtime,\n  state,\n  message,\n  callback,\n  mcpProvider,\n}: CreateToolSelectionOptions): Promise<ToolSelectionName | null> {\n  const toolSelectionPrompt: string = composePromptFromState({\n    state: { ...state, values: { ...state.values, mcpProvider } },\n    template: toolSelectionNameTemplate,\n  });\n  logger.debug(`[SELECTION] Tool Selection Name Prompt:\\n${toolSelectionPrompt}`);\n\n  // Use the model to generate a tool selection stringified json response\n  const toolSelectionName: string = await runtime.useModel(ModelType.TEXT_LARGE, {\n    prompt: toolSelectionPrompt,\n  });\n  logger.debug(`[SELECTION] Tool Selection Name Response:\\n${toolSelectionName}`);\n\n  return await withModelRetry<ToolSelectionName>({\n    runtime,\n    message,\n    state,\n    callback,\n    input: toolSelectionName,\n    validationFn: (parsed) => validateToolSelectionName(parsed, state),\n    createFeedbackPromptFn: (originalResponse, errorMessage, state, userMessage) =>\n      createToolSelectionFeedbackPrompt(originalResponse, errorMessage, state, userMessage),\n    failureMsg: \"I'm having trouble figuring out the best way to help with your request.\",\n  });\n}\n/**\n * Creates a tool selection argument based on the current state and MCP provider.\n * @returns  A tool selection argument object or null if the selection is invalid.\n * ```json\n * {\n *  \"toolArguments\": {\n *    \"file_path\": \"facebook/react/README.md\",\n *    \"repo\": \"facebook/react\"\n *  },\n *  \"reasoning\": \"The user wants to see the README from the facebook/react repository based on our conversation.\"\n * }\n */\nexport async function createToolSelectionArgument({\n  runtime,\n  state,\n  message,\n  callback,\n  mcpProvider,\n  toolSelectionName,\n}: CreateToolSelectionOptions): Promise<ToolSelectionArgument | null> {\n  if (!toolSelectionName) {\n    logger.warn(\n      \"[SELECTION] Tool selection name is not provided. Cannot create tool selection argument.\"\n    );\n    return null;\n  }\n  const { serverName, toolName } = toolSelectionName;\n  const toolInputSchema = mcpProvider.data.mcp[serverName].tools[toolName].inputSchema;\n  logger.trace(`[SELECTION] Tool Input Schema:\\n${JSON.stringify({ toolInputSchema }, null, 2)}`);\n\n  // Create a tool selection argument prompt\n  const toolSelectionArgumentPrompt: string = composePromptFromState({\n    state: {\n      ...state,\n      values: {\n        ...state.values,\n        toolSelectionName,\n        toolInputSchema: JSON.stringify(toolInputSchema),\n      },\n    },\n    template: toolSelectionArgumentTemplate,\n  });\n  logger.debug(`[SELECTION] Tool Selection Prompt:\\n${toolSelectionArgumentPrompt}`);\n\n  // Use the model to generate a tool selection argument stringified json response\n  const toolSelectionArgument: string = await runtime.useModel(ModelType.TEXT_LARGE, {\n    prompt: toolSelectionArgumentPrompt,\n  });\n  logger.debug(`[SELECTION] Tool Selection Argument Response:\\n${toolSelectionArgument}`);\n\n  return await withModelRetry<ToolSelectionArgument>({\n    runtime,\n    message,\n    state,\n    callback,\n    input: toolSelectionArgument,\n    validationFn: (parsed) => validateToolSelectionArgument(parsed, state),\n    createFeedbackPromptFn: (originalResponse, errorMessage, state, userMessage) =>\n      createToolSelectionFeedbackPrompt(originalResponse, errorMessage, state, userMessage),\n    failureMsg: \"I'm having trouble figuring out the best way to help with your request.\",\n  });\n}\n\nfunction createToolSelectionFeedbackPrompt(\n  originalResponse: string | object,\n  errorMessage: string,\n  state: State,\n  userMessage: string\n): string {\n  let toolsDescription = \"\";\n\n  for (const [serverName, server] of Object.entries(state.values.mcp || {}) as [\n    string,\n    McpProviderData[string],\n  ][]) {\n    if (server.status !== \"connected\") continue;\n\n    for (const [toolName, tool] of Object.entries(server.tools || {})) {\n      toolsDescription += `Tool: ${toolName} (Server: ${serverName})\\n`;\n      toolsDescription += `Description: ${tool.description || \"No description available\"}\\n\\n`;\n    }\n  }\n\n  const feedbackPrompt = createFeedbackPrompt(\n    originalResponse,\n    errorMessage,\n    \"tool\",\n    toolsDescription,\n    userMessage\n  );\n  logger.debug(`[SELECTION] Tool Selection Feedback Prompt:\\n${feedbackPrompt}`);\n  return feedbackPrompt;\n}\n\nfunction createFeedbackPrompt(\n  originalResponse: string | object,\n  errorMessage: string,\n  itemType: string,\n  itemsDescription: string,\n  userMessage: string\n): string {\n  return `Error parsing JSON: ${errorMessage}\n  \n  Your original response:\n  ${originalResponse}\n  \n  Please try again with valid JSON for ${itemType} selection.\n  Available ${itemType}s:\n  ${itemsDescription}\n  \n  User request: ${userMessage}`;\n}\n",
    "import Ajv from \"ajv\";\nimport JSON5 from \"json5\";\n\nexport function parseJSON<T>(input: string): T {\n  // Remove code blocks\n  let cleanedInput = input.replace(/^```(?:json)?\\s*|\\s*```$/g, \"\").trim();\n  \n  // Find JSON object boundaries - look for first { and last }\n  const firstBrace = cleanedInput.indexOf('{');\n  const lastBrace = cleanedInput.lastIndexOf('}');\n  \n  if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n    // Extract only the JSON part between { and }\n    cleanedInput = cleanedInput.substring(firstBrace, lastBrace + 1);\n  }\n  \n  return JSON5.parse(cleanedInput);\n}\n\nconst ajv = new Ajv({\n  allErrors: true,\n  strict: false,\n});\n\nexport function validateJsonSchema<T = unknown>(\n  data: unknown,\n  schema: Record<string, unknown>\n): { success: true; data: T } | { success: false; error: string } {\n  try {\n    const validate = ajv.compile(schema);\n    const valid = validate(data);\n\n    if (!valid) {\n      const errors = (validate.errors || []).map((err: any) => {\n        const path = err.instancePath ? `${err.instancePath.replace(/^\\//, \"\")}` : \"value\";\n        return `${path}: ${err.message}`;\n      });\n\n      return { success: false, error: errors.join(\", \") };\n    }\n\n    return { success: true, data: data as T };\n  } catch (error) {\n    return {\n      success: false,\n      error: `Schema validation error: ${error instanceof Error ? error.message : String(error)}`,\n    };\n  }\n}\n",
    "import { parseJSON } from './json';\n\nimport {\n  type HandlerCallback,\n  type Memory,\n  type IAgentRuntime,\n  type State,\n  logger,\n  ModelType,\n} from '@elizaos/core';\nimport { DEFAULT_MAX_RETRIES, type ValidationResult } from '../types';\n\nexport type Input = string | object;\n\ntype CreateFeedbackPromptFnOptions = (\n  originalResponse: Input,\n  errorMessage: string,\n  composedState: State,\n  userMessage: string\n) => string;\n\nexport interface WithModelRetryOptions<T> {\n  runtime: IAgentRuntime;\n  message: Memory;\n  state: State;\n  input: Input;\n  validationFn: (data: Input) => ValidationResult<T>;\n  createFeedbackPromptFn: CreateFeedbackPromptFnOptions;\n  callback?: HandlerCallback;\n  failureMsg?: string;\n  retryCount?: number;\n}\n\n/**\n * Retries the model selection process in case of parsing errors.\n * @param input - The initial input to be parsed\n * @param validationFn - The function to validate the parsed data\n * @param createFeedbackPromptFn - The function to create a feedback prompt\n * @param failureMsg - The message to be sent in case of failure\n * @param retryCount - The current retry count\n * @returns\n */\nexport async function withModelRetry<T>({\n  runtime,\n  message,\n  state,\n  callback,\n  input,\n  validationFn,\n  createFeedbackPromptFn,\n  failureMsg,\n  retryCount = 0,\n}: WithModelRetryOptions<T>): Promise<T | null> {\n  const maxRetries = getMaxRetries(runtime);\n\n  try {\n    logger.info(`[WITH-MODEL-RETRY] Raw selection input:\\n${input}`);\n\n    // If it's a first retry, input is a string, so we need to parse it\n    const parsedJson = typeof input === 'string' ? parseJSON<string>(input) : input;\n    logger.debug(\n      `[WITH-MODEL-RETRY] Parsed selection input:\\n${JSON.stringify(parsedJson, null, 2)}`\n    );\n\n    const validationResult = validationFn(parsedJson);\n\n    if (validationResult.success === false) {\n      throw new Error(validationResult.error);\n    }\n\n    return validationResult.data as T;\n  } catch (parseError) {\n    const errorMessage = parseError instanceof Error ? parseError.message : 'Unknown parsing error';\n\n    logger.error({ errorMessage }, `[WITH-MODEL-RETRY] Failed to parse response: ${errorMessage}`);\n\n    if (retryCount < maxRetries) {\n      logger.debug(`[WITH-MODEL-RETRY] Retrying (attempt ${retryCount + 1}/${maxRetries})`);\n\n      const feedbackPrompt: string = createFeedbackPromptFn(\n        input,\n        errorMessage,\n        state,\n        message.content.text || ''\n      );\n\n      const retrySelection: object = await runtime.useModel(ModelType.OBJECT_LARGE, {\n        prompt: feedbackPrompt,\n      });\n\n      return withModelRetry({\n        runtime,\n        input: retrySelection,\n        validationFn,\n        message,\n        state,\n        createFeedbackPromptFn,\n        callback,\n        failureMsg,\n        retryCount: retryCount + 1,\n      });\n    }\n\n    if (callback && failureMsg) {\n      await callback({\n        text: failureMsg,\n        thought:\n          'Failed to parse response after multiple retries. Requesting clarification from user.',\n        actions: ['REPLY'],\n      });\n    }\n    return null;\n  }\n}\n\n/**\n * Retrieves the maximum number of retries for MCP selection from the agent runtime settings.\n * @param runtime - The agent runtime\n * @returns The maximum number of retries for MCP selection\n */\nfunction getMaxRetries(runtime: IAgentRuntime): number {\n  try {\n    const settings = runtime.getSetting('mcp');\n    if (settings && 'maxRetries' in settings && settings.maxRetries !== undefined) {\n      const configValue = Number(settings.maxRetries);\n      if (!Number.isNaN(configValue) && configValue >= 0) {\n        logger.debug(`[WITH-MODEL-RETRY] Using configured selection retries: ${configValue}`);\n        return configValue;\n      }\n    }\n  } catch (error) {\n    logger.debug(\n      { error: error instanceof Error ? error.message : String(error) },\n      '[WITH-MODEL-RETRY] Error reading selection retries config'\n    );\n  }\n\n  return DEFAULT_MAX_RETRIES;\n}\n",
    "export const toolSelectionNameTemplate = `\n{{mcpProvider.text}}\n\n{{recentMessages}}\n\n# TASK: Select the Most Appropriate Tool and Server\n\nYou must select the most appropriate tool from the list above to fulfill the user's request. Your response must be a valid JSON object with the required properties.\n\n## CRITICAL INSTRUCTIONS\n1. Provide both \"serverName\" and \"toolName\" from the options listed above.\n2. Each name must match EXACTLY as shown in the list:\n   - Example (correct): \"serverName\": \"github\"\n   - Example (incorrect): \"serverName\": \"GitHub\", \"Github\", or variations\n3. Extract ACTUAL parameter values from the conversation context.\n   - Do not invent or use placeholders like \"octocat\" or \"Hello-World\" unless the user said so.\n4. Include a \"reasoning\" field explaining why the selected tool fits the request.\n5. If no tool is appropriate, respond with:\n   {\n     \"noToolAvailable\": true\n   }\n\n!!! YOUR RESPONSE MUST BE A VALID JSON OBJECT ONLY !!! \n\nCRITICAL: Your response must START with { and END with }. DO NOT include ANY text before or after the JSON.\n\n## STRICT FORMAT REQUIREMENTS\n- The response MUST be a single valid JSON object.\n- DO NOT wrap the JSON in triple backticks (\\`\\`\\`), code blocks, or include any explanatory text.\n- DO NOT include comments (// or /* */) anywhere.\n- DO NOT use placeholders (e.g., \"replace with...\", \"example\", \"your...\", etc.)\n- ALL strings must use double quotes.\n\n## CRITICAL NOTES\n- All values must be fully grounded in user input or inferred contextually.\n- No missing fields unless they are explicitly optional in the schema.\n- All types must match the schema (strings, numbers, booleans).\n\n## JSON OBJECT STRUCTURE\nYour response MUST contain ONLY these top-level keys:\n1. \"serverName\"  The name of the server (e.g., \"github\", \"notion\")\n2. \"toolName\"  The name of the tool (e.g., \"get_file_contents\", \"search\")\n3. \"reasoning\"  A string explaining how the values were inferred from the conversation.\n4. \"noToolAvailable\"  A boolean indicating if no tool is available (true/false)\n\n## EXAMPLE RESPONSE\n{\n  \"serverName\": \"github\",\n  \"toolName\": \"get_file_contents\",\n  \"reasoning\": \"The user wants to retrieve the README from the facebook/react repository.\",\n  \"noToolAvailable\": false\n}\n\n## REMINDERS\n- Use \"github\" as serverName for GitHub tools.\n- Use \"notion\" as serverName for Notion tools.\n- For search and knowledge-based tasks, MCP tools are often appropriate.\n\nREMEMBER: This output will be parsed directly as JSON. If the format is incorrect, the operation will fail.\n`;\n\nexport const toolSelectionArgumentTemplate = `\n{{recentMessages}}\n\n# TASK: Generate a Strictly Valid JSON Object for Tool Execution\n\nYou have chosen the \"{{toolSelectionName.toolName}}\" tool from the \"{{toolSelectionName.serverName}}\" server to address the user's request.\nThe reasoning behind this selection is: \"{{toolSelectionName.reasoning}}\"\n\n## CRITICAL INSTRUCTIONS\n1. Ensure the \"toolArguments\" object strictly adheres to the structure and requirements defined in the schema.\n2. All parameter values must be extracted from the conversation context and must be concrete, usable values.\n3. Avoid placeholders or generic terms unless explicitly provided by the user.\n\n!!! YOUR RESPONSE MUST BE A VALID JSON OBJECT ONLY !!! \n\n## STRICT FORMAT REQUIREMENTS\n- The response MUST be a single valid JSON object.\n- DO NOT wrap the JSON in triple backticks (\\`\\`\\`), code blocks, or include any explanatory text.\n- DO NOT include comments (// or /* */) anywhere.\n- DO NOT use placeholders (e.g., \"replace with...\", \"example\", \"your...\", etc.)\n- ALL strings must use double quotes\n\n## CRITICAL NOTES\n- All values must be fully grounded in user input or inferred contextually.\n- No missing fields unless they are explicitly optional in the schema.\n- All types must match the schema (strings, numbers, booleans).\n\n## JSON OBJECT STRUCTURE\nYour response MUST contain ONLY these two top-level keys:\n1. \"toolArguments\"  An object matching the input schema: {{toolInputSchema}}\n2. \"reasoning\"  A string explaining how the values were inferred from the conversation.\n\n## EXAMPLE RESPONSE\n{\n  \"toolArguments\": {\n    \"owner\": \"facebook\",\n    \"repo\": \"react\",\n    \"path\": \"README.md\",\n    \"branch\": \"main\"\n  },\n  \"reasoning\": \"The user wants to see the README from the facebook/react repository based on our conversation.\"\n}\n\nREMEMBER: Your response will be parsed directly as JSON. If it fails to parse, the operation will fail completely.\n`;\n",
    "export const toolSelectionNameSchema = {\n  type: \"object\",\n  required: [\"serverName\", \"toolName\"],\n  properties: {\n    serverName: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"serverName must not be empty\",\n    },\n    toolName: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"toolName must not be empty\",\n    },\n    reasoning: {\n      type: \"string\",\n    },\n    noToolAvailable: {\n      type: \"boolean\",\n    },\n  },\n};\n\nexport interface ToolSelectionName {\n  serverName: string;\n  toolName: string;\n  reasoning?: string;\n  noToolAvailable?: boolean;\n}\n\nexport const toolSelectionArgumentSchema = {\n  type: \"object\",\n  required: [\"toolArguments\"],\n  properties: {\n    toolArguments: {\n      type: \"object\",\n    },\n  },\n};\n\nexport interface ToolSelectionArgument {\n  toolArguments: Record<string, unknown>;\n}\n\nexport const ResourceSelectionSchema = {\n  type: \"object\",\n  required: [\"serverName\", \"uri\"],\n  properties: {\n    serverName: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"serverName must not be empty\",\n    },\n    uri: {\n      type: \"string\",\n      minLength: 1,\n      errorMessage: \"uri must not be empty\",\n    },\n    reasoning: {\n      type: \"string\",\n    },\n    noResourceAvailable: {\n      type: \"boolean\",\n    },\n  },\n};\n\nexport interface ResourceSelection {\n  serverName: string;\n  uri: string;\n  reasoning?: string;\n  noResourceAvailable?: boolean;\n}\n",
    "import type { State } from \"@elizaos/core\";\nimport {\n  type McpProviderData,\n  type McpServer,\n  ResourceSelectionSchema,\n  type ValidationResult,\n} from \"../types\";\nimport { validateJsonSchema } from \"./json\";\nimport {\n  toolSelectionArgumentSchema,\n  toolSelectionNameSchema,\n  type ToolSelectionArgument,\n  type ToolSelectionName,\n} from \"./schemas\";\n\nexport interface ToolSelection {\n  serverName: string;\n  toolName: string;\n  arguments: Record<string, unknown>;\n  reasoning?: string;\n  noToolAvailable?: boolean;\n}\n\nexport interface ResourceSelection {\n  serverName: string;\n  uri: string;\n  reasoning?: string;\n  noResourceAvailable?: boolean;\n}\n\nexport function validateToolSelectionName(\n  parsed: unknown,\n  state: State\n): ValidationResult<ToolSelectionName> {\n  const basicResult = validateJsonSchema<ToolSelectionName>(parsed, toolSelectionNameSchema);\n  if (basicResult.success === false) {\n    return { success: false, error: basicResult.error };\n  }\n\n  const data = basicResult.data;\n\n  const mcpData = state.values.mcp || {};\n\n  const server: McpServer | null = mcpData[data.serverName];\n  if (!server || server.status !== \"connected\") {\n    return {\n      success: false,\n      error: `Server \"${data.serverName}\" not found or not connected`,\n    };\n  }\n\n  const toolInfo = server.tools?.[data.toolName as keyof McpServer[\"tools\"]];\n  if (!toolInfo) {\n    return {\n      success: false,\n      error: `Tool \"${data.toolName}\" not found on server \"${data.serverName}\"`,\n    };\n  }\n\n  return { success: true, data };\n}\n\n/**\n * Validates the tool selection argument object.\n * @param parsed - The tool selection object to validate\n * @param toolInputSchema - The input schema for the tool\n * @returns An object indicating success or failure of validation\n */\nexport function validateToolSelectionArgument(\n  parsed: unknown,\n  toolInputSchema: Record<string, unknown>\n): ValidationResult<ToolSelectionArgument> {\n  const basicResult = validateJsonSchema<ToolSelectionArgument>(\n    parsed,\n    toolSelectionArgumentSchema\n  );\n  if (basicResult.success === false) {\n    return { success: false, error: basicResult.error };\n  }\n\n  const data = basicResult.data;\n  const validationResult = validateJsonSchema(data.toolArguments, toolInputSchema);\n\n  if (validationResult.success === false) {\n    return {\n      success: false,\n      error: `Invalid arguments: ${validationResult.error}`,\n    };\n  }\n\n  return { success: true, data };\n}\n\nexport function validateResourceSelection(\n  selection: unknown\n): { success: true; data: ResourceSelection } | { success: false; error: string } {\n  return validateJsonSchema<ResourceSelection>(selection, ResourceSelectionSchema);\n}\n\nexport function createToolSelectionFeedbackPrompt(\n  originalResponse: string,\n  errorMessage: string,\n  composedState: State,\n  userMessage: string\n): string {\n  let toolsDescription = \"\";\n\n  for (const [serverName, server] of Object.entries(composedState.values.mcp || {}) as [\n    string,\n    McpProviderData[string],\n  ][]) {\n    if (server.status !== \"connected\") continue;\n\n    for (const [toolName, tool] of Object.entries(server.tools || {}) as [\n      string,\n      { description?: string },\n    ][]) {\n      toolsDescription += `Tool: ${toolName} (Server: ${serverName})\\n`;\n      toolsDescription += `Description: ${tool.description || \"No description available\"}\\n\\n`;\n    }\n  }\n\n  return createFeedbackPrompt(\n    originalResponse,\n    errorMessage,\n    \"tool\",\n    toolsDescription,\n    userMessage\n  );\n}\n\nexport function createResourceSelectionFeedbackPrompt(\n  originalResponse: string,\n  errorMessage: string,\n  composedState: State,\n  userMessage: string\n): string {\n  let resourcesDescription = \"\";\n\n  for (const [serverName, server] of Object.entries(composedState.values.mcp || {}) as [\n    string,\n    McpProviderData[string],\n  ][]) {\n    if (server.status !== \"connected\") continue;\n\n    for (const [uri, resource] of Object.entries(server.resources || {}) as [\n      string,\n      { description?: string; name?: string },\n    ][]) {\n      resourcesDescription += `Resource: ${uri} (Server: ${serverName})\\n`;\n      resourcesDescription += `Name: ${resource.name || \"No name available\"}\\n`;\n      resourcesDescription += `Description: ${\n        resource.description || \"No description available\"\n      }\\n\\n`;\n    }\n  }\n\n  return createFeedbackPrompt(\n    originalResponse,\n    errorMessage,\n    \"resource\",\n    resourcesDescription,\n    userMessage\n  );\n}\n\nfunction createFeedbackPrompt(\n  originalResponse: string,\n  errorMessage: string,\n  itemType: string,\n  itemsDescription: string,\n  userMessage: string\n): string {\n  return `Error parsing JSON: ${errorMessage}\n\nYour original response:\n${originalResponse}\n\nPlease try again with valid JSON for ${itemType} selection.\nAvailable ${itemType}s:\n${itemsDescription}\n\nUser request: ${userMessage}`;\n}\n",
    "import type { HandlerCallback, ActionResult } from '@elizaos/core';\n\nexport async function handleNoToolAvailable(\n  callback?: HandlerCallback,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  toolSelection?: Record<string, any> | null\n): Promise<ActionResult> {\n  const responseText =\n    \"I don't have a specific tool that can help with that request. Let me try to assist you directly instead.\";\n  const thoughtText =\n    'No appropriate MCP tool available for this request. Falling back to direct assistance.';\n\n  if (callback && toolSelection?.noToolAvailable) {\n    await callback({\n      text: responseText,\n      thought: thoughtText,\n      actions: ['REPLY'],\n    });\n  }\n\n  return {\n    text: responseText,\n    values: {\n      success: true,\n      noToolAvailable: true,\n      fallbackToDirectAssistance: true,\n    },\n    data: {\n      actionName: 'CALL_MCP_TOOL',\n      noToolAvailable: true,\n      reason: toolSelection?.reasoning || 'No appropriate tool available',\n    },\n    success: true,\n  };\n}\n",
    "import {\n  type Action,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  ModelType,\n  type State,\n  composePromptFromState,\n  logger,\n  type ActionResult,\n} from '@elizaos/core';\nimport type { McpService } from '../service';\nimport { resourceSelectionTemplate } from '../templates/resourceSelectionTemplate';\nimport { MCP_SERVICE_NAME, type McpServer } from '../types';\nimport { handleMcpError } from '../utils/error';\nimport {\n  handleResourceAnalysis,\n  processResourceResult,\n  sendInitialResponse,\n} from '../utils/processing';\nimport {\n  createResourceSelectionFeedbackPrompt,\n  validateResourceSelection,\n} from '../utils/validation';\nimport type { ResourceSelection } from '../utils/validation';\nimport { withModelRetry } from '../utils/wrapper';\n\nfunction createResourceSelectionPrompt(composedState: State, userMessage: string): string {\n  const mcpData = composedState.values.mcp || {};\n  const serverNames = Object.keys(mcpData);\n\n  let resourcesDescription = '';\n  for (const serverName of serverNames) {\n    const server = mcpData[serverName];\n    if (server.status !== 'connected') continue;\n\n    const resourceUris = Object.keys(server.resources || {});\n    for (const uri of resourceUris) {\n      const resource = server.resources[uri];\n      resourcesDescription += `Resource: ${uri} (Server: ${serverName})\\n`;\n      resourcesDescription += `Name: ${resource.name || 'No name available'}\\n`;\n      resourcesDescription += `Description: ${\n        resource.description || 'No description available'\n      }\\n`;\n      resourcesDescription += `MIME Type: ${resource.mimeType || 'Not specified'}\\n\\n`;\n    }\n  }\n\n  const enhancedState: State = {\n    ...composedState,\n    values: {\n      ...composedState.values,\n      resourcesDescription,\n      userMessage,\n    },\n  };\n\n  return composePromptFromState({\n    state: enhancedState,\n    template: resourceSelectionTemplate,\n  });\n}\n\nexport const readResourceAction: Action = {\n  name: 'READ_MCP_RESOURCE',\n  similes: [\n    'READ_RESOURCE',\n    'READ_MCP_RESOURCE',\n    'GET_RESOURCE',\n    'GET_MCP_RESOURCE',\n    'FETCH_RESOURCE',\n    'FETCH_MCP_RESOURCE',\n    'ACCESS_RESOURCE',\n    'ACCESS_MCP_RESOURCE',\n  ],\n  description: 'Reads a resource from an MCP server',\n\n  validate: async (runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<boolean> => {\n    const mcpService = runtime.getService<McpService>(MCP_SERVICE_NAME);\n    if (!mcpService) return false;\n\n    const servers = mcpService.getServers();\n    return (\n      servers.length > 0 &&\n      servers.some(\n        (server: McpServer) =>\n          server.status === 'connected' && server.resources && server.resources.length > 0\n      )\n    );\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state?: State,\n    _options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<ActionResult> => {\n    const composedState = await runtime.composeState(message, ['RECENT_MESSAGES', 'MCP']);\n\n    const mcpService = runtime.getService<McpService>(MCP_SERVICE_NAME);\n    if (!mcpService) {\n      throw new Error('MCP service not available');\n    }\n\n    const mcpProvider = mcpService.getProviderData();\n\n    try {\n      await sendInitialResponse(callback);\n\n      const resourceSelectionPrompt = createResourceSelectionPrompt(\n        composedState,\n        message.content.text || ''\n      );\n\n      const resourceSelection = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt: resourceSelectionPrompt,\n      });\n\n      const parsedSelection = await withModelRetry<ResourceSelection>({\n        runtime,\n        state: composedState,\n        message,\n        callback,\n        input: resourceSelection,\n        validationFn: (data) => validateResourceSelection(data),\n        createFeedbackPromptFn: (originalResponse, errorMessage, state, userMessage) =>\n          createResourceSelectionFeedbackPrompt(\n            originalResponse as string,\n            errorMessage,\n            state,\n            userMessage\n          ),\n        failureMsg: `I'm having trouble finding the resource you're looking for. Could you provide more details about what you need?`,\n        retryCount: 0,\n      });\n\n      if (!parsedSelection || parsedSelection.noResourceAvailable) {\n        const responseText =\n          \"I don't have a specific resource that contains the information you're looking for. Let me try to assist you directly instead.\";\n        const thoughtText =\n          'No appropriate MCP resource available for this request. Falling back to direct assistance.';\n\n        if (callback && parsedSelection?.noResourceAvailable) {\n          await callback({\n            text: responseText,\n            thought: thoughtText,\n            actions: ['REPLY'],\n          });\n        }\n        return {\n          text: responseText,\n          values: {\n            success: true,\n            noResourceAvailable: true,\n            fallbackToDirectAssistance: true,\n          },\n          data: {\n            actionName: 'READ_MCP_RESOURCE',\n            noResourceAvailable: true,\n            reason: parsedSelection?.reasoning || 'No appropriate resource available',\n          },\n          success: true,\n        };\n      }\n\n      const { serverName, uri, reasoning } = parsedSelection;\n\n      logger.debug(`Selected resource \"${uri}\" on server \"${serverName}\" because: ${reasoning}`);\n\n      const result = await mcpService.readResource(serverName, uri);\n      logger.debug(`Read resource ${uri} from server ${serverName}`);\n\n      const { resourceContent, resourceMeta } = processResourceResult(result, uri);\n\n      await handleResourceAnalysis(\n        runtime,\n        message,\n        uri,\n        serverName,\n        resourceContent,\n        resourceMeta,\n        callback\n      );\n\n      return {\n        text: `Successfully read resource: ${uri}`,\n        values: {\n          success: true,\n          resourceRead: true,\n          serverName,\n          uri,\n        },\n        data: {\n          actionName: 'READ_MCP_RESOURCE',\n          serverName,\n          uri,\n          reasoning,\n          resourceMeta,\n          contentLength: resourceContent?.length || 0,\n        },\n        success: true,\n      };\n    } catch (error) {\n      return await handleMcpError(\n        composedState,\n        mcpProvider,\n        error,\n        runtime,\n        message,\n        'resource',\n        callback\n      );\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: '{{user}}',\n        content: {\n          text: 'Can you get the documentation about installing ElizaOS?',\n        },\n      },\n      {\n        name: '{{assistant}}',\n        content: {\n          text: `I'll retrieve that information for you. Let me access the resource...`,\n          actions: ['READ_MCP_RESOURCE'],\n        },\n      },\n      {\n        name: '{{assistant}}',\n        content: {\n          text: `ElizaOS installation is straightforward. You'll need Node.js 23+ and Git installed. For Windows users, WSL 2 is required. The quickest way to get started is by cloning the ElizaOS starter repository with \\`git clone https://github.com/elizaos/eliza-starter.git\\`, then run \\`cd eliza-starter && cp .env.example .env && bun i && bun run build && bun start\\`. This will set up a development environment with the core features enabled. After starting, you can access the web interface at http://localhost:3000 to interact with your agent.`,\n          actions: ['READ_MCP_RESOURCE'],\n        },\n      },\n    ],\n  ],\n};\n",
    "export const resourceSelectionTemplate = `\n{{{mcpProvider.text}}}\n\n{{{recentMessages}}}\n\n# Prompt\n\nYou are an intelligent assistant helping select the right resource to address a user's request.\n\nCRITICAL INSTRUCTIONS:\n1. You MUST specify both a valid serverName AND uri from the list above\n2. The serverName value should match EXACTLY the server name shown in parentheses (Server: X)\n   CORRECT: \"serverName\": \"github\"  (if the server is called \"github\") \n   WRONG: \"serverName\": \"GitHub\" or \"Github\" or any other variation\n3. The uri value should match EXACTLY the resource uri listed\n   CORRECT: \"uri\": \"weather://San Francisco/current\"  (if that's the exact uri)\n   WRONG: \"uri\": \"weather://sanfrancisco/current\" or any variation\n4. Identify the user's information need from the conversation context\n5. Select the most appropriate resource based on its description and the request\n6. If no resource seems appropriate, output {\"noResourceAvailable\": true}\n\n!!! YOUR RESPONSE MUST BE A VALID JSON OBJECT ONLY !!! \n\nSTRICT FORMAT REQUIREMENTS:\n- NO code block formatting (NO backticks or \\`\\`\\`)\n- NO comments (NO // or /* */)\n- NO placeholders like \"replace with...\", \"example\", \"your...\", \"actual\", etc.\n- Every parameter value must be a concrete, usable value (not instructions to replace)\n- Use proper JSON syntax with double quotes for strings\n- NO explanatory text before or after the JSON object\n\nEXAMPLE RESPONSE:\n{\n  \"serverName\": \"weather-server\",\n  \"uri\": \"weather://San Francisco/current\",\n  \"reasoning\": \"Based on the conversation, the user is asking about current weather in San Francisco. This resource provides up-to-date weather information for that city.\"\n}\n\nREMEMBER: Your response will be parsed directly as JSON. If it fails to parse, the operation will fail completely!\n`;\n",
    "import type { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\nimport type { McpService } from \"./service\";\nimport { MCP_SERVICE_NAME } from \"./types\";\n\nexport const provider: Provider = {\n  name: \"MCP\",\n  description: \"Information about connected MCP servers, tools, and resources\",\n\n  get: async (runtime: IAgentRuntime, _message: Memory, _state: State) => {\n    const mcpService = runtime.getService<McpService>(MCP_SERVICE_NAME);\n    if (!mcpService) {\n      return {\n        values: { mcp: {} },\n        data: { mcp: {} },\n        text: \"No MCP servers are available.\",\n      };\n    }\n\n    return mcpService.getProviderData();\n  },\n};\n",
    "import { type IAgentRuntime, Service, logger } from '@elizaos/core';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport type {\n  CallToolResult,\n  Resource,\n  ResourceTemplate,\n  Tool,\n} from '@modelcontextprotocol/sdk/types.js';\nimport {\n  DEFAULT_MCP_TIMEOUT_SECONDS,\n  MCP_SERVICE_NAME,\n  type McpConnection,\n  type McpProvider,\n  type McpResourceResponse,\n  type McpServer,\n  type McpServerConfig,\n  type McpSettings,\n  type HttpMcpServerConfig,\n  type StdioMcpServerConfig,\n  DEFAULT_PING_CONFIG,\n  MAX_RECONNECT_ATTEMPTS,\n  BACKOFF_MULTIPLIER,\n  INITIAL_RETRY_DELAY,\n  type ConnectionState,\n  type PingConfig,\n} from './types';\nimport { buildMcpProviderData } from './utils/mcp';\nimport {\n  createMcpToolCompatibilitySync as createMcpToolCompatibility,\n  type McpToolCompatibility,\n} from './tool-compatibility';\n\nexport class McpService extends Service {\n  static serviceType: string = MCP_SERVICE_NAME;\n  capabilityDescription = 'Enables the agent to interact with MCP (Model Context Protocol) servers';\n\n  private connections: Map<string, McpConnection> = new Map();\n  private connectionStates: Map<string, ConnectionState> = new Map();\n  private mcpProvider: McpProvider = {\n    values: { mcp: {}, mcpText: '' },\n    data: { mcp: {} },\n    text: '',\n  };\n  private pingConfig: PingConfig = DEFAULT_PING_CONFIG;\n  private toolCompatibility: McpToolCompatibility | null = null;\n  private compatibilityInitialized = false;\n\n  private initializationPromise: Promise<void> | null = null;\n\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n    logger.info('[McpService] Constructor called, starting initialization...');\n    // Start initialization and store the promise for awaiting later\n    this.initializationPromise = this.initializeMcpServers();\n  }\n\n  static async start(runtime: IAgentRuntime): Promise<McpService> {\n    const service = new McpService(runtime);\n    // Wait for MCP servers to be connected before returning\n    if (service.initializationPromise) {\n      await service.initializationPromise;\n    }\n    return service;\n  }\n  \n  /**\n   * Wait for initialization to complete (useful if service was created without awaiting start)\n   */\n  async waitForInitialization(): Promise<void> {\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n    }\n  }\n\n  async stop(): Promise<void> {\n    for (const [name] of this.connections) {\n      await this.deleteConnection(name);\n    }\n    this.connections.clear();\n    for (const state of this.connectionStates.values()) {\n      if (state.pingInterval) clearInterval(state.pingInterval);\n      if (state.reconnectTimeout) clearTimeout(state.reconnectTimeout);\n    }\n    this.connectionStates.clear();\n  }\n\n  private async initializeMcpServers(): Promise<void> {\n    logger.info('[McpService] Starting MCP server initialization...');\n    try {\n      const mcpSettings = this.getMcpSettings();\n      const serverCount = mcpSettings?.servers ? Object.keys(mcpSettings.servers).length : 0;\n      const serverNames = mcpSettings?.servers ? Object.keys(mcpSettings.servers) : [];\n      logger.info(`[McpService] Getting MCP settings... hasSettings=${!!mcpSettings} hasServers=${!!mcpSettings?.servers} serverCount=${serverCount} servers=${JSON.stringify(serverNames)}`);\n      \n      if (!mcpSettings || !mcpSettings.servers) {\n        logger.info('[McpService] No MCP servers configured.');\n        // Still build provider data with empty state so runtime doesn't crash\n        this.mcpProvider = buildMcpProviderData([]);\n        return;\n      }\n      \n      if (Object.keys(mcpSettings.servers).length === 0) {\n        logger.info('[McpService] MCP settings exist but no servers configured.');\n        this.mcpProvider = buildMcpProviderData([]);\n        return;\n      }\n      \n      logger.info(`[McpService] Connecting to ${Object.keys(mcpSettings.servers).length} MCP servers: ${JSON.stringify(Object.keys(mcpSettings.servers))}`);\n      \n      // Track connection attempts\n      const connectionStartTime = Date.now();\n      await this.updateServerConnections(mcpSettings.servers);\n      const connectionDuration = Date.now() - connectionStartTime;\n      \n      // Get final server status\n      const servers = this.getServers();\n      const connectedServers = servers.filter(s => s.status === 'connected');\n      const failedServers = servers.filter(s => s.status !== 'connected');\n      \n      // Log detailed status\n      if (connectedServers.length > 0) {\n        const toolCounts = connectedServers.map(s => `${s.name}:${s.tools?.length || 0}tools`).join(', ');\n        logger.info(`[McpService]  Successfully connected ${connectedServers.length}/${servers.length} servers in ${connectionDuration}ms: ${toolCounts}`);\n      }\n      \n      if (failedServers.length > 0) {\n        const failedDetails = failedServers.map(s => `${s.name}(${s.error || 'unknown error'})`).join(', ');\n        logger.warn(`[McpService]   Failed to connect to ${failedServers.length}/${servers.length} servers: ${failedDetails}`);\n      }\n      \n      if (connectedServers.length === 0 && servers.length > 0) {\n        logger.error(`[McpService]  ALL MCP servers failed to connect! MCP tools will NOT be available.`);\n      }\n      \n      // Build provider data with whatever servers we have\n      this.mcpProvider = buildMcpProviderData(servers);\n      const mcpDataKeys = Object.keys(this.mcpProvider.data?.mcp || {});\n      logger.info(`[McpService] MCP provider data built: ${mcpDataKeys.length} server(s) available`);\n      \n    } catch (error) {\n      logger.error(\n        { error: error instanceof Error ? error.message : String(error) },\n        ' Failed to initialize MCP servers - MCP tools will NOT be available'\n      );\n      // Build empty provider data so runtime doesn't crash\n      this.mcpProvider = buildMcpProviderData([]);\n    }\n  }\n\n  private getMcpSettings(): McpSettings | undefined {\n    // Try runtime.getSetting first\n    let settings = this.runtime.getSetting('mcp');\n    logger.info(`[McpService] getSetting(\"mcp\") result: type=${typeof settings} isNull=${settings === null} hasServers=${!!(settings as McpSettings)?.servers}`);\n    \n    // If getSetting returns null/undefined, try accessing character.settings.mcp directly\n    // This handles cases where the runtime's getSetting doesn't find nested objects properly\n    if (!settings || (typeof settings === 'object' && !settings.servers)) {\n      const characterSettings = (this.runtime as any).character?.settings;\n      if (characterSettings?.mcp) {\n        logger.info('[McpService] Found MCP settings in character.settings.mcp (fallback)');\n        settings = characterSettings.mcp;\n      }\n    }\n    \n    // Also check in the runtime's settings object directly\n    if (!settings || (typeof settings === 'object' && !settings.servers)) {\n      const runtimeSettings = (this.runtime as any).settings;\n      if (runtimeSettings?.mcp) {\n        logger.info('[McpService] Found MCP settings in runtime.settings.mcp (fallback)');\n        settings = runtimeSettings.mcp;\n      }\n    }\n    \n    if (settings && typeof settings === 'object' && (settings as McpSettings).servers) {\n      logger.info(`[McpService] MCP settings found with ${Object.keys((settings as McpSettings).servers).length} server(s)`);\n      return settings as McpSettings;\n    }\n    \n    logger.info('[McpService] No valid MCP settings found');\n    return undefined;\n  }\n\n  private async updateServerConnections(\n    serverConfigs: Record<string, McpServerConfig>\n  ): Promise<void> {\n    const currentNames = new Set(this.connections.keys());\n    const newNames = new Set(Object.keys(serverConfigs));\n\n    // First, disconnect servers that are no longer configured\n    for (const name of currentNames) {\n      if (!newNames.has(name)) {\n        await this.deleteConnection(name);\n        logger.info(`Deleted MCP server: ${name}`);\n      }\n    }\n\n    // Then, connect/reconnect all servers in parallel and wait for ALL to complete\n    // This ensures provider data is only built after all connections are settled\n    const connectionPromises = Object.entries(serverConfigs).map(async ([name, config]) => {\n      const currentConnection = this.connections.get(name);\n      if (!currentConnection) {\n        try {\n          await this.initializeConnection(name, config);\n          logger.info(` Connected to MCP server: ${name}`);\n        } catch (error) {\n          logger.error(\n            { error: error instanceof Error ? error.message : String(error), serverName: name },\n            ` Failed to connect to new MCP server ${name}`\n          );\n          // Continue even if this server fails - other servers may work\n        }\n      } else if (JSON.stringify(config) !== currentConnection.server.config) {\n        try {\n          await this.deleteConnection(name);\n          await this.initializeConnection(name, config);\n          logger.info(` Reconnected MCP server with updated config: ${name}`);\n        } catch (error) {\n          logger.error(\n            { error: error instanceof Error ? error.message : String(error), serverName: name },\n            ` Failed to reconnect MCP server ${name}`\n          );\n          // Continue even if this server fails - other servers may work\n        }\n      }\n    });\n\n    // CRITICAL: Wait for ALL connection attempts to complete before returning\n    // This ensures provider data is built with complete server information\n    await Promise.allSettled(connectionPromises);\n    logger.info(`[McpService] All server connection attempts completed`);\n  }\n\n  private async initializeConnection(name: string, config: McpServerConfig): Promise<void> {\n    await this.deleteConnection(name); // Clean up if exists\n    const state: ConnectionState = {\n      status: 'connecting',\n      reconnectAttempts: 0,\n      consecutivePingFailures: 0,\n    };\n    this.connectionStates.set(name, state);\n    try {\n      const client = new Client({ name: 'ElizaOS', version: '1.0.0' }, { capabilities: {} });\n      const transport: StdioClientTransport | SSEClientTransport =\n        config.type === 'stdio'\n          ? await this.buildStdioClientTransport(name, config)\n          : await this.buildHttpClientTransport(name, config);\n      const connection: McpConnection = {\n        server: {\n          name,\n          config: JSON.stringify(config),\n          status: 'connecting',\n        },\n        client,\n        transport,\n      };\n      this.connections.set(name, connection);\n      this.setupTransportHandlers(name, connection, state);\n      await client.connect(transport);\n      \n      // Get server capabilities to check what features are supported\n      const capabilities = client.getServerCapabilities();\n      logger.debug(`[${name}] Server capabilities:`, JSON.stringify(capabilities || {}));\n      \n      // Always fetch tools (core capability)\n      const tools = await this.fetchToolsList(name);\n      \n      // Only fetch resources if server advertises support\n      const resources = capabilities?.resources \n        ? await this.fetchResourcesList(name)\n        : [];\n      \n      // Only fetch resource templates if server advertises resource support\n      // (resource templates are part of the resources capability)\n      const resourceTemplates = capabilities?.resources\n        ? await this.fetchResourceTemplatesList(name)\n        : [];\n      \n      connection.server = {\n        status: 'connected',\n        name,\n        config: JSON.stringify(config),\n        error: '',\n        tools,\n        resources,\n        resourceTemplates,\n      };\n      state.status = 'connected';\n      state.lastConnected = new Date();\n      state.reconnectAttempts = 0;\n      state.consecutivePingFailures = 0;\n      this.startPingMonitoring(name);\n      logger.info(`Successfully connected to MCP server: ${name}`);\n    } catch (error) {\n      state.status = 'disconnected';\n      state.lastError = error instanceof Error ? error : new Error(String(error));\n      this.handleDisconnection(name, error);\n      throw error;\n    }\n  }\n\n  private setupTransportHandlers(name: string, connection: McpConnection, state: ConnectionState) {\n    const config = JSON.parse(connection.server.config) as McpServerConfig;\n    const isHttpTransport = config.type !== 'stdio';\n    \n    connection.transport.onerror = async (error) => {\n      // SSE/HTTP transport errors are often expected timeouts from proxies/load balancers\n      // These typically occur after 5 minutes (300s) and are normal for long-lived connections\n      const errorMessage = error?.message || String(error);\n      const isExpectedTimeout = isHttpTransport && \n        (errorMessage === 'undefined' || \n         errorMessage === '' || \n         errorMessage.includes('SSE error') ||\n         errorMessage.includes('timeout'));\n      \n      if (isExpectedTimeout) {\n        // Log expected SSE timeouts as debug - they're normal and reconnect automatically\n        logger.debug({ serverName: name }, `SSE connection timeout for \"${name}\" (expected, will reconnect)`);\n      } else {\n        // Log unexpected errors as errors\n        logger.error({ error, serverName: name }, `Transport error for \"${name}\"`);\n        connection.server.status = 'disconnected';\n        this.appendErrorMessage(connection, error.message);\n      }\n      \n      // Only auto-reconnect stdio transports; HTTP transports are stateless\n      if (!isHttpTransport) {\n        this.handleDisconnection(name, error);\n      }\n    };\n    connection.transport.onclose = async () => {\n      // For HTTP transports, close events are normal (stateless request/response)\n      if (isHttpTransport) {\n        logger.debug({ serverName: name }, `SSE connection closed for \"${name}\" (stateless, will reconnect on demand)`);\n      } else {\n        logger.warn({ serverName: name }, `Transport closed for \"${name}\"`);\n        connection.server.status = 'disconnected';\n        this.handleDisconnection(name, new Error('Transport closed'));\n      }\n    };\n  }\n\n  private startPingMonitoring(name: string) {\n    const connection = this.connections.get(name);\n    if (!connection) return;\n    \n    const config = JSON.parse(connection.server.config) as McpServerConfig;\n    const isHttpTransport = config.type !== 'stdio';\n    \n    // Skip ping monitoring for HTTP-based transports (they're stateless and reconnect on-demand)\n    if (isHttpTransport) {\n      logger.debug(`[McpService] Skipping ping monitoring for HTTP server: ${name}`);\n      return;\n    }\n    \n    const state = this.connectionStates.get(name);\n    if (!state || !this.pingConfig.enabled) return;\n    if (state.pingInterval) clearInterval(state.pingInterval);\n    state.pingInterval = setInterval(() => {\n      this.sendPing(name).catch((err) => {\n        logger.warn(\n          { error: err instanceof Error ? err.message : String(err), serverName: name },\n          `Ping failed for ${name}`\n        );\n        this.handlePingFailure(name, err);\n      });\n    }, this.pingConfig.intervalMs);\n  }\n\n  private async sendPing(name: string): Promise<void> {\n    const connection = this.connections.get(name);\n    if (!connection) throw new Error(`No connection for ping: ${name}`);\n    // Use a lightweight call, e.g., listTools as a ping\n    await Promise.race([\n      connection.client.listTools(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Ping timeout')), this.pingConfig.timeoutMs)\n      ),\n    ]);\n    // Reset ping failures on success\n    const state = this.connectionStates.get(name);\n    if (state) state.consecutivePingFailures = 0;\n  }\n\n  private handlePingFailure(name: string, error: unknown) {\n    const state = this.connectionStates.get(name);\n    if (!state) return;\n    state.consecutivePingFailures++;\n    if (state.consecutivePingFailures >= this.pingConfig.failuresBeforeDisconnect) {\n      logger.warn(`Ping failures exceeded for ${name}, disconnecting and attempting reconnect.`);\n      this.handleDisconnection(name, error);\n    }\n  }\n\n  private handleDisconnection(name: string, error: unknown) {\n    const state = this.connectionStates.get(name);\n    if (!state) return;\n    state.status = 'disconnected';\n    state.lastError = error instanceof Error ? error : new Error(String(error));\n    if (state.pingInterval) clearInterval(state.pingInterval);\n    if (state.reconnectTimeout) clearTimeout(state.reconnectTimeout);\n    if (state.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n      logger.error(`Max reconnect attempts reached for ${name}. Giving up.`);\n      return;\n    }\n    const delay = INITIAL_RETRY_DELAY * Math.pow(BACKOFF_MULTIPLIER, state.reconnectAttempts);\n    state.reconnectTimeout = setTimeout(async () => {\n      state.reconnectAttempts++;\n      logger.info(`Attempting to reconnect to ${name} (attempt ${state.reconnectAttempts})...`);\n      const config = this.connections.get(name)?.server.config;\n      if (config) {\n        try {\n          await this.initializeConnection(name, JSON.parse(config));\n        } catch (err) {\n          logger.error(\n            { error: err instanceof Error ? err.message : String(err), serverName: name },\n            `Reconnect attempt failed for ${name}`\n          );\n          this.handleDisconnection(name, err);\n        }\n      }\n    }, delay);\n  }\n\n  async deleteConnection(name: string): Promise<void> {\n    const connection = this.connections.get(name);\n    if (connection) {\n      try {\n        await connection.transport.close();\n        await connection.client.close();\n      } catch (error) {\n        logger.error(\n          { error: error instanceof Error ? error.message : String(error), serverName: name },\n          `Failed to close transport for ${name}`\n        );\n      }\n      this.connections.delete(name);\n    }\n    const state = this.connectionStates.get(name);\n    if (state) {\n      if (state.pingInterval) clearInterval(state.pingInterval);\n      if (state.reconnectTimeout) clearTimeout(state.reconnectTimeout);\n      this.connectionStates.delete(name);\n    }\n  }\n\n  private getServerConnection(serverName: string): McpConnection | undefined {\n    return this.connections.get(serverName);\n  }\n\n  private async buildStdioClientTransport(name: string, config: StdioMcpServerConfig) {\n    if (!config.command) {\n      throw new Error(`Missing command for stdio MCP server ${name}`);\n    }\n\n    return new StdioClientTransport({\n      command: config.command,\n      args: config.args,\n      env: {\n        ...config.env,\n        ...(process.env.PATH ? { PATH: process.env.PATH } : {}),\n      },\n      stderr: 'pipe',\n      cwd: config.cwd,\n    });\n  }\n\n  private async buildHttpClientTransport(name: string, config: HttpMcpServerConfig) {\n    if (!config.url) {\n      throw new Error(`Missing URL for HTTP MCP server ${name}`);\n    }\n\n    // Add deprecation warning for legacy \"sse\" type\n    if (config.type === 'sse') {\n      logger.warn(\n        `Server \"${name}\": \"sse\" transport type is deprecated. Use \"streamable-http\" or \"http\" instead for the modern Streamable HTTP transport.`\n      );\n    }\n\n    return new SSEClientTransport(new URL(config.url));\n  }\n\n  private appendErrorMessage(connection: McpConnection, error: string) {\n    const newError = connection.server.error ? `${connection.server.error}\\n${error}` : error;\n    connection.server.error = newError;\n  }\n\n  private async fetchToolsList(serverName: string): Promise<Tool[]> {\n    try {\n      const connection = this.getServerConnection(serverName);\n      if (!connection) {\n        return [];\n      }\n\n      const response = await connection.client.listTools();\n\n      const tools = (response?.tools || []).map((tool) => {\n        // Apply tool compatibility transformation to the tool's input schema\n        let processedTool = { ...tool };\n\n        if (tool.inputSchema) {\n          try {\n            // Initialize compatibility if not already done\n            if (!this.compatibilityInitialized) {\n              this.initializeToolCompatibility();\n            }\n\n            // Apply compatibility transformations automatically\n            processedTool.inputSchema = this.applyToolCompatibility(tool.inputSchema);\n\n            logger.debug(`Applied tool compatibility for: ${tool.name} on server: ${serverName}`);\n          } catch (error) {\n            logger.warn(\n              { error, toolName: tool.name, serverName },\n              `Tool compatibility failed for ${tool.name} on ${serverName}`\n            );\n            // Keep original schema if transformation fails\n          }\n        }\n\n        return processedTool;\n      });\n\n      logger.info(`Fetched ${tools.length} tools for ${serverName}`);\n      for (const tool of tools) {\n        logger.info(`[${serverName}] ${tool.name}: ${tool.description}`);\n      }\n\n      return tools;\n    } catch (error) {\n      logger.error(\n        { error: error instanceof Error ? error.message : String(error), serverName },\n        `Failed to fetch tools for ${serverName}`\n      );\n      return [];\n    }\n  }\n\n  private async fetchResourcesList(serverName: string): Promise<Resource[]> {\n    try {\n      const connection = this.getServerConnection(serverName);\n      if (!connection) {\n        return [];\n      }\n\n      const response = await connection.client.listResources();\n      return response?.resources || [];\n    } catch (error) {\n      logger.warn(\n        { error: error instanceof Error ? error.message : String(error), serverName },\n        `No resources found for ${serverName}`\n      );\n      return [];\n    }\n  }\n\n  private async fetchResourceTemplatesList(serverName: string): Promise<ResourceTemplate[]> {\n    try {\n      const connection = this.getServerConnection(serverName);\n      if (!connection) {\n        return [];\n      }\n\n      const response = await connection.client.listResourceTemplates();\n      return response?.resourceTemplates || [];\n    } catch (error) {\n      logger.warn(\n        { error: error instanceof Error ? error.message : String(error), serverName },\n        `No resource templates found for ${serverName}`\n      );\n      return [];\n    }\n  }\n\n  public getServers(): McpServer[] {\n    return Array.from(this.connections.values())\n      .filter((conn) => !conn.server.disabled)\n      .map((conn) => conn.server);\n  }\n\n  public getProviderData(): McpProvider {\n    return this.mcpProvider;\n  }\n\n  public async callTool(\n    serverName: string,\n    toolName: string,\n    toolArguments?: Record<string, unknown>\n  ): Promise<CallToolResult> {\n    const connection = this.connections.get(serverName);\n    if (!connection) {\n      throw new Error(`No connection found for server: ${serverName}`);\n    }\n    if (connection.server.disabled) {\n      throw new Error(`Server \"${serverName}\" is disabled`);\n    }\n\n    let timeout = DEFAULT_MCP_TIMEOUT_SECONDS;\n    try {\n      const config = JSON.parse(connection.server.config);\n      timeout = config.timeoutInMillis || DEFAULT_MCP_TIMEOUT_SECONDS;\n    } catch (error) {\n      logger.error(\n        { error: error instanceof Error ? error.message : String(error), serverName },\n        `Failed to parse timeout configuration for server ${serverName}`\n      );\n    }\n    const result = await connection.client.callTool(\n      { name: toolName, arguments: toolArguments },\n      undefined,\n      { timeout }\n    );\n    if (!result.content) {\n      throw new Error('Invalid tool result: missing content array');\n    }\n    return result as CallToolResult;\n  }\n\n  public async readResource(serverName: string, uri: string): Promise<McpResourceResponse> {\n    const connection = this.connections.get(serverName);\n    if (!connection) {\n      throw new Error(`No connection found for server: ${serverName}`);\n    }\n    if (connection.server.disabled) {\n      throw new Error(`Server \"${serverName}\" is disabled`);\n    }\n    return await connection.client.readResource({ uri });\n  }\n\n  public async restartConnection(serverName: string): Promise<void> {\n    const connection = this.connections.get(serverName);\n    const config = connection?.server.config;\n    if (config) {\n      logger.info(`Restarting ${serverName} MCP server...`);\n      connection.server.status = 'connecting';\n      connection.server.error = '';\n      try {\n        await this.deleteConnection(serverName);\n        await this.initializeConnection(serverName, JSON.parse(config));\n        logger.info(`${serverName} MCP server connected`);\n      } catch (error) {\n        logger.error(\n          { error: error instanceof Error ? error.message : String(error), serverName },\n          `Failed to restart connection for ${serverName}`\n        );\n        throw new Error(`Failed to connect to ${serverName} MCP server`);\n      }\n    }\n  }\n\n  private initializeToolCompatibility(): void {\n    if (this.compatibilityInitialized) return;\n\n    this.toolCompatibility = createMcpToolCompatibility(this.runtime);\n    this.compatibilityInitialized = true;\n\n    if (this.toolCompatibility) {\n      logger.info(`Tool compatibility enabled`);\n    } else {\n      logger.info(`No tool compatibility needed`);\n    }\n  }\n\n  public applyToolCompatibility(toolSchema: any): any {\n    if (!this.compatibilityInitialized) {\n      this.initializeToolCompatibility();\n    }\n\n    if (!this.toolCompatibility || !toolSchema) {\n      return toolSchema;\n    }\n\n    try {\n      return this.toolCompatibility.transformToolSchema(toolSchema);\n    } catch (error) {\n      logger.warn({ error }, `Tool compatibility transformation failed`);\n      return toolSchema; // Fall back to original schema\n    }\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "7FE3B98268562B6664756E2164756E21",
  "names": []
}