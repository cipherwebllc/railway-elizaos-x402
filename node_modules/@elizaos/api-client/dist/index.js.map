{
  "version": 3,
  "sources": ["../src/lib/base-client.ts", "../src/services/agents.ts", "../src/services/messaging.ts", "../src/services/memory.ts", "../src/services/audio.ts", "../src/services/media.ts", "../src/services/server.ts", "../src/services/system.ts", "../src/services/sessions.ts", "../src/services/runs.ts", "../src/types/jobs.ts", "../src/services/jobs.ts", "../src/client.ts"],
  "sourcesContent": [
    "import { ApiResponse, ApiClientConfig, RequestConfig } from '../types/base';\n\ndeclare const window: any;\n\nexport class ApiError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport abstract class BaseApiClient {\n  protected baseUrl: string;\n  protected apiKey?: string;\n  protected timeout: number;\n  protected defaultHeaders: Record<string, string>;\n\n  constructor(config: ApiClientConfig) {\n    this.baseUrl = config.baseUrl.replace(/\\/$/, ''); // Remove trailing slash\n    this.apiKey = config.apiKey;\n    this.timeout = config.timeout || 30000; // 30 seconds default\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      ...config.headers,\n    };\n\n    if (this.apiKey) {\n      // Server expects X-API-KEY header; keep backward compatibility\n      this.defaultHeaders['X-API-KEY'] = this.apiKey;\n    }\n  }\n\n  /**\n   * Creates a safe response for no-content scenarios (204 responses)\n   * Returns a sensible default based on common API patterns\n   */\n  private createNoContentResponse<T>(): T {\n    // For most delete/update operations, return a success indicator\n    // This handles the common case of { success: boolean } return types\n    return { success: true } as T;\n  }\n\n  protected async request<T>(\n    method: string,\n    path: string,\n    options?: {\n      body?: any;\n      params?: Record<string, any>;\n      headers?: Record<string, string>;\n      config?: RequestConfig;\n    }\n  ): Promise<T> {\n    // Handle empty baseUrl for relative URLs\n    let url: URL;\n    if (this.baseUrl) {\n      url = new URL(`${this.baseUrl}${path}`);\n    } else if (typeof window !== 'undefined' && window.location) {\n      url = new URL(path, window.location.origin);\n    } else {\n      // Fallback for non-browser environments\n      url = new URL(path, 'http://localhost:3000');\n    }\n\n    // Add query parameters\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        ...options?.config?.headers,\n        ...options?.headers,\n      };\n\n      // Remove Content-Type header if body is FormData\n      if (options?.body instanceof FormData) {\n        delete headers['Content-Type'];\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers,\n        body:\n          options?.body instanceof FormData\n            ? options.body\n            : options?.body\n              ? JSON.stringify(options.body)\n              : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      // Handle empty responses (204 No Content)\n      if (response.status === 204 || response.headers.get('content-length') === '0') {\n        // For 204 No Content, create a synthetic success response\n        return this.createNoContentResponse<T>();\n      }\n\n      // Parse JSON response\n      let jsonData: any;\n      try {\n        jsonData = await response.json();\n      } catch (error) {\n        // If JSON parsing fails, treat as success for 2xx responses\n        if (response.ok) {\n          return this.createNoContentResponse<T>();\n        } else {\n          throw new ApiError(\n            'PARSE_ERROR',\n            'Failed to parse response as JSON',\n            undefined,\n            response.status\n          );\n        }\n      }\n\n      // Handle error responses\n      if (!response.ok) {\n        // Try to extract error information from response\n        const error = jsonData?.error || {\n          code: 'HTTP_ERROR',\n          message: `HTTP ${response.status}: ${response.statusText}`,\n        };\n        throw new ApiError(error.code, error.message, error.details, response.status);\n      }\n\n      // Handle successful responses\n      // Check if response is wrapped in { success: true, data: ... } format\n      if (jsonData && typeof jsonData === 'object' && 'success' in jsonData) {\n        const apiResponse = jsonData as ApiResponse<T>;\n        if (!apiResponse.success) {\n          const error =\n            'error' in apiResponse\n              ? apiResponse.error\n              : {\n                  code: 'UNKNOWN_ERROR',\n                  message: 'An unknown error occurred',\n                };\n          throw new ApiError(error.code, error.message, error.details, response.status);\n        }\n        return apiResponse.data;\n      } else {\n        // Response is not wrapped - return the data directly\n        // This handles server endpoints like /health, /ping, /status\n        return jsonData as T;\n      }\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof ApiError) {\n        throw error;\n      }\n\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new ApiError('TIMEOUT', 'Request timed out');\n        }\n        throw new ApiError('NETWORK_ERROR', error.message);\n      }\n\n      throw new ApiError('UNKNOWN_ERROR', 'An unknown error occurred');\n    }\n  }\n\n  protected async get<T>(\n    path: string,\n    options?: Omit<Parameters<typeof this.request>[2], 'body'>\n  ): Promise<T> {\n    return this.request<T>('GET', path, options);\n  }\n\n  protected async post<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('POST', path, { ...options, body });\n  }\n\n  protected async put<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('PUT', path, { ...options, body });\n  }\n\n  protected async patch<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('PATCH', path, { ...options, body });\n  }\n\n  protected async delete<T>(\n    path: string,\n    options?: Omit<Parameters<typeof this.request>[2], 'body'>\n  ): Promise<T> {\n    return this.request<T>('DELETE', path, options);\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Agent,\n  AgentCreateParams,\n  AgentLog,\n  AgentLogsParams,\n  AgentPanel,\n  AgentUpdateParams,\n  AgentWorld,\n  AgentWorldSettings,\n} from '../types/agents';\n\nexport class AgentsService extends BaseApiClient {\n  /**\n   * List all agents with minimal details\n   */\n  async listAgents(): Promise<{ agents: Agent[] }> {\n    return this.get<{ agents: Agent[] }>('/api/agents');\n  }\n\n  /**\n   * Get specific agent details\n   */\n  async getAgent(agentId: UUID): Promise<Agent> {\n    return this.get<Agent>(`/api/agents/${agentId}`);\n  }\n\n  /**\n   * Create a new agent\n   */\n  async createAgent(params: AgentCreateParams): Promise<Agent> {\n    return this.post<Agent>('/api/agents', params);\n  }\n\n  /**\n   * Update an existing agent\n   */\n  async updateAgent(agentId: UUID, params: AgentUpdateParams): Promise<Agent> {\n    return this.patch<Agent>(`/api/agents/${agentId}`, params);\n  }\n\n  /**\n   * Delete an agent\n   */\n  async deleteAgent(agentId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/agents/${agentId}`);\n  }\n\n  /**\n   * Start an existing agent\n   */\n  async startAgent(agentId: UUID): Promise<{ status: string }> {\n    return this.post<{ status: string }>(`/api/agents/${agentId}/start`);\n  }\n\n  /**\n   * Stop a running agent\n   */\n  async stopAgent(agentId: UUID): Promise<{ status: string }> {\n    return this.post<{ status: string }>(`/api/agents/${agentId}/stop`);\n  }\n\n  /**\n   * Get all available worlds\n   */\n  async getWorlds(): Promise<{ worlds: AgentWorld[] }> {\n    return this.get<{ worlds: AgentWorld[] }>('/api/agents/worlds');\n  }\n\n  /**\n   * Add agent to a world\n   */\n  async addAgentToWorld(agentId: UUID, worldId: UUID): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>(`/api/agents/${agentId}/worlds`, { worldId });\n  }\n\n  /**\n   * Update agent's world settings\n   */\n  async updateAgentWorldSettings(\n    agentId: UUID,\n    worldId: UUID,\n    settings: Record<string, any>\n  ): Promise<AgentWorldSettings> {\n    return this.patch<AgentWorldSettings>(`/api/agents/${agentId}/worlds/${worldId}`, { settings });\n  }\n\n  /**\n   * Get agent's plugin panels\n   */\n  async getAgentPanels(agentId: UUID): Promise<{ panels: AgentPanel[] }> {\n    const response = await this.get<Array<{ name: string; path: string }>>(\n      `/api/agents/${agentId}/panels`\n    );\n\n    const panels: AgentPanel[] = (Array.isArray(response) ? response : []).map((panel, index) => ({\n      id: `${panel.name}-${index}`, // Generate an ID since server doesn't send one\n      name: panel.name,\n      url: panel.path,\n      type: 'plugin',\n    }));\n\n    return { panels };\n  }\n\n  /**\n   * Get agent logs\n   */\n  async getAgentLogs(agentId: UUID, params?: AgentLogsParams): Promise<AgentLog[]> {\n    return this.get<AgentLog[]>(`/api/agents/${agentId}/logs`, { params });\n  }\n\n  /**\n   * Delete a specific log entry\n   */\n  async deleteAgentLog(agentId: UUID, logId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/agents/${agentId}/logs/${logId}`);\n  }\n\n  /**\n   * Get agents associated with a server\n   */\n  async getAgentsForMessageServer(\n    messageServerId: UUID\n  ): Promise<{ success: boolean; data: { messageServerId: UUID; agents: UUID[] } }> {\n    return this.get<{ success: boolean; data: { messageServerId: UUID; agents: UUID[] } }>(\n      `/api/messaging/message-servers/${messageServerId}/agents`\n    );\n  }\n\n  async addAgentToMessageServer(\n    messageServerId: UUID,\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { messageServerId: UUID; agentId: UUID; message: string } }> {\n    return this.post<{\n      success: boolean;\n      data: { messageServerId: UUID; agentId: UUID; message: string };\n    }>(`/api/messaging/message-servers/${messageServerId}/agents`, { agentId });\n  }\n\n  async removeAgentFromMessageServer(\n    messageServerId: UUID,\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { messageServerId: UUID; agentId: UUID; message: string } }> {\n    return this.delete<{\n      success: boolean;\n      data: { messageServerId: UUID; agentId: UUID; message: string };\n    }>(`/api/messaging/message-servers/${messageServerId}/agents/${agentId}`);\n  }\n\n  async getMessageServersForAgent(\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { agentId: UUID; messageServers: UUID[] } }> {\n    return this.get<{ success: boolean; data: { agentId: UUID; messageServers: UUID[] } }>(\n      `/api/messaging/agents/${agentId}/message-servers`\n    );\n  }\n}\n",
    "import { UUID, ChannelType } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Message,\n  MessageServer,\n  MessageChannel,\n  MessageSubmitParams,\n  MessageCompleteParams,\n  ExternalMessageParams,\n  ChannelCreateParams,\n  GroupChannelCreateParams,\n  DmChannelParams,\n  ChannelParticipant,\n  MessageSearchParams,\n  MessageServerCreateParams,\n  MessageServerSyncParams,\n  ChannelUpdateParams,\n  ChannelMetadata,\n  MessageMetadata,\n} from '../types/messaging';\nimport { PaginationParams } from '../types/base';\n\n// Internal payload interfaces for API requests\ninterface ChannelCreatePayload {\n  name: string;\n  type: ChannelType;\n  message_server_id: UUID;\n  metadata?: ChannelMetadata;\n}\n\ninterface GroupChannelCreatePayload {\n  name: string;\n  message_server_id: UUID;\n  participantCentralUserIds: UUID[];\n  type?: ChannelType;\n  metadata?: ChannelMetadata;\n}\n\ninterface DmChannelQuery {\n  currentUserId: UUID;\n  targetUserId: UUID;\n  dmServerId: UUID;\n}\n\nexport class MessagingService extends BaseApiClient {\n  /**\n   * Submit agent replies or system messages\n   */\n  async submitMessage(params: MessageSubmitParams): Promise<Message> {\n    return this.post<Message>('/api/messaging/submit', params);\n  }\n\n  /**\n   * Notify message completion\n   */\n  async completeMessage(params: MessageCompleteParams): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>('/api/messaging/complete', params);\n  }\n\n  /**\n   * Ingest messages from external platforms\n   */\n  async ingestExternalMessages(params: ExternalMessageParams): Promise<{ processed: number }> {\n    return this.post<{ processed: number }>('/api/messaging/ingest-external', params);\n  }\n\n  /**\n   * Create a new channel\n   */\n  async createChannel(params: ChannelCreateParams): Promise<MessageChannel> {\n    // MessageServer expects: { name, type, message_server_id, metadata }\n    const payload: ChannelCreatePayload = {\n      name: params.name,\n      type: params.type,\n      message_server_id: params.messageServerId || ('00000000-0000-0000-0000-000000000000' as UUID),\n      metadata: params.metadata,\n    };\n    return this.post<MessageChannel>('/api/messaging/channels', payload);\n  }\n\n  /**\n   * Create a group channel\n   */\n  async createGroupChannel(params: GroupChannelCreateParams): Promise<MessageChannel> {\n    // MessageServer expects: { name, message_server_id, participantCentralUserIds, type?, metadata? }\n    // The client currently provides participantIds and may include message_server_id/type in metadata.\n    const DEFAULT_MESSAGE_SERVER_ID = '00000000-0000-0000-0000-000000000000' as UUID;\n\n    // Extract and clean metadata - handle legacy fields that might be in metadata\n    let cleanedMetadata: ChannelMetadata | undefined;\n    let messageServerIdFromMeta: UUID | undefined;\n    let typeFromMeta: ChannelType | undefined;\n\n    if (params.metadata) {\n      // Create a new metadata object without the hoisted fields\n      const metadataCopy: ChannelMetadata = { ...params.metadata };\n\n      // Extract hoisted fields safely using bracket notation (ChannelMetadata allows [key: string]: unknown)\n      if ('message_server_id' in metadataCopy) {\n        messageServerIdFromMeta = metadataCopy['message_server_id'] as UUID | undefined;\n        delete metadataCopy['message_server_id'];\n      }\n\n      if ('type' in metadataCopy) {\n        typeFromMeta = metadataCopy['type'] as ChannelType | undefined;\n        delete metadataCopy['type'];\n      }\n\n      // Only include metadata if there are remaining properties\n      if (Object.keys(metadataCopy).length > 0) {\n        cleanedMetadata = metadataCopy;\n      }\n    }\n\n    const payload: GroupChannelCreatePayload = {\n      name: params.name,\n      message_server_id: messageServerIdFromMeta || DEFAULT_MESSAGE_SERVER_ID,\n      participantCentralUserIds: params.participantIds,\n      // If caller intended DM, allow type override\n      ...(typeFromMeta ? { type: typeFromMeta } : {}),\n      ...(cleanedMetadata ? { metadata: cleanedMetadata } : {}),\n    };\n\n    return this.post<MessageChannel>('/api/messaging/channels', payload);\n  }\n\n  /**\n   * Find or create a DM channel\n   */\n  async getOrCreateDmChannel(params: DmChannelParams): Promise<MessageChannel> {\n    // Map participantIds -> { currentUserId, targetUserId }\n    const [userA, userB] = params.participantIds;\n    // Arbitrarily treat the first as current and second as target; callers pass [current, target]\n    const query: DmChannelQuery = {\n      currentUserId: userA,\n      targetUserId: userB,\n      dmServerId: '00000000-0000-0000-0000-000000000000' as UUID,\n    };\n    return this.get<MessageChannel>('/api/messaging/dm-channel', { params: query });\n  }\n\n  /**\n   * Get channel details\n   */\n  async getChannelDetails(channelId: UUID): Promise<MessageChannel> {\n    return this.get<MessageChannel>(`/api/messaging/channels/${channelId}/details`);\n  }\n\n  /**\n   * Get channel participants\n   */\n  async getChannelParticipants(channelId: UUID): Promise<{ participants: ChannelParticipant[] }> {\n    return this.get<{ participants: ChannelParticipant[] }>(\n      `/api/messaging/channels/${channelId}/participants`\n    );\n  }\n\n  /**\n   * Add agent to channel\n   */\n  async addAgentToChannel(channelId: UUID, agentId: UUID): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>(`/api/messaging/channels/${channelId}/agents`, {\n      agentId,\n    });\n  }\n\n  /**\n   * Remove agent from channel\n   */\n  async removeAgentFromChannel(channelId: UUID, agentId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/channels/${channelId}/agents/${agentId}`\n    );\n  }\n\n  /**\n   * Delete a channel\n   */\n  async deleteChannel(channelId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/messaging/channels/${channelId}`);\n  }\n\n  /**\n   * Clear channel history\n   */\n  async clearChannelHistory(channelId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(\n      `/api/messaging/channels/${channelId}/messages`\n    );\n  }\n\n  /**\n   * Post a new message to a channel\n   */\n  async postMessage(\n    channelId: UUID,\n    content: string,\n    metadata?: MessageMetadata\n  ): Promise<Message> {\n    return this.post<Message>(`/api/messaging/channels/${channelId}/messages`, {\n      content,\n      metadata,\n    });\n  }\n\n  /**\n   * Get channel messages\n   */\n  async getChannelMessages(\n    channelId: UUID,\n    params?: PaginationParams & { before?: Date | string; after?: Date | string }\n  ): Promise<{ messages: Message[] }> {\n    return this.get<{ messages: Message[] }>(\n      `/api/messaging/channels/${channelId}/messages`,\n      { params }\n    );\n  }\n\n  /**\n   * Get a specific message\n   */\n  async getMessage(messageId: UUID): Promise<Message> {\n    return this.get<Message>(`/api/messaging/messages/${messageId}`);\n  }\n\n  /**\n   * Delete a message from a channel\n   */\n  async deleteMessage(channelId: UUID, messageId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/channels/${channelId}/messages/${messageId}`\n    );\n  }\n\n  /**\n   * Update a message\n   */\n  async updateMessage(messageId: UUID, content: string): Promise<Message> {\n    return this.patch<Message>(`/api/messaging/messages/${messageId}`, { content });\n  }\n\n  /**\n   * Search messages\n   */\n  async searchMessages(params: MessageSearchParams): Promise<{ messages: Message[] }> {\n    return this.post<{ messages: Message[] }>('/api/messaging/messages/search', params);\n  }\n\n  /**\n   * Get current Message Server's ID\n   * This returns the messageServerId of the currently running message server instance.\n   * Clients should use this messageServerId when creating channels and messages.\n   */\n  async getCurrentMessageServer(): Promise<{ messageServerId: UUID }> {\n    return this.get<{ messageServerId: UUID }>('/api/messaging/message-server/current');\n  }\n\n  /**\n   * List all message servers\n   */\n  async listMessageServers(): Promise<{ messageServers: MessageServer[] }> {\n    return this.get<{ messageServers: MessageServer[] }>('/api/messaging/message-servers');\n  }\n\n  /**\n   * Get message server channels\n   */\n  async getMessageServerChannels(messageServerId: UUID): Promise<{ channels: MessageChannel[] }> {\n    return this.get<{ channels: MessageChannel[] }>(\n      `/api/messaging/message-servers/${messageServerId}/channels`\n    );\n  }\n\n  /**\n   * Create a new message server\n   */\n  async createMessageServer(params: MessageServerCreateParams): Promise<MessageServer> {\n    return this.post<MessageServer>('/api/messaging/message-servers', params);\n  }\n\n  /**\n   * Sync message server channels\n   */\n  async syncMessageServerChannels(messageServerId: UUID, params: MessageServerSyncParams): Promise<{ synced: number }> {\n    return this.post<{ synced: number }>(\n      `/api/messaging/message-servers/${messageServerId}/sync-channels`,\n      params\n    );\n  }\n\n  /**\n   * Delete a Message server\n   */\n  async deleteMessageServer(messageServerId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/messaging/message-servers/${messageServerId}`);\n  }\n\n  /**\n   * Update a channel\n   */\n  async updateChannel(\n    channelId: UUID,\n    params: ChannelUpdateParams\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    return this.patch<{ success: boolean; data: MessageChannel }>(\n      `/api/messaging/channels/${channelId}`,\n      params\n    );\n  }\n\n  /**\n   * Generate channel title\n   */\n  async generateChannelTitle(channelId: UUID, agentId: UUID): Promise<{ title: string }> {\n    return this.post<{ title: string }>(\n      `/api/messaging/channels/${channelId}/generate-title`,\n      { agentId }\n    );\n  }\n\n  /**\n   * Add user to channel participants (implemented via updateChannel)\n   */\n  async addUserToChannel(\n    channelId: UUID,\n    userId: UUID\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants: UUID[] = channel.metadata?.participantCentralUserIds || [];\n\n    // Add new user if not already present\n    if (!currentParticipants.includes(userId)) {\n      const updatedParticipants: UUID[] = [...currentParticipants, userId];\n      return this.updateChannel(channelId, {\n        participantCentralUserIds: updatedParticipants,\n      });\n    }\n\n    return { success: true, data: channel };\n  }\n\n  /**\n   * Add multiple users to channel participants (implemented via updateChannel)\n   */\n  async addUsersToChannel(\n    channelId: UUID,\n    userIds: UUID[]\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants: UUID[] = channel.metadata?.participantCentralUserIds || [];\n\n    // Add new users that aren't already present\n    const newParticipants: UUID[] = [...currentParticipants];\n    for (const userId of userIds) {\n      if (!newParticipants.includes(userId)) {\n        newParticipants.push(userId);\n      }\n    }\n\n    return this.updateChannel(channelId, {\n      participantCentralUserIds: newParticipants,\n    });\n  }\n\n  /**\n   * Remove user from channel participants (implemented via updateChannel)\n   */\n  async removeUserFromChannel(\n    channelId: UUID,\n    userId: UUID\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants: UUID[] = channel.metadata?.participantCentralUserIds || [];\n\n    // Remove user from participants\n    const updatedParticipants: UUID[] = currentParticipants.filter((id) => id !== userId);\n\n    return this.updateChannel(channelId, {\n      participantCentralUserIds: updatedParticipants,\n    });\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Memory,\n  Room,\n  MemoryParams,\n  MemoryUpdateParams,\n  RoomCreateParams,\n  WorldCreateParams,\n} from '../types/memory';\n\nexport class MemoryService extends BaseApiClient {\n  /**\n   * Get agent memories\n   */\n  async getAgentMemories(agentId: UUID, params?: MemoryParams): Promise<{ memories: Memory[] }> {\n    return this.get<{ memories: Memory[] }>(`/api/memory/${agentId}/memories`, { params });\n  }\n\n  /**\n   * Get room-specific memories\n   */\n  async getRoomMemories(\n    agentId: UUID,\n    roomId: UUID,\n    params?: MemoryParams\n  ): Promise<{ memories: Memory[] }> {\n    return this.get<{ memories: Memory[] }>(`/api/memory/${agentId}/rooms/${roomId}/memories`, {\n      params,\n    });\n  }\n\n  /**\n   * Update a memory\n   */\n  async updateMemory(agentId: UUID, memoryId: UUID, params: MemoryUpdateParams): Promise<Memory> {\n    return this.patch<Memory>(`/api/memory/${agentId}/memories/${memoryId}`, params);\n  }\n\n  /**\n   * Clear all agent memories\n   */\n  async clearAgentMemories(agentId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/${agentId}/memories`);\n  }\n\n  /**\n   * Clear room memories\n   */\n  async clearRoomMemories(agentId: UUID, roomId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/${agentId}/memories/all/${roomId}`);\n  }\n\n  /**\n   * List agent's rooms\n   */\n  async listAgentRooms(agentId: UUID): Promise<{ rooms: Room[] }> {\n    return this.get<{ rooms: Room[] }>(`/api/memory/${agentId}/rooms`);\n  }\n\n  /**\n   * Get room details\n   */\n  async getRoom(agentId: UUID, roomId: UUID): Promise<Room> {\n    return this.get<Room>(`/api/memory/${agentId}/rooms/${roomId}`);\n  }\n\n  /**\n   * Create a room\n   */\n  async createRoom(agentId: UUID, params: RoomCreateParams): Promise<Room> {\n    return this.post<Room>(`/api/memory/${agentId}/rooms`, params);\n  }\n\n  /**\n   * Create world from message server\n   */\n  async createWorldFromMessageServer(\n    messageServerId: UUID,\n    params: WorldCreateParams\n  ): Promise<{ worldId: UUID }> {\n    return this.post<{ worldId: UUID }>(`/api/memory/groups/${messageServerId}`, params);\n  }\n\n  /**\n   * Delete a world\n   */\n  async deleteWorld(messageServerId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/groups/${messageServerId}`);\n  }\n\n  /**\n   * Clear world memories\n   */\n  async clearWorldMemories(messageServerId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/groups/${messageServerId}/memories`);\n  }\n\n  /**\n   * Delete a specific memory\n   */\n  async deleteMemory(agentId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/${agentId}/memories/${memoryId}`);\n  }\n\n  /**\n   * Get agent internal memories\n   */\n  async getAgentInternalMemories(\n    agentId: UUID,\n    agentPerspectiveRoomId: UUID,\n    includeEmbedding?: boolean\n  ): Promise<{ success: boolean; data: any[] }> {\n    return this.get<{ success: boolean; data: any[] }>(\n      `/api/memory/${agentId}/rooms/${agentPerspectiveRoomId}/memories`,\n      { params: { includeEmbedding } }\n    );\n  }\n\n  /**\n   * Delete agent internal memory\n   */\n  async deleteAgentInternalMemory(agentId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/${agentId}/memories/${memoryId}`);\n  }\n\n  /**\n   * Delete all agent internal memories\n   */\n  async deleteAllAgentInternalMemories(\n    agentId: UUID,\n    agentPerspectiveRoomId: UUID\n  ): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/memory/${agentId}/memories/all/${agentPerspectiveRoomId}`\n    );\n  }\n\n  /**\n   * Update agent internal memory\n   */\n  async updateAgentInternalMemory(agentId: UUID, memoryId: UUID, memoryData: any): Promise<any> {\n    return this.patch<any>(`/api/memory/${agentId}/memories/${memoryId}`, memoryData);\n  }\n\n  /**\n   * Delete group memory (implemented via messaging channel message deletion)\n   */\n  async deleteGroupMemory(messageServerId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/channels/${messageServerId}/messages/${memoryId}`\n    );\n  }\n\n  /**\n   * Clear group chat (implemented via messaging channel history clearing)\n   */\n  async clearGroupChat(messageServerId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/channels/${messageServerId}/messages`\n    );\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  AudioSynthesizeParams,\n  SpeechConversationParams,\n  SpeechGenerateParams,\n  SpeechResponse,\n  TranscribeParams,\n  TranscriptionResponse,\n} from '../types/audio';\n\ndeclare const window: any;\n\nexport class AudioService extends BaseApiClient {\n  /**\n   * Make a binary request using BaseApiClient infrastructure\n   */\n  private async requestBinary(\n    method: string,\n    path: string,\n    options?: {\n      body?: any;\n      params?: Record<string, any>;\n      headers?: Record<string, string>;\n    }\n  ): Promise<ArrayBuffer> {\n    // Handle empty baseUrl for relative URLs\n    let url: URL;\n    if (this.baseUrl) {\n      url = new URL(`${this.baseUrl}${path}`);\n    } else if (typeof window !== 'undefined' && window.location) {\n      url = new URL(path, window.location.origin);\n    } else {\n      // Fallback for non-browser environments\n      url = new URL(path, 'http://localhost:3000');\n    }\n\n    // Add query parameters\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        ...options?.headers,\n      };\n\n      // Remove Content-Type header if body is FormData\n      if (options?.body instanceof FormData) {\n        delete headers['Content-Type'];\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers,\n        body:\n          options?.body instanceof FormData\n            ? options.body\n            : options?.body\n              ? JSON.stringify(options.body)\n              : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.arrayBuffer();\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new Error('Request timed out');\n        }\n        throw error;\n      }\n\n      throw new Error('An unknown error occurred');\n    }\n  }\n\n  /**\n   * Convert audio input to appropriate FormData value\n   */\n  private processAudioInput(audio: Blob | Buffer | string): Blob | string {\n    if (audio instanceof Blob) {\n      return audio;\n    }\n\n    if (typeof audio === 'string') {\n      // Handle base64 data URLs (e.g., \"data:audio/mp3;base64,...\")\n      if (audio.startsWith('data:')) {\n        try {\n          const [header, base64Data] = audio.split(',');\n          const mimeMatch = header.match(/data:([^;]+)/);\n          const mimeType = mimeMatch ? mimeMatch[1] : 'audio/wav';\n\n          const binaryString = atob(base64Data);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          return new Blob([bytes], { type: mimeType });\n        } catch (error) {\n          throw new Error(\n            `Invalid base64 data URL: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n\n      // Handle plain base64 strings (try to decode)\n      if (this.isBase64String(audio)) {\n        try {\n          const binaryString = atob(audio);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          return new Blob([bytes], { type: 'audio/wav' });\n        } catch (error) {\n          // If base64 decoding fails, treat as file path or other string\n          return audio;\n        }\n      }\n\n      // For file paths or other strings, return as-is (server will handle file reading)\n      return audio;\n    }\n\n    // Handle Buffer and ArrayBuffer types\n    if (this.isBuffer(audio)) {\n      return new Blob([new Uint8Array(audio)], { type: 'audio/wav' });\n    }\n\n    // Cast to any for runtime type checking since TypeScript can't narrow the union type properly\n    const audioAsAny = audio as any;\n\n    if (audioAsAny instanceof ArrayBuffer) {\n      return new Blob([audioAsAny], { type: 'audio/wav' });\n    }\n\n    if (\n      audioAsAny &&\n      typeof audioAsAny === 'object' &&\n      'buffer' in audioAsAny &&\n      audioAsAny.buffer instanceof ArrayBuffer\n    ) {\n      // Handle typed arrays like Uint8Array\n      return new Blob([audioAsAny.buffer], { type: 'audio/wav' });\n    }\n\n    throw new Error(\n      `Unsupported audio input type: ${typeof audio}. Expected Blob, Buffer, ArrayBuffer, or string.`\n    );\n  }\n\n  /**\n   * Check if a string appears to be base64 encoded\n   */\n  private isBase64String(str: string): boolean {\n    // Basic base64 pattern check (allows padding)\n    const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;\n\n    // Must be at least 4 characters and divisible by 4 (with padding)\n    if (str.length < 4 || str.length % 4 !== 0) {\n      return false;\n    }\n\n    return base64Pattern.test(str);\n  }\n\n  /**\n   * Safe check for Buffer type (works in both Node.js and browser environments)\n   */\n  private isBuffer(obj: any): obj is Buffer {\n    return (\n      obj != null &&\n      typeof obj === 'object' &&\n      typeof obj.constructor === 'function' &&\n      obj.constructor.name === 'Buffer' &&\n      typeof obj.readUInt8 === 'function'\n    );\n  }\n\n  /**\n   * Handle speech conversation\n   */\n  async speechConversation(\n    agentId: UUID,\n    params: SpeechConversationParams\n  ): Promise<SpeechResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(params.audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (params.format) formData.append('format', params.format);\n    if (params.language) formData.append('language', params.language);\n    if (params.metadata) formData.append('metadata', JSON.stringify(params.metadata));\n\n    return this.request<SpeechResponse>('POST', `/api/audio/${agentId}/speech/conversation`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Generate speech from text\n   */\n  async generateSpeech(\n    agentId: UUID,\n    params: SpeechGenerateParams\n  ): Promise<{ audio: string; format: string }> {\n    // Get the binary audio data using BaseApiClient infrastructure\n    const audioBuffer = await this.requestBinary('POST', `/api/audio/${agentId}/speech/generate`, {\n      body: params,\n    });\n\n    // Convert to base64\n    const bytes = new Uint8Array(audioBuffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    const base64Audio = btoa(binary);\n\n    // Default format (server should ideally return this in a header)\n    const format = 'mpeg';\n\n    return {\n      audio: base64Audio,\n      format: format,\n    };\n  }\n\n  /**\n   * Synthesize audio message\n   */\n  async synthesizeAudioMessage(\n    agentId: UUID,\n    params: AudioSynthesizeParams\n  ): Promise<{ audio: string; format: string }> {\n    return this.post<{ audio: string; format: string }>(\n      `/api/audio/${agentId}/audio-messages/synthesize`,\n      params\n    );\n  }\n\n  /**\n   * Transcribe audio to text\n   */\n  async transcribe(agentId: UUID, params: TranscribeParams): Promise<TranscriptionResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(params.audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (params.format) formData.append('format', params.format);\n    if (params.language) formData.append('language', params.language);\n\n    return this.request<TranscriptionResponse>('POST', `/api/audio/${agentId}/transcriptions`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Process speech input\n   */\n  async processSpeech(\n    agentId: UUID,\n    audio: Blob | Buffer | string,\n    metadata?: Record<string, any>\n  ): Promise<SpeechResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (metadata) formData.append('metadata', JSON.stringify(metadata));\n\n    return this.request<SpeechResponse>('POST', `/api/audio/${agentId}/speech`, {\n      body: formData,\n    });\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport { MediaUploadParams, MediaUploadResponse, ChannelUploadResponse } from '../types/media';\n\nexport class MediaService extends BaseApiClient {\n  /**\n   * Upload media for an agent\n   */\n  async uploadAgentMedia(agentId: UUID, params: MediaUploadParams): Promise<MediaUploadResponse> {\n    const formData = new FormData();\n\n    formData.append('file', params.file, params.filename);\n\n    if (params.contentType) formData.append('contentType', params.contentType);\n    if (params.metadata) formData.append('metadata', JSON.stringify(params.metadata));\n\n    return this.request<MediaUploadResponse>('POST', `/api/media/agents/${agentId}/upload-media`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Upload file to a channel\n   */\n  async uploadChannelMedia(channelId: UUID, file: File): Promise<ChannelUploadResponse> {\n    const formData = new FormData();\n\n    formData.append('file', file);\n\n    return this.request<ChannelUploadResponse>(\n      'POST',\n      `/api/messaging/channels/${channelId}/upload-media`,\n      {\n        body: formData,\n      }\n    );\n  }\n}\n",
    "import { BaseApiClient } from '../lib/base-client';\nimport { ServerHealth, ServerStatus, ServerDebugInfo, LogSubmitParams } from '../types/server';\n\nexport class ServerService extends BaseApiClient {\n  /**\n   * Health check\n   */\n  async checkHealth(): Promise<ServerHealth> {\n    return this.get<ServerHealth>('/api/server/health');\n  }\n\n  /**\n   * Simple ping\n   */\n  async ping(): Promise<{ pong: boolean }> {\n    return this.get<{ pong: boolean }>('/api/server/ping');\n  }\n\n  /**\n   * Hello endpoint\n   */\n  async hello(): Promise<{ message: string }> {\n    return this.get<{ message: string }>('/api/server/hello');\n  }\n\n  /**\n   * Get server status\n   */\n  async getStatus(): Promise<ServerStatus> {\n    return this.get<ServerStatus>('/api/server/status');\n  }\n\n  /**\n   * Stop the server\n   */\n  async stopServer(): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>('/api/server/stop');\n  }\n\n  /**\n   * Get runtime debug info\n   */\n  async getDebugInfo(): Promise<ServerDebugInfo> {\n    return this.get<ServerDebugInfo>('/api/server/debug/servers');\n  }\n\n  /**\n   * Submit logs\n   */\n  async submitLogs(logs: LogSubmitParams[]): Promise<{ received: number }> {\n    return this.post<{ received: number }>('/api/server/logs', { logs });\n  }\n\n  /**\n   * Clear logs\n   */\n  async clearLogs(): Promise<{ cleared: number }> {\n    return this.delete<{ cleared: number }>('/api/server/logs');\n  }\n}\n",
    "import { BaseApiClient } from '../lib/base-client';\nimport { LocalEnvironmentUpdateParams } from '../types/system';\n\nexport class SystemService extends BaseApiClient {\n  /**\n   * Retrieve the local environment variables from the ElizaOS server.\n   *\n   * Server route (packages/server/src/api/system):\n   *   GET /api/system/env/local  ->  { success: true, data: Record<string,string> }\n   */\n  async getEnvironment(): Promise<Record<string, string>> {\n    return this.get<Record<string, string>>('/api/system/env/local');\n  }\n\n  /**\n   * Update (overwrite or merge) the local .env file on the ElizaOS server.\n   *\n   * Server route (packages/server/src/api/system):\n   *   POST /api/system/env/local  ->  { success: true, message: string }\n   *   Body: { content: Record<string,string> }\n   *\n   * For developer-ergonomics we accept several shapes:\n   *   1. { variables: Record<string,string>; merge?: boolean }\n   *   2. { content:   Record<string,string> }      (server-native)\n   *   3. Record<string,string>                      (shorthand)\n   */\n  async updateLocalEnvironment(\n    params:\n      | LocalEnvironmentUpdateParams\n      | { content: Record<string, string> }\n      | Record<string, string>\n  ): Promise<{ success: boolean; message: string }> {\n    if (!params || typeof params !== 'object') {\n      throw new Error('updateLocalEnvironment requires a configuration object');\n    }\n\n    let body: { content: Record<string, string> };\n\n    if ('variables' in params) {\n      body = { content: (params as LocalEnvironmentUpdateParams).variables };\n    } else if ('content' in params) {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      body = { content: (params as { content: Record<string, string> }).content };\n    } else {\n      // Treat params itself as record of env vars\n      body = { content: params as unknown as Record<string, string> };\n    }\n\n    return this.post<{ success: boolean; message: string }>('/api/system/env/local', body);\n  }\n\n  /**\n   * Global logs functionality - implementing via system endpoints\n   */\n  async getGlobalLogs(params?: { level?: string; agentName?: string; agentId?: string }): Promise<{\n    logs: Array<{\n      level: number;\n      time: number;\n      msg: string;\n      [key: string]: string | number | boolean | null | undefined;\n    }>;\n    count: number;\n    total: number;\n    level: string;\n    levels: string[];\n  }> {\n    // Special handling for logs endpoint that returns data directly without wrapper\n    const response = await fetch(this.buildUrl('/api/server/logs', { params }), {\n      method: 'GET',\n      headers: this.getHeaders(),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      logs?: Array<{\n        level: number;\n        time: number;\n        msg: string;\n        [key: string]: string | number | boolean | null | undefined;\n      }>;\n      count?: number;\n      total?: number;\n      requestedLevel?: string;\n      level?: string;\n      levels?: string[];\n    };\n\n    // The logs endpoint returns data directly, not wrapped in { success, data }\n    // Map the response to expected format\n    return {\n      logs: data.logs || [],\n      count: data.count || 0,\n      total: data.total || 0,\n      level: data.requestedLevel || data.level || 'all',\n      levels: data.levels || [],\n    };\n  }\n\n  private buildUrl(path: string, options?: { params?: Record<string, any> }): string {\n    const url = new URL(`${this.baseUrl}${path}`);\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n    return url.toString();\n  }\n\n  private getHeaders(): Record<string, string> {\n    return {\n      ...this.defaultHeaders,\n    };\n  }\n\n  async deleteGlobalLogs(): Promise<{ status: string; message: string }> {\n    return this.delete<{ status: string; message: string }>('/api/server/logs');\n  }\n\n  async deleteLog(logId: string): Promise<void> {\n    // Note: Individual log deletion is not supported by the server\n    // The server only supports bulk deletion via deleteGlobalLogs()\n    throw new Error(\n      'Individual log deletion is not supported. Use deleteGlobalLogs() to clear all logs.'\n    );\n  }\n}\n",
    "import { BaseApiClient } from '../lib/base-client';\nimport type {\n  CreateSessionParams,\n  CreateSessionResponse,\n  SendMessageParams,\n  GetMessagesParams,\n  GetMessagesResponse,\n  SessionInfoResponse,\n  SessionsHealthResponse,\n  ListSessionsResponse,\n  MessageResponse,\n} from '../types/sessions';\n\n/**\n * Query parameters for session messages API\n */\ninterface SessionMessageQueryParams {\n  limit?: string;\n  before?: string;\n  after?: string;\n}\n\n/**\n * Validates and converts a date parameter to timestamp string\n * @param value Date, string, or number to convert\n * @param paramName Name of the parameter for error messages\n * @returns Timestamp string or undefined if value is invalid\n */\nfunction toTimestampString(\n  value: Date | string | number | undefined,\n  paramName: string\n): string | undefined {\n  if (!value) return undefined;\n\n  let timestamp: number;\n\n  if (value instanceof Date) {\n    timestamp = value.getTime();\n  } else if (typeof value === 'string') {\n    const date = new Date(value);\n    timestamp = date.getTime();\n\n    // Check for invalid date\n    if (isNaN(timestamp)) {\n      console.warn(`Invalid date string for ${paramName}: ${value}`);\n      return undefined;\n    }\n  } else if (typeof value === 'number') {\n    timestamp = value;\n  } else {\n    console.warn(`Invalid type for ${paramName}: ${typeof value}`);\n    return undefined;\n  }\n\n  return timestamp.toString();\n}\n\n/**\n * Validates required parameters\n * @param value Parameter value to validate\n * @param paramName Name of the parameter for error messages\n * @throws Error if the parameter is invalid\n */\nfunction validateRequiredParam(\n  value: string | undefined | null,\n  paramName: string\n): asserts value is string {\n  if (!value || value.trim() === '') {\n    throw new Error(`${paramName} is required and cannot be empty`);\n  }\n}\n\n/**\n * Service for managing messaging sessions between users and agents\n */\nexport class SessionsService extends BaseApiClient {\n  /**\n   * Get health status of the sessions service\n   * @returns Health check response\n   */\n  async checkHealth(): Promise<SessionsHealthResponse> {\n    return this.get<SessionsHealthResponse>('/api/messaging/sessions/health');\n  }\n\n  /**\n   * Create a new messaging session\n   * @param params Session creation parameters\n   * @returns Created session response\n   */\n  async createSession(params: CreateSessionParams): Promise<CreateSessionResponse> {\n    return this.post<CreateSessionResponse>('/api/messaging/sessions', params);\n  }\n\n  /**\n   * Get session details\n   * @param sessionId Session ID\n   * @returns Session information\n   */\n  async getSession(sessionId: string): Promise<SessionInfoResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n    return this.get<SessionInfoResponse>(`/api/messaging/sessions/${sessionId}`);\n  }\n\n  /**\n   * Send a message in a session\n   * @param sessionId Session ID\n   * @param params Message parameters\n   * @returns Message response\n   */\n  async sendMessage(sessionId: string, params: SendMessageParams): Promise<MessageResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n    validateRequiredParam(params?.content, 'content');\n    return this.post<MessageResponse>(`/api/messaging/sessions/${sessionId}/messages`, params);\n  }\n\n  /**\n   * Get messages from a session\n   * @param sessionId Session ID\n   * @param params Query parameters for pagination and filtering\n   * @returns Messages response\n   */\n  async getMessages(sessionId: string, params?: GetMessagesParams): Promise<GetMessagesResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n\n    const queryParams: SessionMessageQueryParams = {};\n\n    if (params?.limit) {\n      queryParams.limit = params.limit.toString();\n    }\n\n    // Convert date parameters with validation\n    const beforeTimestamp = toTimestampString(params?.before, 'before');\n    if (beforeTimestamp) {\n      queryParams.before = beforeTimestamp;\n    }\n\n    const afterTimestamp = toTimestampString(params?.after, 'after');\n    if (afterTimestamp) {\n      queryParams.after = afterTimestamp;\n    }\n\n    return this.get<GetMessagesResponse>(`/api/messaging/sessions/${sessionId}/messages`, {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Delete a session\n   * @param sessionId Session ID\n   * @returns Success response\n   */\n  async deleteSession(sessionId: string): Promise<{ success: boolean }> {\n    validateRequiredParam(sessionId, 'sessionId');\n    return this.delete<{ success: boolean }>(`/api/messaging/sessions/${sessionId}`);\n  }\n\n  /**\n   * List all active sessions (admin endpoint)\n   * @returns List of active sessions\n   */\n  async listSessions(): Promise<ListSessionsResponse> {\n    return this.get<ListSessionsResponse>('/api/messaging/sessions');\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport { ListRunsParams, RunDetail, RunSummary } from '../types/runs';\n\nexport class RunsService extends BaseApiClient {\n  async listRuns(\n    agentId: UUID,\n    params?: ListRunsParams\n  ): Promise<{ runs: RunSummary[]; total: number; hasMore: boolean }> {\n    return this.get<{ runs: RunSummary[]; total: number; hasMore: boolean }>(\n      `/api/agents/${agentId}/runs`,\n      { params }\n    );\n  }\n\n  async getRun(agentId: UUID, runId: UUID, roomId?: UUID): Promise<RunDetail> {\n    return this.get<RunDetail>(`/api/agents/${agentId}/runs/${runId}`, {\n      params: roomId ? { roomId } : undefined,\n    });\n  }\n}\n",
    "import { UUID } from '@elizaos/core';\n\n/**\n * Job status enumeration\n */\nexport enum JobStatus {\n    PENDING = 'pending',\n    PROCESSING = 'processing',\n    COMPLETED = 'completed',\n    FAILED = 'failed',\n    TIMEOUT = 'timeout',\n}\n\n/**\n * Validation constants for job requests\n */\nexport const JobValidation = {\n    MAX_CONTENT_LENGTH: 50000, // 50KB max content\n    MAX_METADATA_SIZE: 10000, // 10KB max metadata JSON\n    DEFAULT_TIMEOUT_MS: 30000, // 30 seconds\n    MAX_TIMEOUT_MS: 300000, // 5 minutes\n    MIN_TIMEOUT_MS: 1000, // 1 second\n} as const;\n\n/**\n * Request to create a new job\n */\nexport interface CreateJobRequest {\n    /** Agent ID to send the message to (optional - uses first available agent if not provided) */\n    agentId?: UUID;\n    /** User ID sending the message */\n    userId: UUID;\n    /** Message content/prompt */\n    content: string;\n    /** Optional metadata */\n    metadata?: Record<string, unknown>;\n    /** Optional timeout in milliseconds (default: 30000ms, max: 300000ms) */\n    timeoutMs?: number;\n}\n\n/**\n * Response when creating a job\n */\nexport interface CreateJobResponse {\n    /** Unique job identifier */\n    jobId: string;\n    /** Status of the job */\n    status: JobStatus;\n    /** Timestamp when job was created */\n    createdAt: number;\n    /** Estimated timeout time */\n    expiresAt: number;\n}\n\n/**\n * Job result structure\n */\nexport interface JobResult {\n    /** Agent's response message */\n    message: {\n        id: UUID;\n        content: string;\n        authorId: UUID;\n        createdAt: number;\n        metadata?: Record<string, unknown>;\n    };\n    /** Processing time in milliseconds */\n    processingTimeMs: number;\n}\n\n/**\n * Job details response\n */\nexport interface JobDetailsResponse {\n    /** Unique job identifier */\n    jobId: string;\n    /** Current status */\n    status: JobStatus;\n    /** Agent ID */\n    agentId: UUID;\n    /** User ID */\n    userId: UUID;\n    /** Original prompt/content */\n    prompt: string;\n    /** Timestamp when job was created */\n    createdAt: number;\n    /** Timestamp when job will expire */\n    expiresAt: number;\n    /** Result (only available when status is COMPLETED) */\n    result?: JobResult;\n    /** Error message (only available when status is FAILED) */\n    error?: string;\n    /** Metadata */\n    metadata?: Record<string, unknown>;\n}\n\n/**\n * Poll options for checking job status\n */\nexport interface PollOptions {\n    /** Polling interval in milliseconds (default: 1000ms) */\n    interval?: number;\n    /** Maximum number of poll attempts (default: 30) */\n    maxAttempts?: number;\n    /** Total timeout in milliseconds (overrides maxAttempts if provided) */\n    timeout?: number;\n    /** Callback function called on each poll attempt */\n    onProgress?: (status: JobDetailsResponse, attempt: number) => void;\n}\n\n/**\n * Health check response with metrics\n */\nexport interface JobHealthResponse {\n    healthy: boolean;\n    timestamp: number;\n    totalJobs: number;\n    statusCounts: {\n        pending: number;\n        processing: number;\n        completed: number;\n        failed: number;\n        timeout: number;\n    };\n    metrics: {\n        averageProcessingTimeMs: number;\n        successRate: number;\n        failureRate: number;\n        timeoutRate: number;\n    };\n    maxJobs: number;\n}\n\n/**\n * Job list response\n */\nexport interface JobListResponse {\n    jobs: JobDetailsResponse[];\n    total: number;\n    filtered: number;\n}\n\n/**\n * Parameters for listing jobs\n */\nexport interface ListJobsParams {\n    /** Maximum number of jobs to return */\n    limit?: number;\n    /** Filter by job status */\n    status?: JobStatus;\n}\n\n/**\n * Poll result wrapper\n */\nexport interface PollResult {\n    /** Whether the job completed successfully */\n    success: boolean;\n    /** The final job response */\n    job: JobDetailsResponse;\n    /** Number of poll attempts made */\n    attempts: number;\n    /** Total time spent polling in milliseconds */\n    timeMs: number;\n}\n\n\n",
    "import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n    CreateJobRequest,\n    CreateJobResponse,\n    JobDetailsResponse,\n    JobHealthResponse,\n    JobListResponse,\n    ListJobsParams,\n    JobStatus,\n    PollOptions,\n    PollResult,\n} from '../types/jobs';\n\n/**\n * Jobs API Service - One-off messaging with automatic polling support\n *\n * The Jobs API provides a simplified interface for one-off messages to agents\n * with automatic response handling and polling capabilities.\n *\n * @example\n * ```typescript\n * const client = new ElizaClient({ baseUrl: 'http://localhost:3000' });\n *\n * // Create a job and poll for completion\n * const result = await client.jobs.createAndPoll({\n *   userId: 'user-uuid',\n *   content: 'What is the weather today?'\n * });\n *\n * console.log('Agent response:', result.job.result?.message.content);\n * ```\n */\nexport class JobsService extends BaseApiClient {\n    /**\n     * Create a new job (one-off message to agent)\n     *\n     * @param params - Job creation parameters\n     * @returns Job creation response with jobId and initial status\n     *\n     * @example\n     * ```typescript\n     * const job = await client.jobs.create({\n     *   userId: 'user-uuid',\n     *   content: 'What is Bitcoin price?',\n     *   agentId: 'agent-uuid', // Optional - uses first available if not provided\n     *   timeoutMs: 60000, // Optional - default 30 seconds\n     *   metadata: { source: 'mobile-app' } // Optional\n     * });\n     *\n     * console.log('Job created:', job.jobId);\n     * ```\n     */\n    async create(params: CreateJobRequest): Promise<CreateJobResponse> {\n        return this.post<CreateJobResponse>('/api/messaging/jobs', params);\n    }\n\n    /**\n     * Get job status and details\n     *\n     * @param jobId - The job ID to retrieve\n     * @returns Current job status and details\n     *\n     * @example\n     * ```typescript\n     * const job = await client.jobs.getJob('job-id-123');\n     *\n     * if (job.status === JobStatus.COMPLETED) {\n     *   console.log('Response:', job.result?.message.content);\n     * } else if (job.status === JobStatus.FAILED) {\n     *   console.error('Error:', job.error);\n     * }\n     * ```\n     */\n    async getJob(jobId: string): Promise<JobDetailsResponse> {\n        return this.get<JobDetailsResponse>(`/api/messaging/jobs/${jobId}`);\n    }\n\n    /**\n     * List jobs with optional filtering\n     *\n     * @param params - Optional filtering and pagination parameters\n     * @returns List of jobs matching the criteria\n     *\n     * @example\n     * ```typescript\n     * // Get all completed jobs\n     * const completedJobs = await client.jobs.list({\n     *   status: JobStatus.COMPLETED,\n     *   limit: 10\n     * });\n     *\n     * // Get all jobs (default limit: 50)\n     * const allJobs = await client.jobs.list();\n     * ```\n     */\n    async list(params?: ListJobsParams): Promise<JobListResponse> {\n        return this.get<JobListResponse>('/api/messaging/jobs', { params });\n    }\n\n    /**\n     * Get jobs API health status and metrics\n     *\n     * @returns Health status with metrics\n     *\n     * @example\n     * ```typescript\n     * const health = await client.jobs.health();\n     * console.log('Success rate:', health.metrics.successRate);\n     * console.log('Active jobs:', health.statusCounts.processing);\n     * ```\n     */\n    async health(): Promise<JobHealthResponse> {\n        return this.get<JobHealthResponse>('/api/messaging/jobs/health');\n    }\n\n    /**\n     * Poll a job until completion, failure, or timeout\n     *\n     * This is a convenience method that handles polling logic automatically.\n     * It will continue polling until the job reaches a terminal state (completed, failed, or timeout).\n     *\n     * @param jobId - The job ID to poll\n     * @param options - Polling configuration options\n     * @returns Poll result with final job status\n     *\n     * @example\n     * ```typescript\n     * const result = await client.jobs.poll('job-id-123', {\n     *   interval: 1000, // Poll every second\n     *   maxAttempts: 30, // Give up after 30 attempts\n     *   onProgress: (job, attempt) => {\n     *     console.log(`Attempt ${attempt}: ${job.status}`);\n     *   }\n     * });\n     *\n     * if (result.success) {\n     *   console.log('Response:', result.job.result?.message.content);\n     * } else {\n     *   console.error('Failed:', result.job.error);\n     * }\n     * ```\n     */\n    async poll(jobId: string, options: PollOptions = {}): Promise<PollResult> {\n        const {\n            interval = 1000,\n            maxAttempts = 30,\n            timeout,\n            onProgress,\n        } = options;\n\n        const startTime = Date.now();\n        let attempts = 0;\n\n        // Calculate effective max attempts from timeout if provided\n        const effectiveMaxAttempts = timeout\n            ? Math.ceil(timeout / interval)\n            : maxAttempts;\n\n        while (attempts < effectiveMaxAttempts) {\n            // Check timeout if provided\n            if (timeout && Date.now() - startTime > timeout) {\n                const job = await this.getJob(jobId);\n                return {\n                    success: false,\n                    job,\n                    attempts,\n                    timeMs: Date.now() - startTime,\n                };\n            }\n\n            // Wait before polling (except first attempt)\n            if (attempts > 0) {\n                await new Promise((resolve) => setTimeout(resolve, interval));\n            }\n\n            attempts++;\n\n            // Get current job status\n            const job = await this.getJob(jobId);\n\n            // Call progress callback if provided\n            if (onProgress) {\n                onProgress(job, attempts);\n            }\n\n            // Check if job reached terminal state\n            if (job.status === JobStatus.COMPLETED) {\n                return {\n                    success: true,\n                    job,\n                    attempts,\n                    timeMs: Date.now() - startTime,\n                };\n            }\n\n            if (job.status === JobStatus.FAILED || job.status === JobStatus.TIMEOUT) {\n                return {\n                    success: false,\n                    job,\n                    attempts,\n                    timeMs: Date.now() - startTime,\n                };\n            }\n        }\n\n        // Max attempts reached\n        const job = await this.getJob(jobId);\n        return {\n            success: false,\n            job,\n            attempts,\n            timeMs: Date.now() - startTime,\n        };\n    }\n\n    /**\n     * Create a job and automatically poll until completion\n     *\n     * This is the most convenient method for simple use cases where you want to\n     * send a message and wait for the response in one call.\n     *\n     * @param params - Job creation parameters\n     * @param pollOptions - Optional polling configuration\n     * @returns Poll result with final job status\n     *\n     * @example\n     * ```typescript\n     * // Simple usage\n     * const result = await client.jobs.createAndPoll({\n     *   userId: 'user-uuid',\n     *   content: 'What is the weather today?'\n     * });\n     *\n     * if (result.success) {\n     *   console.log('Agent:', result.job.result?.message.content);\n     * }\n     *\n     * // With custom polling options\n     * const result = await client.jobs.createAndPoll(\n     *   {\n     *     userId: 'user-uuid',\n     *     content: 'Complex analysis query',\n     *     timeoutMs: 120000\n     *   },\n     *   {\n     *     interval: 2000,\n     *     timeout: 120000,\n     *     onProgress: (job, attempt) => {\n     *       console.log(`Waiting... (${attempt})`);\n     *     }\n     *   }\n     * );\n     * ```\n     */\n    async createAndPoll(\n        params: CreateJobRequest,\n        pollOptions?: PollOptions\n    ): Promise<PollResult> {\n        const createResponse = await this.create(params);\n        return this.poll(createResponse.jobId, pollOptions);\n    }\n\n    /**\n     * Create a job and wait for completion with exponential backoff\n     *\n     * Similar to createAndPoll but uses exponential backoff for polling,\n     * which can be more efficient for longer-running jobs.\n     *\n     * @param params - Job creation parameters\n     * @param options - Backoff configuration\n     * @returns Poll result with final job status\n     *\n     * @example\n     * ```typescript\n     * const result = await client.jobs.createAndPollWithBackoff({\n     *   userId: 'user-uuid',\n     *   content: 'Analyze this complex data set'\n     * }, {\n     *   initialInterval: 500,\n     *   maxInterval: 5000,\n     *   multiplier: 1.5,\n     *   maxAttempts: 40\n     * });\n     * ```\n     */\n    async createAndPollWithBackoff(\n        params: CreateJobRequest,\n        options: {\n            initialInterval?: number;\n            maxInterval?: number;\n            multiplier?: number;\n            maxAttempts?: number;\n            timeout?: number;\n            onProgress?: (status: JobDetailsResponse, attempt: number) => void;\n        } = {}\n    ): Promise<PollResult> {\n        const {\n            initialInterval = 500,\n            maxInterval = 5000,\n            multiplier = 1.5,\n            maxAttempts = 40,\n            timeout,\n            onProgress,\n        } = options;\n\n        const createResponse = await this.create(params);\n        const jobId = createResponse.jobId;\n\n        const startTime = Date.now();\n        let attempts = 0;\n        let currentInterval = initialInterval;\n\n        while (attempts < maxAttempts) {\n            // Check timeout if provided\n            if (timeout && Date.now() - startTime > timeout) {\n                const job = await this.getJob(jobId);\n                return {\n                    success: false,\n                    job,\n                    attempts,\n                    timeMs: Date.now() - startTime,\n                };\n            }\n\n            // Wait before polling (except first attempt)\n            if (attempts > 0) {\n                await new Promise((resolve) => setTimeout(resolve, currentInterval));\n                // Increase interval with exponential backoff\n                currentInterval = Math.min(currentInterval * multiplier, maxInterval);\n            }\n\n            attempts++;\n\n            // Get current job status\n            const job = await this.getJob(jobId);\n\n            // Call progress callback if provided\n            if (onProgress) {\n                onProgress(job, attempts);\n            }\n\n            // Check if job reached terminal state\n            if (job.status === JobStatus.COMPLETED) {\n                return {\n                    success: true,\n                    job,\n                    attempts,\n                    timeMs: Date.now() - startTime,\n                };\n            }\n\n            if (job.status === JobStatus.FAILED || job.status === JobStatus.TIMEOUT) {\n                return {\n                    success: false,\n                    job,\n                    attempts,\n                    timeMs: Date.now() - startTime,\n                };\n            }\n        }\n\n        // Max attempts reached\n        const job = await this.getJob(jobId);\n        return {\n            success: false,\n            job,\n            attempts,\n            timeMs: Date.now() - startTime,\n        };\n    }\n\n    /**\n     * Convenience method to ask a question and get the response\n     *\n     * This is a simplified interface that abstracts away the job ID and returns\n     * the agent's response content directly. Throws an error if the job fails.\n     *\n     * @param userId - User ID sending the message\n     * @param content - Message content/question\n     * @param agentId - Optional agent ID to target\n     * @param pollOptions - Optional polling configuration\n     * @returns The agent's response content\n     * @throws Error if the job fails or times out\n     *\n     * @example\n     * ```typescript\n     * try {\n     *   const response = await client.jobs.ask(\n     *     'user-uuid',\n     *     'What is the price of Bitcoin?'\n     *   );\n     *   console.log('Agent says:', response);\n     * } catch (error) {\n     *   console.error('Failed to get response:', error.message);\n     * }\n     * ```\n     */\n    async ask(\n        userId: UUID,\n        content: string,\n        agentId?: UUID,\n        pollOptions?: PollOptions\n    ): Promise<string> {\n        const result = await this.createAndPoll(\n            {\n                userId,\n                content,\n                ...(agentId && { agentId }),\n            },\n            pollOptions\n        );\n\n        if (!result.success || !result.job.result) {\n            throw new Error(\n                result.job.error || 'Job failed or timed out without a response'\n            );\n        }\n\n        return result.job.result.message.content;\n    }\n}\n\n",
    "import { ApiClientConfig } from './types/base';\nimport { AgentsService } from './services/agents';\nimport { MessagingService } from './services/messaging';\nimport { MemoryService } from './services/memory';\nimport { AudioService } from './services/audio';\nimport { MediaService } from './services/media';\nimport { ServerService } from './services/server';\nimport { SystemService } from './services/system';\nimport { SessionsService } from './services/sessions';\nimport { RunsService } from './services/runs';\nimport { JobsService } from './services/jobs';\n\nexport class ElizaClient {\n  public readonly agents: AgentsService;\n  public readonly messaging: MessagingService;\n  public readonly memory: MemoryService;\n  public readonly audio: AudioService;\n  public readonly media: MediaService;\n  public readonly server: ServerService;\n  public readonly system: SystemService;\n  public readonly sessions: SessionsService;\n  public readonly runs: RunsService;\n  public readonly jobs: JobsService;\n\n  constructor(config: ApiClientConfig) {\n    // Initialize all services with the same config\n    this.agents = new AgentsService(config);\n    this.messaging = new MessagingService(config);\n    this.memory = new MemoryService(config);\n    this.audio = new AudioService(config);\n    this.media = new MediaService(config);\n    this.server = new ServerService(config);\n    this.system = new SystemService(config);\n    this.sessions = new SessionsService(config);\n    this.runs = new RunsService(config);\n    this.jobs = new JobsService(config);\n  }\n\n  /**\n   * Create a new ElizaClient instance\n   */\n  static create(config: ApiClientConfig): ElizaClient {\n    return new ElizaClient(config);\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "9C7ACDF98DD0E92E64756E2164756E21",
  "names": []
}