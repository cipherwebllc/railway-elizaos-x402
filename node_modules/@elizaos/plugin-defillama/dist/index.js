// src/index.ts
import { logger as logger15 } from "@elizaos/core";
import { z } from "zod";

// src/services/defiLlamaService.ts
import {
  logger,
  Service
} from "@elizaos/core";
var _DefiLlamaService = class _DefiLlamaService extends Service {
  constructor(runtime) {
    super(runtime);
    this.capabilityDescription = "DeFiLlama API integration for DeFi market data and analytics";
    this.requestQueue = [];
    this.requestCount = 0;
    this.isProcessingQueue = false;
    this.defiConfig = {
      apiBaseUrl: "https://api.llama.fi",
      rateLimitPerMinute: Number(process.env.RATE_LIMIT_PER_MINUTE) || 300,
      maxConcurrentRequests: Number(process.env.MAX_CONCURRENT_REQUESTS) || 10,
      retryAttempts: 3,
      retryDelay: 1e3
    };
    this.resetTime = Date.now() + 6e4;
    this.rateLimitStatus = {
      remaining: this.defiConfig.rateLimitPerMinute,
      resetTime: this.resetTime,
      limit: this.defiConfig.rateLimitPerMinute
    };
  }
  static async start(runtime) {
    logger.info("Starting DeFiLlama service");
    const service = new _DefiLlamaService(runtime);
    service.rateLimitResetInterval = setInterval(() => {
      service.requestCount = 0;
      service.resetTime = Date.now() + 6e4;
      service.rateLimitStatus.remaining = service.defiConfig.rateLimitPerMinute;
      service.rateLimitStatus.resetTime = service.resetTime;
    }, 6e4);
    service.queueProcessInterval = setInterval(
      () => service.processQueue(),
      100
    );
    return service;
  }
  static async stop(runtime) {
    logger.info("Stopping DeFiLlama service");
  }
  async stop() {
    if (this.queueProcessInterval) {
      clearInterval(this.queueProcessInterval);
    }
    if (this.rateLimitResetInterval) {
      clearInterval(this.rateLimitResetInterval);
    }
    this.requestQueue = [];
  }
  // API Methods
  async getProtocols() {
    return this.makeRequest({
      endpoint: "/protocols",
      priority: "medium"
    });
  }
  async getProtocol(slug) {
    return this.makeRequest({
      endpoint: `/protocol/${slug}`,
      priority: "high"
    });
  }
  async getTVL(protocol) {
    if (protocol) {
      const tvlValue = await this.makeRequest({
        endpoint: `/tvl/${protocol}`,
        priority: "medium"
      });
      return {
        date: (/* @__PURE__ */ new Date()).toISOString(),
        totalLiquidityUSD: tvlValue
      };
    } else {
      const chains = await this.makeRequest({
        endpoint: "/v2/chains",
        priority: "medium"
      });
      const totalTVL = chains.reduce((sum, chain) => sum + (chain.tvl || 0), 0);
      return {
        date: (/* @__PURE__ */ new Date()).toISOString(),
        totalLiquidityUSD: totalTVL
      };
    }
  }
  async getYields() {
    const response = await this.makeRequest({
      endpoint: "/pools",
      priority: "medium"
    });
    return response.data || [];
  }
  async getChains() {
    return this.makeRequest({
      endpoint: "/v2/chains",
      priority: "low"
    });
  }
  async getHistoricalTVL(protocol, period) {
    const endpoint = `/protocol/${protocol}`;
    const data = await this.makeRequest({
      endpoint,
      priority: "medium"
    });
    const now = Date.now() / 1e3;
    const periodSeconds = this.parsePeriod(period);
    const startTime = now - periodSeconds;
    const allTvlData = [];
    const dateMap = /* @__PURE__ */ new Map();
    for (const chain of Object.values(data.chainTvls)) {
      if (chain.tvl) {
        for (const tvlPoint of chain.tvl) {
          if (tvlPoint.date >= startTime) {
            const existingValue = dateMap.get(tvlPoint.date) || 0;
            dateMap.set(
              tvlPoint.date,
              existingValue + tvlPoint.totalLiquidityUSD
            );
          }
        }
      }
    }
    for (const [date, totalLiquidityUSD] of dateMap) {
      allTvlData.push({ date, totalLiquidityUSD });
    }
    return allTvlData.sort((a, b) => a.date - b.date);
  }
  async getBridges(params) {
    const queryParams = params ? { includeChains: String(params.includeChains) } : void 0;
    const response = await this.makeRequest({
      endpoint: "/bridges",
      priority: "low",
      params: queryParams
    });
    return response.bridges || [];
  }
  async getStablecoins(params) {
    const queryParams = params ? { includePrices: String(params.includePrices) } : void 0;
    const response = await this.makeRequest({
      endpoint: "/stablecoins",
      priority: "medium",
      params: queryParams
    });
    return response.peggedAssets;
  }
  async getStablecoinChains() {
    return this.makeRequest({
      endpoint: "/stablecoinchains",
      priority: "low"
    });
  }
  // Additional endpoints based on DeFiLlama API specification
  async getYieldChart(poolId) {
    return this.makeRequest({
      endpoint: `/chart/${poolId}`,
      priority: "medium"
    });
  }
  async getDexVolumes(params) {
    return this.makeRequest({
      endpoint: "/overview/dexs",
      priority: "medium",
      params
    });
  }
  async getDexVolumesByChain(chain, params) {
    return this.makeRequest({
      endpoint: `/overview/dexs/${chain}`,
      priority: "medium",
      params
    });
  }
  async getProtocolFees(params) {
    return this.makeRequest({
      endpoint: "/overview/fees",
      priority: "medium",
      params
    });
  }
  async getProtocolFeesByChain(chain, params) {
    return this.makeRequest({
      endpoint: `/overview/fees/${chain}`,
      priority: "medium",
      params
    });
  }
  async getProtocolFeesById(protocolId) {
    return this.makeRequest({
      endpoint: `/summary/fees/${protocolId}`,
      priority: "high"
    });
  }
  async getCoinPrices(coins, searchWidth) {
    const params = {};
    if (searchWidth) {
      params.searchWidth = searchWidth;
    }
    return this.makeRequest({
      endpoint: `/prices/current/${coins.join(",")}`,
      params,
      priority: "high"
    });
  }
  async getHistoricalPrices(coins, timestamp) {
    return this.makeRequest({
      endpoint: `/prices/historical/${timestamp}/${coins.join(",")}`,
      priority: "medium"
    });
  }
  async getBatchHistoricalPrices(coins, searchWidth) {
    const params = {
      coins: coins.join(",")
    };
    if (searchWidth) {
      params.searchWidth = searchWidth;
    }
    return this.makeRequest({
      endpoint: "/batchHistorical",
      params,
      priority: "medium"
    });
  }
  async getFirstPrices(coins) {
    return this.makeRequest({
      endpoint: `/prices/first/${coins.join(",")}`,
      priority: "low"
    });
  }
  // Rate Limiting Methods
  async getRateLimitStatus() {
    return this.rateLimitStatus;
  }
  async batchRequests(requests) {
    const sortedRequests = requests.sort((a, b) => {
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
    const results = await Promise.all(
      sortedRequests.map((req) => this.makeRequest(req))
    );
    return results;
  }
  // Private Methods
  async makeRequest(request) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push({
        request,
        resolve,
        reject,
        timestamp: Date.now()
      });
      this.processQueue();
    });
  }
  async processQueue() {
    if (this.isProcessingQueue || this.requestQueue.length === 0) {
      return;
    }
    this.isProcessingQueue = true;
    try {
      const now = Date.now();
      if (now >= this.resetTime) {
        this.requestCount = 0;
        this.resetTime = now + 6e4;
        this.rateLimitStatus.remaining = this.defiConfig.rateLimitPerMinute;
        this.rateLimitStatus.resetTime = this.resetTime;
      }
      const availableSlots = this.defiConfig.rateLimitPerMinute - this.requestCount;
      const requestsToProcess = Math.min(
        availableSlots,
        this.defiConfig.maxConcurrentRequests,
        this.requestQueue.length
      );
      if (requestsToProcess <= 0) {
        return;
      }
      this.requestQueue.sort((a, b) => {
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        const priorityDiff = priorityOrder[a.request.priority] - priorityOrder[b.request.priority];
        if (priorityDiff !== 0) return priorityDiff;
        return a.timestamp - b.timestamp;
      });
      const batch = this.requestQueue.splice(0, requestsToProcess);
      this.requestCount += batch.length;
      this.rateLimitStatus.remaining = this.defiConfig.rateLimitPerMinute - this.requestCount;
      await Promise.all(
        batch.map(async (item) => {
          try {
            const result = await this.executeRequest(item.request);
            item.resolve(result);
          } catch (error) {
            item.reject(error);
          }
        })
      );
    } finally {
      this.isProcessingQueue = false;
    }
  }
  async executeRequest(request) {
    let url;
    if (request.endpoint.startsWith("/stablecoins") || request.endpoint.startsWith("/stablecoin")) {
      url = `https://stablecoins.llama.fi${request.endpoint}`;
    } else if (request.endpoint.startsWith("/pools") || request.endpoint.startsWith("/chart/")) {
      url = `https://yields.llama.fi${request.endpoint}`;
    } else if (request.endpoint.startsWith("/bridges")) {
      url = `https://bridges.llama.fi${request.endpoint}`;
    } else if (request.endpoint.startsWith("/prices/") || request.endpoint === "/batchHistorical") {
      url = `https://coins.llama.fi${request.endpoint}`;
    } else if (request.endpoint.startsWith("https://")) {
      url = request.endpoint;
    } else {
      url = `${this.defiConfig.apiBaseUrl}${request.endpoint}`;
    }
    const params = new URLSearchParams(request.params || {});
    const fullUrl = params.toString() ? `${url}?${params}` : url;
    for (let attempt = 0; attempt < this.defiConfig.retryAttempts; attempt++) {
      try {
        logger.debug(`DeFiLlama API request: ${fullUrl}`);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1e4);
        const response = await fetch(fullUrl, {
          method: "GET",
          headers: {
            Accept: "application/json",
            "User-Agent": "ElizaOS-DeFiLlama-Plugin/1.0"
          },
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          const shouldRetry = this.shouldRetryError(response.status);
          if (!shouldRetry && attempt === 0) {
          }
          throw new Error(
            `API request failed: ${response.status} ${response.statusText}`
          );
        }
        const data = await response.json();
        return data;
      } catch (error) {
        logger.error(`DeFiLlama API error (attempt ${attempt + 1}):`, error);
        const isLastAttempt = attempt >= this.defiConfig.retryAttempts - 1;
        const isRetryableError = error instanceof Error && (error.name === "AbortError" || // Timeout
        error.message.includes("500") || // Server error
        error.message.includes("502") || // Bad Gateway
        error.message.includes("503") || // Service Unavailable
        error.message.includes("429"));
        if (!isLastAttempt && isRetryableError) {
          const baseDelay = this.defiConfig.retryDelay * Math.pow(2, attempt);
          const jitter = Math.random() * 1e3;
          const delay = baseDelay + jitter;
          logger.debug(`Retrying in ${delay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          const defiError = {
            code: "API_ERROR",
            message: "Failed to fetch data from DeFiLlama API",
            details: error,
            suggestions: [
              "Try again later",
              "Check your internet connection",
              error instanceof Error && error.message.includes("404") ? "The requested resource may not exist" : "This may be a temporary service issue"
            ],
            fallbackAvailable: false
          };
          throw new Error(JSON.stringify(defiError));
        }
      }
    }
  }
  shouldRetryError(statusCode) {
    if (statusCode >= 400 && statusCode < 500) {
      return statusCode === 429;
    }
    if (statusCode >= 500) {
      return true;
    }
    return false;
  }
  parsePeriod(period) {
    const units = {
      "1d": 86400,
      "7d": 604800,
      "30d": 2592e3,
      "90d": 7776e3,
      "1y": 31536e3
    };
    return units[period] || 604800;
  }
};
_DefiLlamaService.serviceType = "defillama";
var DefiLlamaService = _DefiLlamaService;

// src/actions/protocolDataAction.ts
import {
  logger as logger2,
  ModelType
} from "@elizaos/core";
var extractProtocolsTemplate = `Extract protocol and analysis information from the user's request for DeFi protocol data.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- Protocol responses use proper case names: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"
- Category names match API format: "Dexs", "Lending", "Liquid Staking", "Derivatives", "Yield", "CDP", "Bridge"
- Chain filtering should use proper case as returned by /v2/chains endpoint

The user might express protocol requests in various ways:
- "What's Aave's TVL?" \u2192 specific protocol: "Aave"
- "Compare Uniswap and SushiSwap" \u2192 multiple protocols: ["Uniswap", "SushiSwap"]
- "Top lending protocols" \u2192 category: "lending"
- "Show me DEX rankings" \u2192 category: "dex"
- "Best yield farming protocols" \u2192 category: "yield"
- "Ethereum DeFi protocols" \u2192 chain: "Ethereum"
- "Protocol analysis for MakerDAO and Compound" \u2192 protocols: ["MakerDAO", "Compound"]
- "TVL comparison of top 5 protocols" \u2192 analysis: "top_ranking", count: 5

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "protocols": ["Protocol names if specifically mentioned"],
  "categories": ["Category names if mentioned: Dexs/Lending/Liquid Staking/Derivatives/Yield/CDP/Bridge"],
  "chains": ["Chain names as per /v2/chains endpoint: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche"],
  "analysisType": "specific/comparison/ranking/category_analysis/overview",
  "metrics": ["tvl/ranking/volume/fees/apy if specifically requested"],
  "count": number (if user wants top N protocols),
  "timeframe": "24h/7d/30d if mentioned for changes",
  "includeDetails": true/false (if user wants detailed breakdown)
}

Return only the JSON object, no other text.`;
var protocolDataAction = {
  name: "PROTOCOL_DATA",
  similes: [
    "GET_PROTOCOL",
    "PROTOCOL_INFO",
    "PROTOCOL_TVL",
    "PROTOCOL_STATS",
    "COMPARE_PROTOCOLS",
    "PROTOCOL_ANALYSIS",
    "PROTOCOL_METRICS",
    "PROTOCOL_RESEARCH",
    "COMPETITIVE_ANALYSIS",
    "PROTOCOL_INTELLIGENCE",
    "MARKET_POSITION",
    "PROTOCOL_HEALTH"
  ],
  description: `Simple DeFi protocol data fetcher. This action:
1. Extracts protocol names/categories from user queries using LLM
2. Fetches current protocol data from DeFiLlama API
3. Returns clean, structured protocol data for analysis or display
4. Supports multiple protocols and basic protocol information

USE WHEN: User asks about specific protocols, TVL data, or protocol comparisons.
RETURNS: Raw protocol data without extensive analysis - focused on data retrieval.`,
  validate: async (runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    const protocolKeywords = [
      "protocol",
      "tvl",
      "total value locked",
      "defi",
      "ranking",
      "compare",
      "aave",
      "compound",
      "uniswap",
      "curve",
      "makerdao",
      "top protocols",
      "market share",
      "liquidity",
      "dex",
      "dexs",
      "decentralized exchange",
      "trading",
      "swap",
      "swapping",
      "amm",
      "automated market maker",
      "pancakeswap",
      "sushiswap",
      "balancer",
      "1inch",
      "0x",
      "exchange"
    ];
    return protocolKeywords.some((keyword) => text.includes(keyword));
  },
  handler: async (runtime, message, state, options, callback) => {
    try {
      logger2.info("[PROTOCOL_DATA] Starting protocol data fetch");
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const userQuestion = message.content.text || "";
      let extractedParams = {};
      if (options?.protocolParams) {
        extractedParams = options.protocolParams;
      } else {
        const prompt = extractProtocolsTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              protocols: parsed.protocols || [],
              categories: parsed.categories || [],
              chains: parsed.chains || [],
              analysisType: parsed.analysisType || "overview",
              metrics: parsed.metrics || [],
              count: parsed.count || 10,
              timeframe: parsed.timeframe || "24h",
              includeDetails: parsed.includeDetails || false
            };
            logger2.info(
              `[PROTOCOL_DATA] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger2.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            extractedParams = {
              protocols: [],
              categories: [extractCategoryFromQueryLegacy(userQuestion)].filter(
                Boolean
              ),
              chains: [],
              analysisType: "overview",
              metrics: [],
              count: 10,
              timeframe: "24h",
              includeDetails: false
            };
          }
        } else {
          logger2.warn(
            "[PROTOCOL_DATA] No LLM response received, falling back to regex"
          );
          extractedParams = {
            protocols: [],
            categories: [extractCategoryFromQueryLegacy(userQuestion)].filter(
              Boolean
            ),
            chains: [],
            analysisType: "overview",
            metrics: [],
            count: 10,
            timeframe: "24h",
            includeDetails: false
          };
        }
      }
      logger2.info(
        `[PROTOCOL_DATA] Processing request with categories: ${extractedParams.categories.join(", ")}, protocols: ${extractedParams.protocols.join(", ")}`
      );
      const [protocols, chains] = await Promise.all([
        defiLlamaService.getProtocols(),
        defiLlamaService.getChains()
      ]);
      const validatedProtocols = Array.isArray(protocols) ? protocols : [];
      if (validatedProtocols.length === 0) {
        throw new Error("No protocol data available from API");
      }
      const targetProtocols = extractProtocolsFromDataLLM(
        extractedParams,
        validatedProtocols
      );
      logger2.info(
        `[PROTOCOL_DATA] Found protocols: ${targetProtocols.map((p) => p.name).join(", ")}`
      );
      const protocolData = buildProtocolData(
        targetProtocols,
        validatedProtocols,
        extractedParams.categories[0],
        // Use first category if multiple
        extractedParams.count
      );
      const response = await runtime.useModel(ModelType.LARGE, {
        prompt: `Respond concisely with protocol analysis based on data: ${JSON.stringify(protocolData)}
        and user query: ${JSON.stringify(message.content)}`
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze protocol data at this time.",
          actions: ["PROTOCOL_DATA"],
          source: message.content.source
        });
      }
      return {
        text: response,
        success: true,
        data: {
          actionName: "PROTOCOL_DATA",
          extractedParams,
          targetProtocols,
          protocolData,
          protocolDataFetched: true,
          protocolsFound: protocolData.protocols.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      logger2.error("[PROTOCOL_DATA] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      if (callback) {
        await callback({
          text: `\u274C Failed to fetch protocol data: ${errorMessage}`,
          actions: ["PROTOCOL_DATA"],
          source: message.content.source
        });
      }
      return {
        text: `Error fetching protocol data: ${errorMessage}`,
        success: false,
        error: error instanceof Error ? error : new Error(errorMessage),
        data: {
          actionName: "PROTOCOL_DATA",
          error: errorMessage,
          protocolDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "What is Aave's current TVL and ranking?"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Aave currently ranks #2 in DeFi with $12.8B TVL, up 2.3% over 24h. It's the leading lending protocol with deployments across 8 chains.",
          actions: ["PROTOCOL_DATA"]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Compare Uniswap and SushiSwap TVL"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Uniswap: $5.2B TVL (Rank #5), SushiSwap: $890M TVL (Rank #23). Uniswap leads with 5.8x higher TVL in the DEX category.",
          actions: ["PROTOCOL_DATA"]
        }
      }
    ]
  ]
};
function extractProtocolsFromDataLLM(params, protocols) {
  let foundProtocols = [];
  if (params.protocols && params.protocols.length > 0) {
    for (const protocolName of params.protocols) {
      const protocol = findProtocolByName(protocolName, protocols);
      if (protocol) {
        foundProtocols.push(protocol);
      }
    }
  }
  if (params.categories && params.categories.length > 0) {
    for (const category of params.categories) {
      const categoryProtocols = protocols.filter(
        (p) => p.category && p.category.toLowerCase() === category.toLowerCase()
      );
      foundProtocols.push(...categoryProtocols);
    }
  }
  if (params.chains && params.chains.length > 0) {
    const chainProtocols = protocols.filter(
      (p) => p.chains && params.chains.some(
        (chain) => p.chains.some(
          (pChain) => pChain.toLowerCase() === chain.toLowerCase()
        )
      )
    );
    foundProtocols.push(...chainProtocols);
  }
  foundProtocols = foundProtocols.filter(
    (protocol, index, self) => index === self.findIndex((p) => p.slug === protocol.slug)
  );
  if (foundProtocols.length === 0) {
    foundProtocols = protocols.slice(0, params.count || 10);
  }
  return foundProtocols;
}
function findProtocolByName(name, protocols) {
  const searchName = name.toLowerCase();
  let protocol = protocols.find(
    (p) => p.name.toLowerCase() === searchName || p.slug.toLowerCase() === searchName || p.symbol?.toLowerCase() === searchName
  );
  if (protocol) return protocol;
  protocol = protocols.find(
    (p) => p.name.toLowerCase().includes(searchName) || searchName.includes(p.name.toLowerCase()) || p.slug && p.slug.toLowerCase().includes(searchName) || p.symbol && searchName.includes(p.symbol.toLowerCase())
  );
  return protocol || null;
}
function extractCategoryFromQueryLegacy(query) {
  const searchText = query.toLowerCase();
  const categoryMappings = {
    Dexs: [
      "dex",
      "dexs",
      "decentralized exchange",
      "trading",
      "swap",
      "swapping",
      "amm",
      "automated market maker",
      "trading experience",
      "best trading",
      "trading platform",
      "exchange protocols"
    ],
    Lending: [
      "lending",
      "borrow",
      "borrowing",
      "loan",
      "loans",
      "credit",
      "lending protocol",
      "borrowing platform",
      "lend"
    ],
    "Liquid Staking": [
      "liquid staking",
      "staking",
      "stake",
      "validator",
      "liquid stake",
      "staking protocol",
      "staking platform"
    ],
    Derivatives: [
      "derivatives",
      "perp",
      "perpetual",
      "futures",
      "options",
      "derivative protocol",
      "trading derivatives"
    ],
    Yield: [
      "yield",
      "yield farming",
      "farming",
      "liquidity mining",
      "yield protocol",
      "yield platform",
      "yields"
    ],
    CDP: [
      "cdp",
      "collateralized debt position",
      "collateral",
      "debt position",
      "cdp protocol",
      "maker",
      "makerdao"
    ],
    Bridge: [
      "bridge",
      "cross-chain",
      "cross chain",
      "bridging",
      "bridge protocol"
    ]
  };
  for (const [category, keywords] of Object.entries(categoryMappings)) {
    if (keywords.some((keyword) => searchText.includes(keyword))) {
      return category;
    }
  }
  return null;
}
function buildProtocolData(targetProtocols, allProtocols, categoryFilter = null, count = 10) {
  const data = {
    protocols: [],
    totalTvl: 0,
    categoryBreakdown: {},
    timestamp: Date.now()
  };
  let relevantProtocols = allProtocols;
  if (categoryFilter) {
    relevantProtocols = allProtocols.filter(
      (p) => p.category === categoryFilter
    );
  }
  if (targetProtocols.length > 0) {
    relevantProtocols = targetProtocols;
  }
  relevantProtocols = relevantProtocols.sort((a, b) => (b.tvl || 0) - (a.tvl || 0)).slice(0, count);
  relevantProtocols.forEach((protocol, index) => {
    data.protocols.push({
      name: protocol.name,
      slug: protocol.slug,
      tvl: protocol.tvl || 0,
      rank: calculateProtocolRank(protocol, allProtocols),
      category: protocol.category || "Unknown",
      chains: protocol.chains?.length || 0,
      change_1d: protocol.change_1d || 0,
      change_7d: protocol.change_7d || 0,
      change_30d: protocol.change_30d || 0,
      formatted: formatProtocolData(protocol)
    });
    data.totalTvl += protocol.tvl || 0;
  });
  data.categoryBreakdown = allProtocols.reduce((acc, p) => {
    const category = p.category || "Other";
    acc[category] = (acc[category] || 0) + (p.tvl || 0);
    return acc;
  }, {});
  return data;
}
function calculateProtocolRank(protocol, allProtocols) {
  const sorted = allProtocols.sort((a, b) => (b.tvl || 0) - (a.tvl || 0));
  return sorted.findIndex((p) => p.slug === protocol.slug) + 1;
}
function formatProtocolData(protocol) {
  const tvl = formatTvl(protocol.tvl || 0);
  const change = formatChange(protocol.change_1d);
  return `${protocol.name}: $${tvl} TVL (${change} 24h)`;
}
function formatTvl(tvl) {
  if (tvl >= 1e9) return (tvl / 1e9).toFixed(1) + "B";
  if (tvl >= 1e6) return (tvl / 1e6).toFixed(1) + "M";
  if (tvl >= 1e3) return (tvl / 1e3).toFixed(1) + "K";
  return tvl.toFixed(0);
}
function formatChange(change) {
  if (!change) return "N/A";
  const sign = change >= 0 ? "+" : "";
  return `${sign}${change.toFixed(1)}%`;
}

// src/actions/yieldSearchAction.ts
import {
  logger as logger3,
  ModelType as ModelType2
} from "@elizaos/core";
var extractYieldTemplate = `Extract yield search criteria from the user's request for DeFi yield farming opportunities.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /pools endpoint returns data with chain names in proper case: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"
- Protocol names as returned by API: "Aave", "Compound", "Uniswap", "Curve", etc.
- Asset symbols as in underlyingTokens/symbol fields: "USDC", "ETH", "WBTC", etc.

The user might express yield requests in various ways:
- "Best USDC yields" \u2192 asset: "USDC", sortBy: "apy"
- "Aave staking opportunities" \u2192 protocol: "Aave"
- "High APY farming above 15%" \u2192 minApy: 15, riskTolerance: "high"
- "Safe stablecoin yields on Polygon" \u2192 chains: ["Polygon"], assets: ["stablecoins"], riskTolerance: "low"
- "Ethereum lending yields under 10%" \u2192 chains: ["Ethereum"], maxApy: 10, categories: ["lending"]
- "Auto-compounding WETH farms" \u2192 assets: ["WETH"], features: ["auto-compound"]

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "assets": ["Asset symbols if mentioned: USDC/ETH/WBTC/DAI/stablecoins"],
  "protocols": ["Protocol names if mentioned: Aave/Compound/Uniswap/Curve"],
  "chains": ["Chain names as per /pools endpoint: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche"],
  "minApy": number (minimum APY if specified),
  "maxApy": number (maximum APY if specified),
  "minTvl": number (minimum TVL in USD if specified),
  "riskTolerance": "low/medium/high/any (based on user preference)",
  "categories": ["lending/dex/staking/farming if mentioned"],
  "features": ["auto-compound/rewards/stable if mentioned"],
  "sortBy": "apy/tvl/project (how to sort results)",
  "limit": number (how many results, default 15)
}

Return only the JSON object, no other text.`;
var yieldSearchAction = {
  name: "YIELD_SEARCH",
  similes: [
    "FIND_YIELDS",
    "YIELD_FARMING",
    "BEST_APY",
    "STAKING_YIELDS",
    "FARM_SEARCH",
    "APY_SEARCH",
    "YIELD_OPPORTUNITIES",
    "FARMING_OPTIONS",
    "STAKE_REWARDS",
    "LIQUIDITY_MINING"
  ],
  description: `Simple yield opportunity finder. This action:
1. Extracts yield search criteria from user queries using LLM
2. Fetches current yield pool data from DeFiLlama API
3. Returns clean, structured yield data for analysis or display
4. Supports filtering by protocol, asset, chain, and APY ranges

USE WHEN: User asks about yield farming, staking rewards, APY opportunities, or specific yield strategies.
RETURNS: Raw yield data without extensive analysis - focused on data retrieval.`,
  validate: async (runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    const yieldKeywords = [
      "yield",
      "apy",
      "apr",
      "farming",
      "staking",
      "returns",
      "interest",
      "earn",
      "best yields",
      "high apy",
      "stable yields",
      "usdc yield",
      "eth yield",
      "stablecoin yield",
      "farm",
      "stake",
      "liquidity mining",
      "rewards",
      "yield opportunities",
      "passive income",
      "compound",
      "auto-compound"
    ];
    return yieldKeywords.some((keyword) => text.includes(keyword));
  },
  handler: async (runtime, message, state, options, callback) => {
    try {
      logger3.info("[YIELD_SEARCH] Starting yield data fetch");
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const userQuestion = message.content.text || "";
      let yieldCriteria;
      if (options?.yieldParams) {
        yieldCriteria = options.yieldParams;
      } else {
        const prompt = extractYieldTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType2.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            yieldCriteria = {
              assets: parsed.assets || [],
              protocols: parsed.protocols || [],
              chains: parsed.chains || [],
              minApy: parsed.minApy || 0,
              maxApy: parsed.maxApy || 1e3,
              minTvl: parsed.minTvl || 0,
              riskTolerance: parsed.riskTolerance || "any",
              categories: parsed.categories || [],
              features: parsed.features || [],
              sortBy: parsed.sortBy || "apy",
              limit: parsed.limit || 15
            };
            logger3.info(
              `[YIELD_SEARCH] LLM extracted criteria: ${JSON.stringify(yieldCriteria)}`
            );
          } catch (parseError) {
            logger3.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            yieldCriteria = extractYieldCriteriaLegacy(userQuestion);
          }
        } else {
          logger3.warn(
            "[YIELD_SEARCH] No LLM response received, falling back to regex"
          );
          yieldCriteria = extractYieldCriteriaLegacy(userQuestion);
        }
      }
      logger3.info(
        `[YIELD_SEARCH] Fetching yields with criteria: ${JSON.stringify(yieldCriteria)}`
      );
      const yields = await defiLlamaService.getYields();
      const validatedYields = Array.isArray(yields) ? yields : [];
      if (validatedYields.length === 0) {
        throw new Error("No yield data available from API");
      }
      const yieldData = buildYieldData(yieldCriteria, validatedYields);
      const response = await runtime.useModel(ModelType2.LARGE, {
        prompt: `Respond concisely with yield analysis based on data: ${JSON.stringify(yieldData)}
        and user query: ${JSON.stringify(message.content)}`
      });
      if (callback) {
        await callback({
          text: response || "Unable to fetch yield data at this time.",
          actions: ["YIELD_SEARCH"],
          source: message.content.source
        });
      }
      return {
        text: response,
        success: true,
        data: {
          actionName: "YIELD_SEARCH",
          extractedCriteria: yieldCriteria,
          yieldData,
          yieldDataFetched: true,
          yieldsFound: yieldData.yields.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      logger3.error("[YIELD_SEARCH] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      if (callback) {
        await callback({
          text: `\u274C Failed to fetch yield data: ${errorMessage}`,
          actions: ["YIELD_SEARCH"],
          source: message.content.source
        });
      }
      return {
        text: `Error fetching yield data: ${errorMessage}`,
        success: false,
        error: error instanceof Error ? error : new Error(errorMessage),
        data: {
          actionName: "YIELD_SEARCH",
          error: errorMessage,
          yieldDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "What are the best USDC yields right now?"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Best USDC yields: Aave V3 Polygon 4.2% APY ($45M TVL), Compound V3 3.8% APY ($120M TVL), Venus BSC 5.1% APY ($12M TVL). All are stable lending yields with low risk.",
          actions: ["YIELD_SEARCH"]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Find me high APY farming opportunities above 15%"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "High APY opportunities: PancakeSwap CAKE-BNB 18.5% APY, TraderJoe AVAX-USDC 22.1% APY, SpookySwap BOO-FTM 28.3% APY. Note: Higher APY carries increased impermanent loss and smart contract risks.",
          actions: ["YIELD_SEARCH"]
        }
      }
    ]
  ]
};
function extractYieldCriteriaLegacy(query) {
  const searchText = query.toLowerCase();
  const criteria = {
    assets: [],
    protocols: [],
    chains: [],
    minApy: 0,
    maxApy: 1e3,
    riskLevel: "any"
  };
  const assetKeywords = {
    usdc: "usdc",
    usdt: "usdt",
    dai: "dai",
    eth: "eth",
    weth: "weth",
    btc: "btc",
    wbtc: "wbtc",
    matic: "matic",
    avax: "avax",
    bnb: "bnb",
    stablecoin: ["usdc", "usdt", "dai", "frax", "busd"]
  };
  for (const [keyword, assets] of Object.entries(assetKeywords)) {
    if (searchText.includes(keyword)) {
      criteria.assets.push(...Array.isArray(assets) ? assets : [assets]);
    }
  }
  const protocolKeywords = {
    aave: "aave",
    compound: "compound",
    uniswap: "uniswap",
    sushiswap: "sushiswap",
    pancakeswap: "pancakeswap",
    curve: "curve",
    yearn: "yearn",
    convex: "convex",
    lido: "lido",
    maker: "maker"
  };
  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {
    if (searchText.includes(keyword)) {
      criteria.protocols.push(protocol);
    }
  }
  const chainKeywords = {
    ethereum: "Ethereum",
    polygon: "Polygon",
    arbitrum: "Arbitrum",
    optimism: "Optimism",
    avalanche: "Avalanche",
    bsc: "BSC",
    fantom: "Fantom",
    solana: "Solana"
  };
  for (const [keyword, chain] of Object.entries(chainKeywords)) {
    if (searchText.includes(keyword)) {
      criteria.chains.push(chain);
    }
  }
  const apyMatch = searchText.match(/(\d+)%?\s*(apy|apr|yield)/i);
  if (apyMatch) {
    const apy = parseInt(apyMatch[1]);
    if (searchText.includes("above") || searchText.includes("over") || searchText.includes("high")) {
      criteria.minApy = apy;
    } else if (searchText.includes("under") || searchText.includes("below")) {
      criteria.maxApy = apy;
    }
  }
  if (searchText.includes("safe") || searchText.includes("stable") || searchText.includes("low risk")) {
    criteria.riskLevel = "low";
  } else if (searchText.includes("high risk") || searchText.includes("aggressive")) {
    criteria.riskLevel = "high";
  }
  return criteria;
}
function buildYieldData(criteria, allYields) {
  const data = {
    yields: [],
    totalTvl: 0,
    averageApy: 0,
    timestamp: Date.now()
  };
  let filteredYields = allYields;
  if (criteria.assets && criteria.assets.length > 0) {
    filteredYields = filteredYields.filter((y) => {
      const symbol = y.symbol?.toLowerCase() || "";
      const underlying = y.underlyingTokens?.map((t) => t.toLowerCase()) || [];
      return criteria.assets.some((asset) => {
        const searchAsset = asset.toLowerCase();
        if (searchAsset === "stablecoins") {
          return ["usdc", "usdt", "dai", "frax", "busd"].some(
            (stable) => symbol.includes(stable) || underlying.some((u) => u.includes(stable))
          );
        }
        return symbol.includes(searchAsset) || underlying.some((u) => u.includes(searchAsset));
      });
    });
  }
  if (criteria.protocols && criteria.protocols.length > 0) {
    filteredYields = filteredYields.filter(
      (y) => criteria.protocols.some(
        (protocol) => y.project?.toLowerCase().includes(protocol.toLowerCase())
      )
    );
  }
  if (criteria.chains && criteria.chains.length > 0) {
    filteredYields = filteredYields.filter(
      (y) => criteria.chains.some(
        (chain) => y.chain?.toLowerCase().includes(chain.toLowerCase())
      )
    );
  }
  filteredYields = filteredYields.filter((y) => {
    const apy = y.apy || 0;
    return apy >= (criteria.minApy || 0) && apy <= (criteria.maxApy || 1e3);
  });
  if (criteria.minTvl && criteria.minTvl > 0) {
    filteredYields = filteredYields.filter(
      (y) => (y.tvlUsd || 0) >= criteria.minTvl
    );
  }
  if (criteria.riskTolerance === "low") {
    filteredYields = filteredYields.filter((y) => {
      const apy = y.apy || 0;
      const tvl = y.tvlUsd || 0;
      return apy < 15 && tvl > 1e6;
    });
  } else if (criteria.riskTolerance === "high") {
    filteredYields = filteredYields.filter((y) => {
      const apy = y.apy || 0;
      return apy > 20;
    });
  }
  const sortBy = criteria.sortBy || "apy";
  if (sortBy === "apy") {
    filteredYields = filteredYields.sort((a, b) => (b.apy || 0) - (a.apy || 0));
  } else if (sortBy === "tvl") {
    filteredYields = filteredYields.sort(
      (a, b) => (b.tvlUsd || 0) - (a.tvlUsd || 0)
    );
  } else if (sortBy === "project") {
    filteredYields = filteredYields.sort(
      (a, b) => (a.project || "").localeCompare(b.project || "")
    );
  }
  filteredYields = filteredYields.slice(0, criteria.limit || 15);
  filteredYields.forEach((yieldPool) => {
    data.yields.push({
      pool: yieldPool.pool,
      project: yieldPool.project || "Unknown",
      symbol: yieldPool.symbol || "Unknown",
      chain: yieldPool.chain || "Unknown",
      tvlUsd: yieldPool.tvlUsd || 0,
      apy: yieldPool.apy || 0,
      apyBase: yieldPool.apyBase || 0,
      apyReward: yieldPool.apyReward || 0,
      rewardTokens: yieldPool.rewardTokens || [],
      underlyingTokens: yieldPool.underlyingTokens || [],
      poolMeta: yieldPool.poolMeta || "",
      formatted: formatYieldData(yieldPool)
    });
    data.totalTvl += yieldPool.tvlUsd || 0;
  });
  if (data.yields.length > 0) {
    data.averageApy = data.yields.reduce((sum, y) => sum + y.apy, 0) / data.yields.length;
  }
  return data;
}
function formatYieldData(yieldPool) {
  const apy = (yieldPool.apy || 0).toFixed(1);
  const tvl = formatLargeNumber(yieldPool.tvlUsd || 0);
  return `${yieldPool.project} ${yieldPool.symbol}: ${apy}% APY, $${tvl} TVL`;
}
function formatLargeNumber(num) {
  if (num >= 1e9) return (num / 1e9).toFixed(1) + "B";
  if (num >= 1e6) return (num / 1e6).toFixed(1) + "M";
  if (num >= 1e3) return (num / 1e3).toFixed(1) + "K";
  return num.toFixed(0);
}

// src/actions/marketTrendsAction.ts
import {
  logger as logger4,
  ModelType as ModelType3
} from "@elizaos/core";
var extractMarketTrendsTemplate = `Extract market trends analysis parameters from the user's request for DeFi market trend data.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /protocols endpoint returns protocol data with tvl, change_1d, change_7d, category
- /chains endpoint returns chain data with tvl (no change data available)
- /overview/fees and /overview/dexs endpoints provide additional performance metrics
- Protocol categories: "Dexs", "Lending", "Liquid Staking", "Derivatives", "Yield", "CDP", "Bridge"
- Chain names in proper case: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"

The user might express market trends requests in various ways:
- "Best performing DeFi protocols this week" \u2192 focus: "protocols", timeframe: "7d", direction: "winners"
- "Chain performance trends last 30 days" \u2192 focus: "chains", timeframe: "30d", analysisType: "performance"
- "DEX sector analysis" \u2192 focus: "categories", category: "Dexs", sortBy: "tvl"
- "Top 5 lending protocols by TVL" \u2192 focus: "protocols", category: "Lending", sortBy: "tvl", limit: 5
- "Market losers today" \u2192 direction: "losers", timeframe: "1d"
- "DeFi market overview" \u2192 focus: "all", analysisType: "overview"
- "Volume leaders this month" \u2192 sortBy: "volume", timeframe: "30d"

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "focus": "protocols/chains/categories/all (what to analyze)",
  "timeframe": "1d/7d/30d (time period for analysis)",
  "direction": "winners/losers/all (performance filter)",
  "category": "Dexs/Lending/Liquid Staking/Derivatives if mentioned",
  "sortBy": "tvl/volume/change (how to rank results)",
  "analysisType": "performance/overview/ranking/comparison",
  "limit": number (how many results, default 10),
  "includeMetrics": ["tvl/volume/fees/change if specifically requested"],
  "marketScope": "overall/sector/chain if specified"
}

Return only the JSON object, no other text.`;
var marketTrendsAction = {
  name: "MARKET_TRENDS",
  similes: [
    "MARKET_ANALYSIS",
    "TREND_ANALYSIS",
    "MARKET_OVERVIEW",
    "DEFI_TRENDS",
    "SECTOR_PERFORMANCE",
    "CHAIN_TRENDS",
    "PROTOCOL_TRENDS",
    "TVL_TRENDS",
    "MARKET_SENTIMENT",
    "PERFORMANCE_ANALYSIS"
  ],
  description: `Simple market trends data fetcher. This action:
1. Extracts trend analysis criteria from user queries using LLM
2. Fetches current market trend data from DeFiLlama API
3. Returns clean, structured trend data for analysis or display
4. Supports filtering by time period, category, and specific metrics

USE WHEN: User asks about market trends, sector performance, protocol rankings, or DeFi market analysis.
RETURNS: Raw trend data without extensive analysis - focused on data retrieval.`,
  validate: async (runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    const trendKeywords = [
      "trend",
      "trends",
      "market",
      "performance",
      "growth",
      "decline",
      "sector",
      "category",
      "ranking",
      "winners",
      "losers",
      "best performing",
      "worst performing",
      "market overview",
      "defi market",
      "tvl growth",
      "volume trends",
      "chain performance",
      "protocol ranking"
    ];
    return trendKeywords.some((keyword) => text.includes(keyword));
  },
  handler: async (runtime, message, state, options, callback) => {
    try {
      logger4.info("[MARKET_TRENDS] Starting market trends data fetch");
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const userQuestion = message.content.text || "";
      let extractedParams;
      if (options?.trendParams) {
        extractedParams = options.trendParams;
      } else {
        const prompt = extractMarketTrendsTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType3.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              focus: parsed.focus || "protocols",
              timeframe: parsed.timeframe || "7d",
              direction: parsed.direction || "all",
              category: parsed.category || void 0,
              sortBy: parsed.sortBy || "tvl",
              analysisType: parsed.analysisType || "performance",
              limit: parsed.limit || 10,
              includeMetrics: parsed.includeMetrics || [],
              marketScope: parsed.marketScope || "overall"
            };
            logger4.info(
              `[MARKET_TRENDS] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger4.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            extractedParams = {
              ...extractTrendCriteriaLegacy(userQuestion),
              analysisType: "performance",
              includeMetrics: [],
              marketScope: "overall"
            };
          }
        } else {
          logger4.warn(
            "[MARKET_TRENDS] No LLM response received, falling back to regex"
          );
          extractedParams = {
            ...extractTrendCriteriaLegacy(userQuestion),
            analysisType: "performance",
            includeMetrics: [],
            marketScope: "overall"
          };
        }
      }
      logger4.info(
        `[MARKET_TRENDS] Fetching trends with criteria: ${JSON.stringify(extractedParams)}`
      );
      const [protocols, chains, dexVolumes, protocolFees] = await Promise.all([
        defiLlamaService.getProtocols(),
        defiLlamaService.getChains(),
        defiLlamaService.getDexVolumes({
          excludeTotalDataChart: true,
          excludeTotalDataChartBreakdown: true
        }).catch(() => null),
        defiLlamaService.getProtocolFees({
          excludeTotalDataChart: true,
          excludeTotalDataChartBreakdown: true,
          dataType: "dailyFees"
        }).catch(() => null)
      ]);
      const validatedProtocols = Array.isArray(protocols) ? protocols : [];
      const validatedChains = Array.isArray(chains) ? chains : [];
      const validatedDexVolumes = Array.isArray(dexVolumes) ? dexVolumes : null;
      const validatedProtocolFees = Array.isArray(protocolFees) ? protocolFees : null;
      if (validatedProtocols.length === 0) {
        throw new Error("No market data available from API");
      }
      const trendData = buildTrendDataLLM(
        extractedParams,
        validatedProtocols,
        validatedChains,
        validatedDexVolumes,
        validatedProtocolFees
      );
      const response = await runtime.useModel(ModelType3.LARGE, {
        prompt: `Respond concisely with market trends analysis based on data: ${JSON.stringify(trendData)}
        and user query: ${JSON.stringify(message.content)}`
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze market trends at this time.",
          actions: ["MARKET_TRENDS"],
          source: message.content.source
        });
      }
      return {
        text: response,
        success: true,
        data: {
          actionName: "MARKET_TRENDS",
          extractedParams,
          trendData,
          trendDataFetched: true,
          trendsFound: trendData.trends.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      logger4.error("[MARKET_TRENDS] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      if (callback) {
        await callback({
          text: `\u274C Failed to fetch trend data: ${errorMessage}`,
          actions: ["MARKET_TRENDS"],
          source: message.content.source
        });
      }
      return {
        text: `Error fetching trend data: ${errorMessage}`,
        success: false,
        error: error instanceof Error ? error : new Error(errorMessage),
        data: {
          actionName: "MARKET_TRENDS",
          error: errorMessage,
          trendDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "What are the best performing DeFi protocols this week?"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Top DeFi performers this week: Aave +12.3% (rank #2), Uniswap +8.7% (rank #5), Curve +15.2% (rank #7). Lending and DEX categories showing strong growth with increased TVL inflows.",
          actions: ["MARKET_TRENDS"]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Show me chain performance trends over the last 30 days"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "30-day chain trends: Arbitrum +18.5% TVL growth, Polygon +12.1%, Base +22.3%. Ethereum stable at +2.1%. L2s outperforming with increased adoption and lower fees driving growth.",
          actions: ["MARKET_TRENDS"]
        }
      }
    ]
  ]
};
function buildTrendDataLLM(params, protocols, chains, dexVolumes, protocolFees) {
  const data = {
    trends: [],
    totalTvl: 0,
    marketSentiment: "neutral",
    timestamp: Date.now()
  };
  let items = [];
  if (params.focus === "chains") {
    items = chains.map((chain) => ({
      name: chain.name,
      type: "chain",
      tvl: chain.tvl || 0,
      change_1d: 0,
      // chains don't have change data in basic endpoint
      change_7d: 0,
      rank: 0
    }));
  } else if (params.focus === "categories") {
    const categoryTvl = {};
    protocols.forEach((protocol) => {
      const category = protocol.category || "Other";
      if (!categoryTvl[category]) {
        categoryTvl[category] = {
          name: category,
          type: "category",
          tvl: 0,
          change_1d: 0,
          change_7d: 0,
          count: 0
        };
      }
      categoryTvl[category].tvl += protocol.tvl || 0;
      categoryTvl[category].change_1d += protocol.change_1d || 0;
      categoryTvl[category].change_7d += protocol.change_7d || 0;
      categoryTvl[category].count += 1;
    });
    items = Object.values(categoryTvl).map((cat) => ({
      ...cat,
      change_1d: cat.count > 0 ? cat.change_1d / cat.count : 0,
      change_7d: cat.count > 0 ? cat.change_7d / cat.count : 0
    }));
  } else {
    items = protocols.map((protocol, index) => ({
      name: protocol.name,
      type: "protocol",
      tvl: protocol.tvl || 0,
      change_1d: protocol.change_1d || 0,
      change_7d: protocol.change_7d || 0,
      rank: index + 1,
      category: protocol.category
    }));
  }
  if (params.category) {
    items = items.filter(
      (item) => item.category === params.category || item.name === params.category
    );
  }
  const getChangeValue = (item, timeframe) => {
    if (timeframe === "1d") return item.change_1d;
    if (timeframe === "7d") return item.change_7d;
    return item.change_1d;
  };
  if (params.direction === "winners") {
    items = items.filter((item) => getChangeValue(item, params.timeframe) > 0);
  } else if (params.direction === "losers") {
    items = items.filter((item) => getChangeValue(item, params.timeframe) < 0);
  }
  if (params.sortBy === "tvl") {
    items.sort((a, b) => (b.tvl || 0) - (a.tvl || 0));
  } else if (params.sortBy === "change") {
    items.sort(
      (a, b) => getChangeValue(b, params.timeframe) - getChangeValue(a, params.timeframe)
    );
  } else if (params.sortBy === "volume" && dexVolumes) {
    items.forEach((item) => {
      const volumeData = findMatchingProtocolByName(dexVolumes, item.name);
      if (volumeData) {
        item.volume = volumeData.total24h || 0;
      }
    });
    items.sort((a, b) => (b.volume || 0) - (a.volume || 0));
  } else {
    items.sort(
      (a, b) => getChangeValue(b, params.timeframe) - getChangeValue(a, params.timeframe)
    );
  }
  items = items.slice(0, params.limit);
  items.forEach((item) => {
    data.trends.push({
      name: item.name,
      type: item.type,
      tvl: item.tvl,
      change_1d: item.change_1d,
      change_7d: item.change_7d,
      rank: item.rank,
      category: item.category,
      formatted: formatTrendDataLLM(item, params.timeframe)
    });
    data.totalTvl += item.tvl || 0;
  });
  const avgChange = items.length > 0 ? items.reduce(
    (sum, item) => sum + getChangeValue(item, params.timeframe),
    0
  ) / items.length : 0;
  data.marketSentiment = avgChange > 5 ? "bullish" : avgChange < -5 ? "bearish" : "neutral";
  return data;
}
function extractTrendCriteriaLegacy(query) {
  const searchText = query.toLowerCase();
  const criteria = {
    timeframe: "7d",
    // default
    focus: "protocols",
    // protocols, chains, categories, all
    category: void 0,
    sortBy: "tvl",
    // tvl, volume, change
    direction: "all",
    // winners, losers, all
    limit: 10
  };
  if (searchText.includes("24h") || searchText.includes("24 hour") || searchText.includes("today")) {
    criteria.timeframe = "1d";
  } else if (searchText.includes("week") || searchText.includes("7d") || searchText.includes("7 day")) {
    criteria.timeframe = "7d";
  } else if (searchText.includes("month") || searchText.includes("30d") || searchText.includes("30 day")) {
    criteria.timeframe = "30d";
  }
  if (searchText.includes("chain") || searchText.includes("blockchain") || searchText.includes("network")) {
    criteria.focus = "chains";
  } else if (searchText.includes("category") || searchText.includes("sector")) {
    criteria.focus = "categories";
  } else if (searchText.includes("protocol") || searchText.includes("project")) {
    criteria.focus = "protocols";
  }
  const categoryKeywords = {
    dex: "Dexs",
    lending: "Lending",
    staking: "Liquid Staking",
    derivatives: "Derivatives",
    yield: "Yield",
    bridge: "Bridge",
    cdp: "CDP",
    insurance: "Insurance"
  };
  for (const [keyword, category] of Object.entries(categoryKeywords)) {
    if (searchText.includes(keyword)) {
      criteria.category = category;
      break;
    }
  }
  if (searchText.includes("winner") || searchText.includes("best") || searchText.includes("top") || searchText.includes("gain")) {
    criteria.direction = "winners";
  } else if (searchText.includes("loser") || searchText.includes("worst") || searchText.includes("declining") || searchText.includes("loss")) {
    criteria.direction = "losers";
  }
  if (searchText.includes("volume") || searchText.includes("trading")) {
    criteria.sortBy = "volume";
  } else if (searchText.includes("tvl") || searchText.includes("value locked")) {
    criteria.sortBy = "tvl";
  }
  return criteria;
}
function formatTrendDataLLM(item, timeframe) {
  const getChangeForFormat = (item2, timeframe2) => {
    if (timeframe2 === "1d") return item2.change_1d;
    if (timeframe2 === "7d") return item2.change_7d;
    return item2.change_1d;
  };
  const change = getChangeForFormat(item, timeframe).toFixed(1);
  const tvl = formatLargeNumber2(item.tvl || 0);
  const sign = parseFloat(change) >= 0 ? "+" : "";
  return `${item.name}: $${tvl} TVL, ${sign}${change}% (${timeframe})`;
}
function formatLargeNumber2(num) {
  if (num >= 1e12) return (num / 1e12).toFixed(1) + "T";
  if (num >= 1e9) return (num / 1e9).toFixed(1) + "B";
  if (num >= 1e6) return (num / 1e6).toFixed(1) + "M";
  if (num >= 1e3) return (num / 1e3).toFixed(1) + "K";
  return num.toFixed(0);
}
var PROTOCOL_NAME_MAPPINGS = {
  // Uniswap variations
  uniswap: ["uniswap-v3", "uniswap-v2", "uniswap"],
  uni: ["uniswap-v3", "uniswap-v2", "uniswap"],
  "uniswap v3": ["uniswap-v3"],
  "uniswap v2": ["uniswap-v2"],
  // Curve variations
  curve: ["curve-dex", "curve"],
  crv: ["curve-dex", "curve"],
  // Compound variations
  compound: ["compound-v3", "compound-v2", "compound"],
  comp: ["compound-v3", "compound-v2", "compound"],
  // Aave variations
  aave: ["aave-v3", "aave-v2", "aave"],
  "aave v3": ["aave-v3"],
  "aave v2": ["aave-v2"],
  // Balancer variations
  balancer: ["balancer-v2", "balancer"],
  bal: ["balancer-v2", "balancer"],
  // SushiSwap variations
  sushiswap: ["sushiswap", "sushi"],
  sushi: ["sushiswap", "sushi"],
  // PancakeSwap variations
  pancakeswap: ["pancakeswap", "pancake"],
  pancake: ["pancakeswap", "pancake"],
  pcs: ["pancakeswap"],
  // 1inch variations
  "1inch": ["1inch", "1inch-liquidity-protocol"],
  oneinch: ["1inch", "1inch-liquidity-protocol"],
  // MakerDAO variations
  makerdao: ["makerdao", "maker"],
  maker: ["makerdao", "maker"],
  dai: ["makerdao"],
  // Lido variations
  lido: ["lido", "lido-liquid-staking"],
  steth: ["lido"],
  // Rocket Pool variations
  "rocket pool": ["rocket-pool"],
  rocketpool: ["rocket-pool"],
  rpl: ["rocket-pool"],
  // Frax variations
  frax: ["frax-finance", "frax"],
  "frax finance": ["frax-finance"],
  // Convex variations
  convex: ["convex-finance"],
  "convex finance": ["convex-finance"],
  cvx: ["convex-finance"]
};
function findMatchingProtocolByName(protocols, targetName) {
  if (!protocols || protocols.length === 0 || !targetName) {
    return null;
  }
  const normalizedTarget = targetName.toLowerCase().trim();
  const exactMatch = protocols.find(
    (protocol) => protocol.name?.toLowerCase().trim() === normalizedTarget
  );
  if (exactMatch) {
    return exactMatch;
  }
  const mappedNames = PROTOCOL_NAME_MAPPINGS[normalizedTarget];
  if (mappedNames) {
    for (const mappedName of mappedNames) {
      const mappedMatch = protocols.find(
        (protocol) => protocol.name?.toLowerCase().trim() === mappedName.toLowerCase()
      );
      if (mappedMatch) {
        return mappedMatch;
      }
    }
    for (const mappedName of mappedNames) {
      const mappedContainsMatch = protocols.find(
        (protocol) => protocol.name?.toLowerCase().includes(mappedName.toLowerCase()) || mappedName.toLowerCase().includes(protocol.name?.toLowerCase() || "")
      );
      if (mappedContainsMatch) {
        return mappedContainsMatch;
      }
    }
  }
  if (normalizedTarget.length >= 3) {
    const containsMatch = protocols.find((protocol) => {
      const protocolName = protocol.name?.toLowerCase().trim() || "";
      return protocolName.includes(normalizedTarget) || normalizedTarget.includes(protocolName);
    });
    if (containsMatch) {
      return containsMatch;
    }
  }
  return null;
}

// src/actions/historicalDataAction.ts
import {
  logger as logger5,
  ModelType as ModelType4
} from "@elizaos/core";
var extractHistoricalTemplate = `Extract historical data analysis parameters from the user's request for time-series DeFi data.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /protocol/{protocol} endpoint returns historical TVL data with chainTvls.tvl[].{date, totalLiquidityUSD}
- /protocols endpoint returns current protocol data with tvl, category, chains
- /v2/historicalChainTvl/{chain} returns historical chain-level TVL data
- Chain names in proper case: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"
- Protocol names as returned by API: "Aave", "Uniswap", "Compound", "Curve", etc.

The user might express historical data requests in various ways:
- "Aave TVL growth over 6 months" \u2192 protocols: ["Aave"], timeframe: "6m", dataType: "tvl"
- "Compare Uniswap vs SushiSwap last year" \u2192 protocols: ["Uniswap", "SushiSwap"], timeframe: "1y", analysisType: "comparison"
- "DeFi trends last 30 days" \u2192 timeframe: "30d", analysisType: "market_overview"
- "Ethereum TVL historical performance" \u2192 chains: ["Ethereum"], timeframe: "1y", dataType: "tvl"
- "Protocol performance since January" \u2192 timeframe: "custom", analysisType: "performance"
- "Weekly growth analysis for lending protocols" \u2192 category: "Lending", timeframe: "7d", analysisType: "growth"

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "protocols": ["Protocol names if mentioned: Aave/Uniswap/Compound/Curve"],
  "chains": ["Chain names as per API: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche"],
  "timeframe": "24h/7d/30d/90d/180d/1y/custom (time period requested)",
  "dataType": "tvl/volume/fees/price (what historical data to analyze)",
  "analysisType": "growth/comparison/trends/performance/market_overview",
  "category": ["Lending/Dexs/Derivatives if mentioned"],
  "granularity": "daily/weekly/monthly (data point frequency if specified)",
  "includeBreakdown": true/false (if user wants chain/token breakdown),
  "compareToMarket": true/false (if user wants market comparison),
  "count": number (how many protocols/chains to analyze, default 10)
}

Return only the JSON object, no other text.`;
var historicalDataAction = {
  name: "HISTORICAL_DATA",
  similes: [
    "historical analysis",
    "price history",
    "tvl trends",
    "protocol growth",
    "historical comparison",
    "time series",
    "trend analysis",
    "historical performance",
    "past data",
    "historical metrics"
  ],
  validate: async (runtime, message) => {
    const userQuestion = message.content.text?.toLowerCase() || "";
    const historicalKeywords = [
      "historical",
      "history",
      "past",
      "trend",
      "growth",
      "over time",
      "time series",
      "charts",
      "performance",
      "since",
      "ago",
      "previous",
      "last week",
      "last month",
      "last year",
      "compare",
      "timeline"
    ];
    return historicalKeywords.some((keyword) => userQuestion.includes(keyword));
  },
  description: "Retrieves historical data and trends from DeFiLlama using LLM parameter extraction",
  handler: async (runtime, message, state, options, callback) => {
    logger5.info("[HISTORICAL_DATA] Starting historical data analysis");
    try {
      const userQuestion = message.content.text || "";
      let extractedParams;
      if (options?.historicalParams) {
        extractedParams = options.historicalParams;
      } else {
        const prompt = extractHistoricalTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType4.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              protocols: parsed.protocols || [],
              chains: parsed.chains || [],
              timeframe: parsed.timeframe || "30d",
              dataType: parsed.dataType || "tvl",
              analysisType: parsed.analysisType || "trends",
              category: parsed.category || [],
              granularity: parsed.granularity || "daily",
              includeBreakdown: parsed.includeBreakdown || false,
              compareToMarket: parsed.compareToMarket || false,
              count: parsed.count || 10
            };
            logger5.info(
              `[HISTORICAL_DATA] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger5.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            const timeframe = extractTimeframeFromQueryLegacy(userQuestion);
            const targetProtocols = extractProtocolsFromQueryLegacy(userQuestion);
            extractedParams = {
              protocols: targetProtocols,
              chains: [],
              timeframe,
              dataType: "tvl",
              analysisType: "trends",
              category: [],
              granularity: "daily",
              includeBreakdown: false,
              compareToMarket: false,
              count: 10
            };
          }
        } else {
          logger5.warn(
            "[HISTORICAL_DATA] No LLM response received, falling back to regex"
          );
          const timeframe = extractTimeframeFromQueryLegacy(userQuestion);
          const targetProtocols = extractProtocolsFromQueryLegacy(userQuestion);
          extractedParams = {
            protocols: targetProtocols,
            chains: [],
            timeframe,
            dataType: "tvl",
            analysisType: "trends",
            category: [],
            granularity: "daily",
            includeBreakdown: false,
            compareToMarket: false,
            count: 10
          };
        }
      }
      logger5.info(
        `[HISTORICAL_DATA] Fetching data for timeframe: ${extractedParams.timeframe}, protocols: ${extractedParams.protocols.join(", ") || "all"}`
      );
      const defiLlamaService = runtime.getService(
        DefiLlamaService.serviceType
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      let historicalData = {};
      if (extractedParams.protocols.length > 0) {
        const protocolDataPromises = extractedParams.protocols.map(
          async (protocol) => {
            try {
              const protocolSlug = protocol.toLowerCase().replace(/\s+/g, "-");
              const [protocolInfo, historicalTVL] = await Promise.all([
                defiLlamaService.getProtocol(protocolSlug),
                defiLlamaService.getHistoricalTVL(
                  protocolSlug,
                  extractedParams.timeframe
                )
              ]);
              return { protocol, protocolInfo, historicalTVL };
            } catch (error) {
              logger5.warn(
                `[HISTORICAL_DATA] Failed to fetch data for ${protocol}: ${error}`
              );
              return null;
            }
          }
        );
        const protocolResults = await Promise.allSettled(protocolDataPromises);
        historicalData.protocols = protocolResults.filter(
          (result) => result.status === "fulfilled" && result.value !== null
        ).map((result) => result.value);
      } else {
        const [protocols, chains] = await Promise.all([
          defiLlamaService.getProtocols(),
          defiLlamaService.getChains()
        ]);
        let filteredProtocols = protocols;
        if (extractedParams.category && extractedParams.category.length > 0) {
          filteredProtocols = protocols.filter(
            (p) => extractedParams.category.some(
              (cat) => p.category?.toLowerCase().includes(cat.toLowerCase())
            )
          );
        }
        historicalData.protocols = filteredProtocols.slice(
          0,
          extractedParams.count
        );
        historicalData.chains = chains.slice(0, 5);
      }
      const structuredData = buildHistoricalDataLLM(
        historicalData,
        extractedParams
      );
      logger5.info("[HISTORICAL_DATA] Data fetched and structured successfully");
      const response = await runtime.useModel(ModelType4.LARGE, {
        prompt: `Respond concisely with historical analysis based on data: ${JSON.stringify(structuredData)}

Question: ${userQuestion}

Provide insights on:
- Historical trends and patterns in the specified timeframe
- Key performance changes and growth metrics
- Significant events or inflection points
- Comparative analysis if multiple protocols mentioned

Keep response focused, data-driven, and under 150 words.`,
        temperature: 0.7,
        stop: ["<END>"]
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze historical data at this time.",
          actions: ["HISTORICAL_DATA"],
          source: message.content.source
        });
      }
      return {
        text: response || "Historical analysis completed",
        success: true,
        data: {
          actionName: "HISTORICAL_DATA",
          extractedParams,
          structuredData,
          historicalDataFetched: true,
          protocolsAnalyzed: extractedParams.protocols.length || "market overview",
          timestamp: Date.now()
        }
      };
    } catch (error) {
      const errorMessage = `Failed to fetch historical data: ${error}`;
      logger5.error(`[HISTORICAL_DATA] ${errorMessage}`);
      if (callback) {
        await callback({
          text: "I encountered an error while fetching historical data. Please try again.",
          source: "HISTORICAL_DATA"
        });
      }
      return {
        text: "Error fetching historical data. Please try again.",
        success: false,
        data: {
          actionName: "HISTORICAL_DATA",
          error: errorMessage,
          historicalDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "user",
        content: { text: "Show me Aave's TVL growth over the last 6 months" }
      },
      {
        name: "assistant",
        content: {
          text: "Here's Aave's TVL historical analysis over the past 6 months: [analysis based on latest DeFiLlama data]",
          source: "HISTORICAL_DATA"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "Compare Uniswap and SushiSwap performance over the last year"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Here's a comparative analysis of Uniswap vs SushiSwap performance over the past year: [detailed historical comparison]",
          source: "HISTORICAL_DATA"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "What are the major DeFi trends from the past 30 days?"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Based on the last 30 days of data, here are the major DeFi trends: [market trend analysis]",
          source: "HISTORICAL_DATA"
        }
      }
    ]
  ]
};
function buildHistoricalDataLLM(data, params) {
  const result = {
    timeframe: params.timeframe,
    protocolsAnalyzed: params.protocols.length > 0 ? params.protocols : "market overview",
    protocolData: [],
    marketData: null,
    summary: {
      totalProtocols: 0,
      dataPoints: 0,
      timeRange: params.timeframe
    }
  };
  if (data.protocols && data.protocols.length > 0) {
    if (params.protocols.length > 0) {
      result.protocolData = data.protocols.map(
        (item) => {
          const currentTvl = item.protocolInfo?.tvl || (item.protocolInfo?.chainTvls ? Object.values(
            item.protocolInfo.chainTvls
          ).reduce((sum, val) => sum + val, 0) : 0);
          return {
            name: item.protocol,
            currentTvl,
            category: item.protocolInfo?.category || "Unknown",
            chain: item.protocolInfo?.chains?.join(", ") || "Multi-chain",
            historicalPoints: item.historicalTVL?.length || 0,
            latestChange: calculateChangeLLM(item.historicalTVL)
          };
        }
      );
    } else {
      result.marketData = {
        protocols: data.protocols.slice(0, params.count).map(
          (protocol) => ({
            name: protocol.name,
            tvl: protocol.tvl || 0,
            category: protocol.category || "Unknown",
            change_7d: protocol.change_7d || 0
          })
        ),
        chains: data.chains?.slice(0, 5).map((chain) => ({
          name: chain.name,
          tvl: chain.tvl || 0
        })) || []
      };
    }
    result.summary.totalProtocols = data.protocols.length;
    result.summary.dataPoints = data.protocols.reduce(
      (sum, item) => sum + (item.historicalTVL?.length || 1),
      0
    );
  }
  if (data.chains && params.chains.length > 0) {
    result.summary.totalProtocols = data.chains.length;
    result.summary.dataPoints = data.chains.reduce(
      (sum, item) => sum + (item.historicalTVL?.length || 1),
      0
    );
  }
  return result;
}
function calculateChangeLLM(historicalData) {
  if (!historicalData || historicalData.length < 2) return 0;
  const latest = historicalData[historicalData.length - 1];
  const previous = historicalData[0];
  if (!latest?.totalLiquidityUSD || !previous?.totalLiquidityUSD) return 0;
  return (latest.totalLiquidityUSD - previous.totalLiquidityUSD) / previous.totalLiquidityUSD * 100;
}
function extractTimeframeFromQueryLegacy(query) {
  const lowerQuery = query.toLowerCase();
  const timeFramePatterns = {
    "24h": ["24h", "24 hour", "1 day", "today", "daily"],
    "7d": ["7d", "7 day", "week", "weekly", "last week"],
    "30d": ["30d", "30 day", "month", "monthly", "last month"],
    "90d": ["90d", "90 day", "3 month", "quarter", "quarterly"],
    "365d": ["365d", "year", "yearly", "annual", "last year", "12 month"]
  };
  for (const [period, patterns] of Object.entries(timeFramePatterns)) {
    if (patterns.some((pattern) => lowerQuery.includes(pattern))) {
      return period;
    }
  }
  return "30d";
}
function extractProtocolsFromQueryLegacy(query) {
  const protocols = [];
  const lowerQuery = query.toLowerCase();
  const protocolKeywords = {
    aave: "Aave",
    uniswap: "Uniswap",
    compound: "Compound",
    sushiswap: "SushiSwap",
    curve: "Curve",
    pancakeswap: "PancakeSwap",
    balancer: "Balancer",
    maker: "MakerDAO",
    "1inch": "1inch",
    synthetix: "Synthetix",
    yearn: "Yearn Finance",
    convex: "Convex Finance",
    lido: "Lido",
    frax: "Frax"
  };
  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {
    if (lowerQuery.includes(keyword)) {
      protocols.push(protocol);
    }
  }
  return protocols;
}

// src/actions/crossChainAction.ts
import {
  logger as logger6,
  ModelType as ModelType5
} from "@elizaos/core";
var extractCrossChainTemplate = `Extract cross-chain analysis parameters from the user's request for multi-chain DeFi analysis.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- Chain names as per /v2/chains and /bridges endpoints: "Ethereum", "Arbitrum", "Optimism", "Polygon", "Avalanche", "Fantom", "BSC"
- Bridge data uses proper case chain names in chains array
- Yield data matches chain names from /pools endpoint

The user might express cross-chain requests in various ways:
- "Compare Ethereum vs Arbitrum DeFi" \u2192 chains: ["Ethereum", "Arbitrum"], analysis: "comparison"
- "Best bridges to move assets" \u2192 analysis: "bridge", focus: ["bridge protocols"]
- "Cross-chain yield farming opportunities" \u2192 analysis: "yield", focus: ["yield farming"]
- "Arbitrage between Polygon and BSC" \u2192 chains: ["Polygon", "BSC"], analysis: "arbitrage"
- "Layer 2 protocol comparison" \u2192 chains: ["Arbitrum", "Optimism", "Polygon"], analysis: "comparison"
- "Multi-chain lending protocols" \u2192 focus: ["lending"], analysis: "comparison"
- "Migrate from Ethereum to cheaper chains" \u2192 sourceChain: "Ethereum", analysis: "migration"

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "targetChains": ["Chain names as per DeFiLlama API: Ethereum/Arbitrum/Optimism/Polygon/Avalanche/Fantom/BSC"],
  "sourceChain": "Source chain if migration mentioned",
  "analysisType": "comparison/arbitrage/yield/bridge/migration/general",
  "focusCategories": ["Category focus: lending/dex/staking/bridge/yield if mentioned"],
  "minTvlPreference": "large/medium/small/any (based on user preference)",
  "riskTolerance": "low/medium/high (if mentioned)",
  "specificProtocols": ["Protocol names if specifically mentioned"],
  "metrics": ["tvl/volume/fees/apy if specific metrics requested"],
  "timeframe": "24h/7d/30d if historical comparison mentioned",
  "includeDetails": true/false (if user wants detailed breakdown)
}

Return only the JSON object, no other text.`;
var crossChainAction = {
  name: "CROSS_CHAIN_ANALYSIS",
  similes: [
    "cross chain",
    "multi chain",
    "bridge assets",
    "chain comparison",
    "arbitrage opportunities",
    "L2 analysis",
    "chain migration",
    "cross chain yield",
    "bridge protocols",
    "multi chain defi"
  ],
  validate: async (runtime, message) => {
    const userQuestion = message.content.text?.toLowerCase() || "";
    const crossChainKeywords = [
      "cross chain",
      "multi chain",
      "bridge",
      "arbitrage",
      "l2",
      "layer 2",
      "polygon",
      "arbitrum",
      "optimism",
      "avalanche",
      "chains",
      "chain comparison",
      "migrate",
      "move assets",
      "different chains",
      "across chains"
    ];
    return crossChainKeywords.some((keyword) => userQuestion.includes(keyword));
  },
  description: "Analyzes cross-chain DeFi opportunities and comparisons using LLM-based parameter extraction",
  handler: async (runtime, message, state, options, callback) => {
    logger6.info("[CROSS_CHAIN] Starting cross-chain analysis");
    try {
      const userQuestion = message.content.text || "";
      let criteria;
      if (options?.crossChainParams) {
        criteria = options.crossChainParams;
      } else {
        const prompt = extractCrossChainTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType5.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            criteria = {
              targetChains: parsed.targetChains || [],
              analysisType: parsed.analysisType || "general",
              minTvl: parseMinTvlFromPreference(parsed.minTvlPreference),
              focusCategories: parsed.focusCategories || []
            };
            if (criteria.targetChains.length === 0) {
              if (parsed.sourceChain) {
                criteria.targetChains = [
                  parsed.sourceChain,
                  "Arbitrum",
                  "Polygon",
                  "Optimism"
                ];
              } else {
                criteria.targetChains = [
                  "Ethereum",
                  "Arbitrum",
                  "Polygon",
                  "Optimism"
                ];
              }
            }
            logger6.info(
              `[CROSS_CHAIN] LLM extracted criteria: ${JSON.stringify(criteria)}`
            );
          } catch (parseError) {
            logger6.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            criteria = extractCrossChainCriteriaLegacy(userQuestion);
          }
        } else {
          logger6.warn(
            "[CROSS_CHAIN] No LLM response received, falling back to regex"
          );
          criteria = extractCrossChainCriteriaLegacy(userQuestion);
        }
      }
      logger6.info(
        `[CROSS_CHAIN] Analyzing chains: ${criteria.targetChains.join(", ")}, type: ${criteria.analysisType}`
      );
      const defiLlamaService = runtime.getService(
        DefiLlamaService.serviceType
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const [protocols, chains, yields, bridges] = await Promise.all([
        defiLlamaService.getProtocols(),
        defiLlamaService.getChains(),
        defiLlamaService.getYields(),
        defiLlamaService.getBridges({ includeChains: true })
      ]);
      const structuredData = buildCrossChainAnalysis(
        protocols,
        chains,
        yields,
        bridges,
        criteria
      );
      logger6.info("[CROSS_CHAIN] Cross-chain analysis completed successfully");
      const response = await runtime.useModel(ModelType5.LARGE, {
        prompt: `Respond concisely with cross-chain analysis based on data: ${JSON.stringify(structuredData)}

Question: ${userQuestion}

Provide insights on:
- Key differences and opportunities across chains
- Best protocols and yields on each chain
- Bridge recommendations for asset movement
- Strategic cross-chain opportunities

Keep response focused, practical, and under 150 words.`,
        temperature: 0.7,
        stop: ["<END>"]
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze cross-chain opportunities at this time.",
          actions: ["CROSS_CHAIN_ANALYSIS"],
          source: message.content.source
        });
      }
      return {
        text: response || "Cross-chain analysis completed",
        success: true,
        data: {
          actionName: "CROSS_CHAIN_ANALYSIS",
          extractedCriteria: criteria,
          structuredData,
          crossChainAnalysisCompleted: true,
          chainsAnalyzed: structuredData.chainAnalysis.length,
          bridgesFound: structuredData.bridgeOpportunities.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      const errorMessage = `Failed to analyze cross-chain opportunities: ${error}`;
      logger6.error(`[CROSS_CHAIN] ${errorMessage}`);
      if (callback) {
        await callback({
          text: "I encountered an error while analyzing cross-chain opportunities. Please try again.",
          source: "CROSS_CHAIN_ANALYSIS"
        });
      }
      return {
        text: "Error analyzing cross-chain opportunities. Please try again.",
        success: false,
        data: {
          actionName: "CROSS_CHAIN_ANALYSIS",
          error: errorMessage,
          crossChainAnalysisCompleted: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "user",
        content: { text: "Compare DeFi opportunities on Ethereum vs Arbitrum" }
      },
      {
        name: "assistant",
        content: {
          text: "Here's a comprehensive comparison of DeFi opportunities on Ethereum vs Arbitrum: [detailed analysis]",
          source: "CROSS_CHAIN_ANALYSIS"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "What are the best bridges to move assets between chains?"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Here are the top bridges for cross-chain asset movement: [bridge recommendations with security analysis]",
          source: "CROSS_CHAIN_ANALYSIS"
        }
      }
    ],
    [
      {
        name: "user",
        content: { text: "Find cross-chain arbitrage opportunities" }
      },
      {
        name: "assistant",
        content: {
          text: "Based on current data, here are potential cross-chain arbitrage opportunities: [arbitrage analysis]",
          source: "CROSS_CHAIN_ANALYSIS"
        }
      }
    ]
  ]
};
function parseMinTvlFromPreference(preference) {
  switch (preference?.toLowerCase()) {
    case "large":
      return 5e8;
    // $500M
    case "medium":
      return 5e7;
    // $50M
    case "small":
      return 5e6;
    // $5M
    case "any":
      return 1e6;
    // $1M
    default:
      return 5e7;
  }
}
function extractCrossChainCriteriaLegacy(query) {
  const lowerQuery = query.toLowerCase();
  const chains = [];
  const chainKeywords = {
    ethereum: "Ethereum",
    arbitrum: "Arbitrum",
    optimism: "Optimism",
    polygon: "Polygon",
    avalanche: "Avalanche",
    fantom: "Fantom",
    bsc: "BSC",
    "binance smart chain": "BSC"
  };
  for (const [keyword, chain] of Object.entries(chainKeywords)) {
    if (lowerQuery.includes(keyword)) {
      chains.push(chain);
    }
  }
  if (chains.length === 0) {
    chains.push("Ethereum", "Arbitrum", "Polygon", "Optimism");
  }
  let analysisType = "general";
  if (lowerQuery.includes("compare") || lowerQuery.includes("comparison") || lowerQuery.includes("vs")) {
    analysisType = "comparison";
  } else if (lowerQuery.includes("arbitrage") || lowerQuery.includes("price difference")) {
    analysisType = "arbitrage";
  } else if (lowerQuery.includes("yield") || lowerQuery.includes("farming") || lowerQuery.includes("apy")) {
    analysisType = "yield";
  }
  let minTvl = 5e7;
  if (lowerQuery.includes("large") || lowerQuery.includes("established")) {
    minTvl = 5e8;
  } else if (lowerQuery.includes("small") || lowerQuery.includes("emerging")) {
    minTvl = 5e6;
  }
  const categories = [];
  const categoryKeywords = {
    lending: "Lending",
    dex: "Dexs",
    staking: "Liquid Staking",
    bridge: "Bridge",
    yield: "Yield"
  };
  for (const [keyword, category] of Object.entries(categoryKeywords)) {
    if (lowerQuery.includes(keyword)) {
      categories.push(category);
    }
  }
  return {
    targetChains: chains,
    analysisType,
    minTvl,
    focusCategories: categories
  };
}
function buildCrossChainAnalysis(protocols, chains, yields, bridges, criteria) {
  const targetChainData = chains.filter(
    (chain) => criteria.targetChains.some(
      (targetChain) => targetChain.toLowerCase() === chain.name.toLowerCase()
    )
  );
  const chainAnalysis = targetChainData.map((chain) => {
    const chainProtocols = protocols.filter(
      (p) => p.chain && chain.name && p.chain.toLowerCase() === chain.name.toLowerCase() && (p.tvl || 0) >= criteria.minTvl
    );
    const topProtocols = chainProtocols.sort((a, b) => (b.tvl || 0) - (a.tvl || 0)).slice(0, 5).map((p) => ({
      name: p.name,
      tvl: p.tvl || 0,
      category: p.category
    }));
    const totalTvl = chainProtocols.reduce((sum, p) => sum + (p.tvl || 0), 0);
    const totalMarketTvl = chains.reduce((sum, c) => sum + (c.tvl || 0), 0);
    return {
      name: chain.name,
      tvl: chain.tvl || 0,
      protocolCount: chainProtocols.length,
      topProtocols,
      dominanceMetrics: {
        totalMarketShare: totalMarketTvl > 0 ? (chain.tvl || 0) / totalMarketTvl * 100 : 0,
        categoryLeader: topProtocols[0]?.category || "Unknown"
      }
    };
  });
  const bridgeOpportunities = bridges.filter((bridge) => {
    if (!bridge.chains) return false;
    return criteria.targetChains.some(
      (targetChain) => bridge.chains.some(
        (bridgeChain) => bridgeChain.toLowerCase() === targetChain.toLowerCase()
      )
    );
  }).map((bridge) => ({
    name: bridge.name,
    displayName: bridge.displayName || bridge.name,
    volume24h: bridge.lastDailyVolume || 0,
    supportedChains: bridge.chains || [],
    category: "Bridge"
  })).sort((a, b) => b.volume24h - a.volume24h).slice(0, 6);
  const crossChainYields = yields.filter((yieldPool) => {
    if (!yieldPool.chain) return false;
    if (!criteria.targetChains.some(
      (targetChain) => targetChain.toLowerCase() === yieldPool.chain.toLowerCase()
    ))
      return false;
    if (yieldPool.tvlUsd < criteria.minTvl * 0.1) return false;
    return true;
  }).map((yieldPool) => ({
    protocol: yieldPool.project,
    chain: yieldPool.chain,
    apy: yieldPool.apy,
    tvl: yieldPool.tvlUsd,
    category: "Yield",
    riskLevel: assessCrossChainYieldRisk(yieldPool)
  })).sort((a, b) => b.apy - a.apy).slice(0, 8);
  const totalTvlAcrossChains = chainAnalysis.reduce(
    (sum, chain) => sum + chain.tvl,
    0
  );
  const totalProtocols = chainAnalysis.reduce(
    (sum, chain) => sum + chain.protocolCount,
    0
  );
  const averageYield = crossChainYields.length > 0 ? crossChainYields.reduce((sum, y) => sum + y.apy, 0) / crossChainYields.length : 0;
  const topChainByTvl = chainAnalysis.length > 0 ? chainAnalysis.sort((a, b) => b.tvl - a.tvl)[0].name : "Unknown";
  return {
    analysisType: criteria.analysisType,
    targetChains: criteria.targetChains,
    chainAnalysis,
    bridgeOpportunities,
    crossChainYields,
    summary: {
      totalTvlAcrossChains,
      totalProtocols,
      averageYield,
      topChainByTvl
    }
  };
}
function assessCrossChainYieldRisk(yieldPool) {
  let riskScore = 0;
  if (yieldPool.apy > 50) riskScore += 2;
  else if (yieldPool.apy > 20) riskScore += 1;
  if (yieldPool.tvlUsd < 5e6) riskScore += 2;
  else if (yieldPool.tvlUsd < 25e6) riskScore += 1;
  if (riskScore <= 0) return "low";
  if (riskScore <= 2) return "medium";
  return "high";
}

// src/actions/feesVolumeAction.ts
import {
  logger as logger7,
  ModelType as ModelType6
} from "@elizaos/core";
var extractFeesVolumeTemplate = `Extract fees and volume analysis parameters from the user's request for protocol economics data.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /overview/fees endpoint returns {protocols: []} with protocol names, total24h, revenue24h, change_1d, chains
- /overview/dexs endpoint returns {protocols: []} with protocol names, total24h, total7d, change_1d, change_7d, chains
- Chain names in proper case: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"
- Protocol names as returned by API: "Uniswap", "Aave", "Compound", "Curve", etc.

The user might express fees/volume requests in various ways:
- "Uniswap fees analysis" \u2192 protocols: ["Uniswap"], analysisType: "fees"
- "DEX trading volumes" \u2192 analysisType: "volume", category: "dex"
- "Ethereum protocol fees vs volume" \u2192 chains: ["Ethereum"], analysisType: "both"
- "Compare Aave and Compound revenue" \u2192 protocols: ["Aave", "Compound"], analysisType: "fees"
- "Top 5 protocols by volume" \u2192 count: 5, sortBy: "volume", analysisType: "volume"
- "Protocol economics on Polygon" \u2192 chains: ["Polygon"], analysisType: "both"
- "Daily fees for lending protocols" \u2192 category: "lending", analysisType: "fees"

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "protocols": ["Protocol names if mentioned: Uniswap/Aave/Compound/Curve"],
  "chains": ["Chain names as per API: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche"],
  "analysisType": "fees/volume/both (what user wants to analyze)",
  "category": ["dex/lending/derivatives if mentioned"],
  "timeframe": "24h/7d/30d (time period if specified)",
  "metrics": ["revenue/volume/fees/efficiency if specifically requested"],
  "sortBy": "fees/volume/name/change (how to sort results)",
  "count": number (how many results, default 10),
  "includeBreakdown": true/false (if user wants detailed breakdown),
  "compareMode": true/false (if user wants comparison analysis)
}

Return only the JSON object, no other text.`;
var feesVolumeAction = {
  name: "FEE_VOLUME_DATA",
  similes: [
    "protocol fees",
    "trading volume",
    "revenue analysis",
    "dex volume",
    "protocol economics",
    "fee comparison",
    "volume trends",
    "protocol profitability",
    "trading activity",
    "fee structure"
  ],
  validate: async (runtime, message) => {
    const userQuestion = message.content.text?.toLowerCase() || "";
    const feesVolumeKeywords = [
      "fees",
      "revenue",
      "volume",
      "trading",
      "economics",
      "profitability",
      "fee structure",
      "daily fees",
      "trading volume",
      "protocol revenue",
      "dex volume",
      "fee comparison",
      "volume analysis",
      "earnings"
    ];
    return feesVolumeKeywords.some((keyword) => userQuestion.includes(keyword));
  },
  description: "Retrieves protocol fees and trading volume data from DeFiLlama using LLM parameter extraction",
  handler: async (runtime, message, state, options, callback) => {
    logger7.info("[FEES_VOLUME] Starting fees and volume data action");
    try {
      const userQuestion = message.content.text || "";
      let extractedParams;
      if (options?.feesVolumeParams) {
        extractedParams = options.feesVolumeParams;
      } else {
        const prompt = extractFeesVolumeTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType6.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              protocols: parsed.protocols || [],
              chains: parsed.chains || [],
              analysisType: parsed.analysisType || "both",
              category: parsed.category || [],
              timeframe: parsed.timeframe || "24h",
              metrics: parsed.metrics || [],
              sortBy: parsed.sortBy || "volume",
              count: parsed.count || 10,
              includeBreakdown: parsed.includeBreakdown || false,
              compareMode: parsed.compareMode || false
            };
            logger7.info(
              `[FEES_VOLUME] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger7.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            const chainFilter2 = extractChainFromQueryLegacy(userQuestion);
            const targetProtocols = extractProtocolsFromQueryLegacy2(userQuestion);
            extractedParams = {
              protocols: targetProtocols,
              chains: chainFilter2 ? [chainFilter2] : [],
              analysisType: "both",
              category: [],
              timeframe: "24h",
              metrics: [],
              sortBy: "volume",
              count: 10,
              includeBreakdown: false,
              compareMode: false
            };
          }
        } else {
          logger7.warn(
            "[FEES_VOLUME] No LLM response received, falling back to regex"
          );
          const chainFilter2 = extractChainFromQueryLegacy(userQuestion);
          const targetProtocols = extractProtocolsFromQueryLegacy2(userQuestion);
          extractedParams = {
            protocols: targetProtocols,
            chains: chainFilter2 ? [chainFilter2] : [],
            analysisType: "both",
            category: [],
            timeframe: "24h",
            metrics: [],
            sortBy: "volume",
            count: 10,
            includeBreakdown: false,
            compareMode: false
          };
        }
      }
      const chainFilter = extractedParams.chains && extractedParams.chains.length > 0 ? extractedParams.chains[0] : null;
      logger7.info(
        `[FEES_VOLUME] Fetching data for chain: ${chainFilter || "all"}, analysis: ${extractedParams.analysisType}`
      );
      const defiLlamaService = runtime.getService(
        DefiLlamaService.serviceType
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const [feesData, volumeData] = await Promise.all([
        chainFilter ? defiLlamaService.getProtocolFeesByChain(chainFilter, {
          excludeTotalDataChart: true,
          excludeTotalDataChartBreakdown: true,
          dataType: "dailyFees"
        }) : defiLlamaService.getProtocolFees({
          excludeTotalDataChart: true,
          excludeTotalDataChartBreakdown: true,
          dataType: "dailyFees"
        }),
        chainFilter ? defiLlamaService.getDexVolumesByChain(chainFilter, {
          excludeTotalDataChart: true,
          excludeTotalDataChartBreakdown: true
        }) : defiLlamaService.getDexVolumes({
          excludeTotalDataChart: true,
          excludeTotalDataChartBreakdown: true
        })
      ]);
      const filteredData = filterFeesVolumeDataLLM(
        feesData,
        volumeData,
        extractedParams
      );
      const structuredData = buildFeesVolumeDataLLM(
        filteredData,
        extractedParams
      );
      logger7.info("[FEES_VOLUME] Data fetched and structured successfully");
      const response = await runtime.useModel(ModelType6.LARGE, {
        prompt: `Respond concisely with fees and volume analysis based on data: ${JSON.stringify(structuredData)}

Question: ${userQuestion}

Provide insights on:
- Protocol revenue trends and sustainability
- Trading volume patterns and market share
- Fee efficiency and competitive positioning
- Chain-specific performance if relevant

Keep response focused, data-driven, and under 150 words.`,
        temperature: 0.7,
        stop: ["<END>"]
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze fees and volume data at this time.",
          actions: ["FEE_VOLUME_DATA"],
          source: message.content.source
        });
      }
      return {
        text: response || "Analysis completed",
        success: true,
        data: {
          actionName: "FEES_VOLUME_DATA",
          extractedParams,
          structuredData,
          feesVolumeDataFetched: true,
          protocolsAnalyzed: extractedParams.protocols.length || "all",
          chainFilterUsed: chainFilter || "all",
          timestamp: Date.now()
        }
      };
    } catch (error) {
      const errorMessage = `Failed to fetch fees and volume data: ${error}`;
      logger7.error(`[FEES_VOLUME] ${errorMessage}`);
      if (callback) {
        await callback({
          text: "I encountered an error while fetching fees and volume data. Please try again.",
          source: "FEE_VOLUME_DATA"
        });
      }
      return {
        text: "Error fetching fees and volume data. Please try again.",
        success: false,
        data: {
          actionName: "FEES_VOLUME_DATA",
          error: errorMessage,
          feesVolumeDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "user",
        content: { text: "Show me the fee revenue for Uniswap and Aave" }
      },
      {
        name: "assistant",
        content: {
          text: "Here's the current fee revenue analysis for Uniswap and Aave: [analysis based on latest DeFiLlama data]",
          source: "FEE_VOLUME_DATA"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "Which protocols generate the most trading volume on Ethereum?"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Based on the latest data, here are the top volume-generating protocols on Ethereum: [detailed breakdown]",
          source: "FEE_VOLUME_DATA"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "Compare DEX trading volumes across different chains"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Here's a comparison of DEX trading volumes across major chains: [cross-chain analysis]",
          source: "FEE_VOLUME_DATA"
        }
      }
    ]
  ]
};
function filterFeesVolumeDataLLM(feesData, volumeData, params) {
  let filteredFees = feesData;
  let filteredVolume = volumeData;
  if (params.protocols && params.protocols.length > 0) {
    if (Array.isArray(feesData)) {
      filteredFees = feesData.filter(
        (item) => params.protocols.some(
          (protocol) => item.name?.toLowerCase().includes(protocol.toLowerCase())
        )
      );
    }
    if (Array.isArray(volumeData)) {
      filteredVolume = volumeData.filter(
        (item) => params.protocols.some(
          (protocol) => item.name?.toLowerCase().includes(protocol.toLowerCase())
        )
      );
    }
  }
  if (params.category && params.category.length > 0) {
    if (Array.isArray(feesData)) {
      filteredFees = feesData.filter(
        (item) => params.category.some(
          (cat) => item.category?.toLowerCase().includes(cat.toLowerCase())
        )
      );
    }
  }
  return {
    fees: filteredFees,
    volume: filteredVolume
  };
}
function buildFeesVolumeDataLLM(data, params) {
  const result = {
    criteria: {
      targetProtocols: params.protocols || [],
      chainFilter: params.chains && params.chains.length > 0 ? params.chains[0] : null,
      analysisType: params.analysisType || "both"
    },
    protocolFees: [],
    dexVolumes: [],
    summary: {
      totalDailyFees: 0,
      totalDailyVolume: 0,
      protocolCount: 0,
      avgFeeEfficiency: 0
    }
  };
  if (Array.isArray(data.fees)) {
    let feesArray = data.fees;
    if (params.sortBy === "fees") {
      feesArray = feesArray.sort(
        (a, b) => (b.total24h || 0) - (a.total24h || 0)
      );
    }
    result.protocolFees = feesArray.slice(0, params.count || 10).map((protocol) => ({
      name: protocol.name || "Unknown",
      total24h: protocol.total24h || 0,
      revenue24h: protocol.revenue24h || 0,
      change_1d: protocol.change_1d || 0,
      category: protocol.category || "Unknown"
    }));
    result.summary.protocolCount = data.fees.length;
    result.summary.totalDailyFees = data.fees.reduce(
      (sum, p) => sum + (p.total24h || 0),
      0
    );
  }
  if (Array.isArray(data.volume)) {
    let volumeArray = data.volume;
    if (params.sortBy === "volume") {
      volumeArray = volumeArray.sort(
        (a, b) => (b.total24h || 0) - (a.total24h || 0)
      );
    }
    result.dexVolumes = volumeArray.slice(0, params.count || 10).map((dex) => ({
      name: dex.name || "Unknown",
      total24h: dex.total24h || 0,
      total7d: dex.total7d || 0,
      change_1d: dex.change_1d || 0,
      change_7d: dex.change_7d || 0
    }));
    result.summary.totalDailyVolume = data.volume.reduce(
      (sum, d) => sum + (d.total24h || 0),
      0
    );
  }
  return result;
}
function extractChainFromQueryLegacy(query) {
  const chainKeywords = {
    ethereum: "Ethereum",
    polygon: "Polygon",
    bsc: "BSC",
    "binance smart chain": "BSC",
    arbitrum: "Arbitrum",
    optimism: "Optimism",
    avalanche: "Avalanche",
    solana: "Solana",
    fantom: "Fantom"
  };
  const lowerQuery = query.toLowerCase();
  for (const [keyword, chain] of Object.entries(chainKeywords)) {
    if (lowerQuery.includes(keyword)) {
      return chain;
    }
  }
  return null;
}
function extractProtocolsFromQueryLegacy2(query) {
  const protocols = [];
  const lowerQuery = query.toLowerCase();
  const protocolKeywords = {
    uniswap: "Uniswap",
    aave: "Aave",
    compound: "Compound",
    sushiswap: "SushiSwap",
    curve: "Curve",
    pancakeswap: "PancakeSwap",
    balancer: "Balancer",
    "1inch": "1inch",
    "0x": "0x",
    dydx: "dYdX",
    gmx: "GMX",
    synthetix: "Synthetix"
  };
  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {
    if (lowerQuery.includes(keyword)) {
      protocols.push(protocol);
    }
  }
  return protocols;
}

// src/actions/priceDataAction.ts
import {
  logger as logger8,
  ModelType as ModelType7
} from "@elizaos/core";
var extractTokensTemplate = `Extract token information from the user's request for cryptocurrency price data.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- Chain identifiers must be lowercase: ethereum, bsc, polygon, arbitrum, optimism, avax, fantom
- Token format: {chain}:{address} (e.g., "ethereum:0x123...", "polygon:0x456...")  
- CoinGecko format: coingecko:{id} (e.g., "coingecko:ethereum", "coingecko:bitcoin")
- All chain names in API parameters MUST be lowercase as per DeFiLlama API spec

The user might express price requests in various ways:
- "What's the price of ETH?" \u2192 token: "ethereum"
- "Show me BTC and ETH prices" \u2192 tokens: ["bitcoin", "ethereum"]
- "How much is 0x1234...abcd worth on Polygon?" \u2192 contract address with chain
- "What's USDC trading at?" \u2192 stablecoin symbol
- "Check the value of UNI and LINK" \u2192 multiple DeFi tokens
- "Price of Solana and Cardano" \u2192 full token names
- "What's the current worth of MATIC?" \u2192 alternative names

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "tokens": [
    {
      "identifier": "Symbol, name, or contract address",
      "chain": "LOWERCASE chain identifier (ethereum/polygon/arbitrum/optimism/bsc/avax/fantom) as per DeFiLlama API",
      "type": "symbol/name/address/coingecko_id"
    }
  ],
  "requestType": "single/multiple/comparison",
  "includeDetails": true/false (if user wants detailed info beyond just price),
  "searchWidth": "4h/24h/48h (time window for price search if mentioned)"
}

Return only the JSON object, no other text.`;
var priceDataAction = {
  name: "PRICE_DATA",
  similes: [
    "GET_PRICE",
    "TOKEN_PRICE",
    "COIN_PRICE",
    "CURRENT_PRICE",
    "PRICE_CHECK",
    "MARKET_PRICE",
    "TOKEN_VALUE",
    "CRYPTO_PRICE"
  ],
  description: `Simple cryptocurrency price data fetcher. This action:
1. Extracts token symbols/names from user queries using LLM
2. Fetches current price data from DeFiLlama price feeds
3. Returns clean, structured price data for analysis or display
4. Supports multiple tokens and basic price information

USE WHEN: User asks about specific token prices or needs price data.
RETURNS: Raw price data without analysis - use ANALYZE_DEFI_DATA for insights.`,
  validate: async (runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    if (!text.includes("price") && !text.includes("worth") && !text.includes("value") && !text.includes("cost")) {
      return false;
    }
    const tokens = extractTokensFromQueryLegacy(text, "");
    return tokens.length > 0;
  },
  handler: async (runtime, message, state, options, callback) => {
    try {
      logger8.info("[PRICE_DATA] Starting price data fetch");
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const userQuestion = message.content.text || "";
      let tokens = [];
      let searchWidth = void 0;
      if (options?.tokens) {
        tokens = Array.isArray(options.tokens) ? options.tokens : [options.tokens];
      } else {
        const prompt = extractTokensTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType7.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            if (parsed.tokens && Array.isArray(parsed.tokens)) {
              for (const tokenInfo of parsed.tokens) {
                const resolvedToken = resolveTokenToId(
                  tokenInfo.identifier,
                  tokenInfo.chain,
                  tokenInfo.type
                );
                if (resolvedToken) {
                  tokens.push(resolvedToken);
                }
              }
              if (parsed.searchWidth) {
                searchWidth = parsed.searchWidth;
              }
              logger8.info(
                `[PRICE_DATA] LLM extracted tokens: ${tokens.join(", ")}, searchWidth: ${searchWidth || "default"}`
              );
            } else {
              logger8.warn(
                "[PRICE_DATA] LLM response missing tokens array, falling back to regex"
              );
              tokens = extractTokensFromQueryLegacy(userQuestion, "");
            }
          } catch (parseError) {
            logger8.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            tokens = extractTokensFromQueryLegacy(userQuestion, "");
          }
        } else {
          logger8.warn(
            "[PRICE_DATA] No LLM response received, falling back to regex"
          );
          tokens = extractTokensFromQueryLegacy(userQuestion, "");
        }
      }
      if (tokens.length === 0) {
        throw new Error("No valid tokens found in query");
      }
      const validTokens = tokens.filter((token) => {
        const isValidFormat = /^(\w+:0x[a-fA-F0-9]{40}|coingecko:[\w-]+)$/.test(
          token
        );
        if (!isValidFormat) {
          logger8.warn(`[PRICE_DATA] Skipping invalid token format: ${token}`);
          return false;
        }
        return true;
      });
      if (validTokens.length === 0) {
        throw new Error("No valid token formats found after validation");
      }
      if (validTokens.length !== tokens.length) {
        logger8.info(
          `[PRICE_DATA] Filtered ${tokens.length - validTokens.length} invalid tokens`
        );
      }
      logger8.info(
        `[PRICE_DATA] Fetching prices for validated tokens: ${validTokens.join(", ")}`
      );
      const currentPrices = await defiLlamaService.getCoinPrices(
        validTokens,
        searchWidth
      );
      const priceData = {};
      for (const token of validTokens) {
        const price = currentPrices.coins?.[token];
        if (price) {
          priceData[token] = {
            token: getTokenDisplayName(token),
            symbol: price.symbol,
            price: price.price,
            confidence: price.confidence,
            timestamp: price.timestamp,
            formatted: formatPrice(price.price)
          };
        }
      }
      const response = await runtime.useModel(ModelType7.LARGE, {
        prompt: `Respond concisely based on data: ${JSON.stringify(priceData)}
        and context: ${JSON.stringify(message.content)}`
      });
      if (callback) {
        await callback({
          text: response || "Unable to fetch price data at this time.",
          actions: ["PRICE_DATA"],
          source: message.content.source
        });
      }
      return {
        text: response,
        success: true,
        data: {
          actionName: "PRICE_DATA",
          tokens: validTokens,
          prices: priceData,
          priceDataFetched: true,
          tokensFound: validTokens.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      logger8.error("[PRICE_DATA] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      return {
        text: `Failed to fetch price data: ${errorMessage}`,
        success: false,
        error: error instanceof Error ? error : new Error(errorMessage),
        data: {
          actionName: "PRICE_DATA",
          error: errorMessage,
          priceDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "What is the current price of ETH?"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Retrieved price data for: Ethereum (ETH): $2,543.67, confidence 99%, updated 2m ago",
          actions: ["PRICE_DATA"]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Show me BTC and ETH prices"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "Bitcoin (BTC): $43,256.78, confidence 99%, updated 1m ago, Ethereum (ETH): $2,543.67, updated 2m ago",
          actions: ["PRICE_DATA"]
        }
      }
    ]
  ]
};
function resolveTokenToId(identifier, chain, type) {
  const lowerIdentifier = identifier.toLowerCase();
  if (type === "address" || /^0x[a-fA-F0-9]{40}$/.test(identifier)) {
    const resolvedChain = chain || guessChainFromContext(lowerIdentifier);
    return `${resolvedChain}:${identifier}`;
  }
  if (type === "coingecko_id" || identifier.startsWith("coingecko:")) {
    return identifier.startsWith("coingecko:") ? identifier : `coingecko:${identifier}`;
  }
  const tokenMap = getTokenMappings();
  if (tokenMap[lowerIdentifier]) {
    return tokenMap[lowerIdentifier];
  }
  logger8.warn(
    `[PRICE_DATA] Unknown token "${identifier}", attempting as coingecko ID`
  );
  return `coingecko:${lowerIdentifier}`;
}
function extractTokensFromQueryLegacy(query, assetsFromAI) {
  const found = [];
  const searchText = (query + " " + assetsFromAI).toLowerCase();
  const addressPattern = /0x[a-fA-F0-9]{40}/g;
  const addresses = searchText.match(addressPattern);
  if (addresses) {
    for (const addr of addresses) {
      const chain = guessChainFromContext(searchText);
      found.push(`${chain}:${addr}`);
    }
  }
  const chainAddressPattern = /(\w+):0x[a-fA-F0-9]{40}/g;
  const chainAddresses = searchText.match(chainAddressPattern);
  if (chainAddresses) {
    found.push(...chainAddresses);
  }
  const coingeckoPattern = /coingecko:[\w-]+/g;
  const coingeckoIds = searchText.match(coingeckoPattern);
  if (coingeckoIds) {
    found.push(...coingeckoIds);
  }
  const tokenMap = getTokenMappings();
  for (const [token, id] of Object.entries(tokenMap)) {
    if (searchText.includes(token)) {
      found.push(id);
    }
  }
  if (found.length === 0) {
    const patterns = [
      /price of ([a-z0-9]+)/i,
      /([a-z0-9]+) price/i,
      /how much is ([a-z0-9]+)/i,
      /value of ([a-z0-9]+)/i,
      /([a-z0-9]+) worth/i,
      /([a-z0-9]+) token/i
    ];
    for (const pattern of patterns) {
      const match = searchText.match(pattern);
      if (match) {
        const token = match[1].toLowerCase();
        if (tokenMap[token]) {
          found.push(tokenMap[token]);
        } else {
          found.push(`coingecko:${token}`);
        }
      }
    }
  }
  return Array.from(new Set(found));
}
function guessChainFromContext(text) {
  const chainKeywords = {
    ethereum: "ethereum",
    eth: "ethereum",
    mainnet: "ethereum",
    polygon: "polygon",
    matic: "polygon",
    arbitrum: "arbitrum",
    arb: "arbitrum",
    optimism: "optimism",
    op: "optimism",
    bsc: "bsc",
    binance: "bsc",
    avalanche: "avax",
    avax: "avax",
    fantom: "fantom",
    ftm: "fantom"
  };
  for (const [keyword, chain] of Object.entries(chainKeywords)) {
    if (text.includes(keyword)) {
      return chain;
    }
  }
  return "ethereum";
}
function getTokenMappings() {
  return {
    // Major cryptocurrencies
    bitcoin: "coingecko:bitcoin",
    btc: "coingecko:bitcoin",
    ethereum: "coingecko:ethereum",
    eth: "coingecko:ethereum",
    // Stablecoins
    usdc: "coingecko:usd-coin",
    usdt: "coingecko:tether",
    dai: "coingecko:dai",
    busd: "coingecko:binance-usd",
    frax: "coingecko:frax",
    // Layer 1s
    bnb: "coingecko:binancecoin",
    ada: "coingecko:cardano",
    sol: "coingecko:solana",
    matic: "coingecko:matic-network",
    polygon: "coingecko:matic-network",
    avax: "coingecko:avalanche-2",
    avalanche: "coingecko:avalanche-2",
    dot: "coingecko:polkadot",
    atom: "coingecko:cosmos",
    // DeFi tokens
    link: "coingecko:chainlink",
    uni: "coingecko:uniswap",
    aave: "coingecko:aave",
    comp: "coingecko:compound-governance-token",
    mkr: "coingecko:maker",
    crv: "coingecko:curve-dao-token",
    snx: "coingecko:havven",
    synthetix: "coingecko:havven",
    sushi: "coingecko:sushi",
    // Layer 2s
    arb: "coingecko:arbitrum",
    arbitrum: "coingecko:arbitrum",
    op: "coingecko:optimism",
    optimism: "coingecko:optimism",
    // Popular DeFi
    gmx: "coingecko:gmx",
    ldo: "coingecko:lido-dao",
    rpl: "coingecko:rocket-pool",
    bal: "coingecko:balancer",
    yfi: "coingecko:yearn-finance",
    // Meme coins (popular ones)
    doge: "coingecko:dogecoin",
    shib: "coingecko:shiba-inu",
    pepe: "coingecko:pepe"
  };
}
function getTokenDisplayName(tokenId) {
  const nameMap = {
    "coingecko:bitcoin": "Bitcoin",
    "coingecko:ethereum": "Ethereum",
    "coingecko:usd-coin": "USD Coin",
    "coingecko:tether": "Tether",
    "coingecko:dai": "Dai",
    "coingecko:binancecoin": "BNB",
    "coingecko:cardano": "Cardano",
    "coingecko:solana": "Solana",
    "coingecko:matic-network": "Polygon",
    "coingecko:avalanche-2": "Avalanche",
    "coingecko:polkadot": "Polkadot",
    "coingecko:chainlink": "Chainlink",
    "coingecko:uniswap": "Uniswap",
    "coingecko:aave": "Aave",
    "coingecko:compound-governance-token": "Compound",
    "coingecko:maker": "Maker",
    "coingecko:curve-dao-token": "Curve",
    "coingecko:havven": "Synthetix"
  };
  return nameMap[tokenId] || tokenId.split(":")[1] || tokenId;
}
function formatPrice(price) {
  if (price >= 1e3) {
    return price.toLocaleString("en-US", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
  } else if (price >= 1) {
    return price.toFixed(4);
  } else {
    return price.toFixed(6);
  }
}

// src/actions/defiRecommendationAction.ts
import {
  logger as logger9,
  ModelType as ModelType8
} from "@elizaos/core";
var extractRecommendationTemplate = `Extract DeFi investment recommendation parameters from the user's request for investment advice and opportunities.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /protocols endpoint returns protocol data with tvl, category, chains
- /pools endpoint returns yield data with {status: "success", data: [{apy, tvlUsd, project, symbol, chain}]}
- Protocol categories: "Dexs", "Lending", "Liquid Staking", "Derivatives", "Yield", "CDP", "Bridge"
- Chain names in proper case: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"
- Risk assessment based on TVL, APY levels, and protocol maturity

The user might express investment requests in various ways:
- "Good DeFi yield farming opportunities" \u2192 targetApy: 10, category: "Yield", riskTolerance: "medium"
- "Where should I invest $10k for moderate risk?" \u2192 investmentAmount: 10000, riskTolerance: "medium"
- "Best low-risk DeFi protocols for beginners" \u2192 riskTolerance: "low", categories: ["Lending", "Liquid Staking"]
- "High yield opportunities above 15%" \u2192 targetApy: 15, riskTolerance: "high"
- "Safe stablecoin farming on Ethereum" \u2192 chains: ["Ethereum"], targetApy: 5, riskTolerance: "low"
- "Conservative DeFi with $100k" \u2192 investmentAmount: 100000, riskTolerance: "low", minTvl: 1000000000
- "Aggressive yield strategies" \u2192 riskTolerance: "high", targetApy: 20

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "targetApy": number (desired APY percentage, default 8),
  "riskTolerance": "low/medium/high (investment risk preference)",
  "investmentAmount": number (investment amount in USD if mentioned),
  "minTvl": number (minimum protocol TVL for safety),
  "chains": ["Chain names as per API: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche"],
  "categories": ["Protocol categories: Dexs/Lending/Liquid Staking/Derivatives/Yield/CDP"],
  "timeHorizon": "short/medium/long (investment timeframe)",
  "strategy": "conservative/balanced/aggressive/yield_focused",
  "excludeRisky": true/false (if user wants to avoid high-risk protocols),
  "diversified": true/false (if user wants diversified recommendations)
}

Return only the JSON object, no other text.`;
var defiRecommendationAction = {
  name: "DEFI_RECOMMENDATIONS",
  similes: [
    "investment advice",
    "recommendations",
    "suggest protocols",
    "yield farming",
    "best opportunities",
    "where to invest",
    "defi strategies",
    "portfolio suggestions",
    "investment ideas",
    "yield opportunities"
  ],
  validate: async (runtime, message) => {
    const userQuestion = message.content.text?.toLowerCase() || "";
    const recommendationKeywords = [
      "recommend",
      "suggest",
      "advice",
      "best",
      "should i",
      "where to",
      "invest",
      "yield",
      "farming",
      "opportunities",
      "strategy",
      "portfolio",
      "apy",
      "returns",
      "earnings",
      "profitable",
      "good protocols"
    ];
    return recommendationKeywords.some(
      (keyword) => userQuestion.includes(keyword)
    );
  },
  description: "Provides DeFi investment recommendations and yield opportunities using LLM parameter extraction",
  handler: async (runtime, message, state, options, callback) => {
    logger9.info("[DEFI_RECOMMENDATIONS] Starting recommendation analysis");
    try {
      const userQuestion = message.content.text || "";
      let extractedParams;
      if (options?.recommendationParams) {
        extractedParams = options.recommendationParams;
      } else {
        const prompt = extractRecommendationTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType8.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              targetApy: parsed.targetApy || 8,
              riskTolerance: parsed.riskTolerance || "medium",
              investmentAmount: parsed.investmentAmount || 0,
              minTvl: parsed.minTvl || (parsed.riskTolerance === "low" ? 1e8 : parsed.riskTolerance === "high" ? 1e6 : 1e7),
              chains: parsed.chains || [],
              categories: parsed.categories || [],
              timeHorizon: parsed.timeHorizon || "medium",
              strategy: parsed.strategy || "balanced",
              excludeRisky: parsed.excludeRisky || false,
              diversified: parsed.diversified || true
            };
            logger9.info(
              `[DEFI_RECOMMENDATIONS] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger9.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            extractedParams = extractInvestmentCriteriaLegacy(userQuestion);
          }
        } else {
          logger9.warn(
            "[DEFI_RECOMMENDATIONS] No LLM response received, falling back to regex"
          );
          extractedParams = extractInvestmentCriteriaLegacy(userQuestion);
        }
      }
      logger9.info(
        `[DEFI_RECOMMENDATIONS] Analyzing with criteria: ${JSON.stringify(extractedParams)}`
      );
      const defiLlamaService = runtime.getService(
        DefiLlamaService.serviceType
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const [protocols, yields] = await Promise.all([
        defiLlamaService.getProtocols(),
        defiLlamaService.getYields()
      ]);
      const structuredData = buildRecommendationsLLM(
        protocols,
        yields,
        extractedParams
      );
      logger9.info(
        "[DEFI_RECOMMENDATIONS] Recommendations generated successfully"
      );
      const response = await runtime.useModel(ModelType8.LARGE, {
        prompt: `Respond concisely with investment recommendations based on data: ${JSON.stringify(structuredData)}

Question: ${userQuestion}

Provide insights on:
- Top yield opportunities matching user criteria
- Protocol recommendations with risk assessment
- Strategic investment suggestions
- Risk management considerations

Keep response focused, practical, and under 150 words.`,
        temperature: 0.7,
        stop: ["<END>"]
      });
      if (callback) {
        await callback({
          text: response || "Unable to generate recommendations at this time.",
          actions: ["DEFI_RECOMMENDATIONS"],
          source: message.content.source
        });
      }
      return {
        text: response || "Investment recommendations generated",
        success: true,
        data: {
          actionName: "DEFI_RECOMMENDATIONS",
          extractedParams,
          structuredData,
          recommendationsGenerated: true,
          opportunitiesFound: structuredData.yieldOpportunities.length,
          protocolsRecommended: structuredData.protocolRecommendations.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      const errorMessage = `Failed to generate recommendations: ${error}`;
      logger9.error(`[DEFI_RECOMMENDATIONS] ${errorMessage}`);
      if (callback) {
        await callback({
          text: "I encountered an error while generating recommendations. Please try again.",
          source: "DEFI_RECOMMENDATIONS"
        });
      }
      return {
        text: "Error generating recommendations. Please try again.",
        success: false,
        data: {
          actionName: "DEFI_RECOMMENDATIONS",
          error: errorMessage,
          recommendationsGenerated: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "user",
        content: {
          text: "Recommend some good DeFi yield farming opportunities"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Here are the top DeFi yield farming opportunities based on current market conditions: [analysis with recommendations]",
          source: "DEFI_RECOMMENDATIONS"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "Where should I invest $10k for moderate risk and good returns?"
        }
      },
      {
        name: "assistant",
        content: {
          text: "For $10k with moderate risk tolerance, here are my top protocol recommendations: [detailed investment strategy]",
          source: "DEFI_RECOMMENDATIONS"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "What are the best low-risk DeFi protocols for beginners?"
        }
      },
      {
        name: "assistant",
        content: {
          text: "For beginners seeking low-risk DeFi exposure, I recommend these established protocols: [beginner-friendly recommendations]",
          source: "DEFI_RECOMMENDATIONS"
        }
      }
    ]
  ]
};
function buildRecommendationsLLM(protocols, yields, params) {
  const criteria = {
    targetApy: params.targetApy,
    riskTolerance: params.riskTolerance,
    minTvl: params.minTvl,
    chains: params.chains,
    categories: params.categories
  };
  const yieldOpportunities = yields.filter((pool) => {
    const minApyThreshold = params.riskTolerance === "low" ? params.targetApy * 0.3 : params.targetApy * 0.5;
    if (pool.apy < minApyThreshold) return false;
    const minTvlThreshold = params.riskTolerance === "low" ? params.minTvl * 0.5 : params.minTvl * 0.1;
    if (pool.tvlUsd < minTvlThreshold) return false;
    if (params.chains.length > 0 && pool.chain && !params.chains.includes(pool.chain))
      return false;
    if (params.excludeRisky && pool.apy > 50) return false;
    return true;
  }).map((pool) => ({
    project: pool.project,
    symbol: pool.symbol,
    apy: pool.apy,
    tvlUsd: pool.tvlUsd,
    chain: pool.chain || "Multi-chain",
    category: "Yield",
    riskLevel: assessYieldRiskLLM(pool, params)
  })).sort((a, b) => {
    if (params.strategy === "conservative") {
      return b.tvlUsd - a.tvlUsd;
    } else if (params.strategy === "yield_focused") {
      return b.apy - a.apy;
    } else {
      const scoreA = a.apy * Math.log(a.tvlUsd + 1);
      const scoreB = b.apy * Math.log(b.tvlUsd + 1);
      return scoreB - scoreA;
    }
  }).slice(0, params.diversified ? 8 : 5);
  const protocolRecommendations = protocols.filter((protocol) => {
    const protocolTvl = protocol.tvl || 0;
    if (protocolTvl < params.minTvl) return false;
    if (params.categories.length > 0 && !params.categories.includes(protocol.category))
      return false;
    if (params.chains.length > 0 && protocol.chain && !params.chains.includes(protocol.chain))
      return false;
    if (params.excludeRisky) {
      const highRiskCategories = [
        "Derivatives",
        "Cross Chain",
        "Algo-Stables"
      ];
      if (highRiskCategories.includes(protocol.category)) return false;
    }
    return true;
  }).map((protocol) => ({
    name: protocol.name,
    tvl: protocol.tvl || 0,
    category: protocol.category,
    chain: protocol.chain || "Multi-chain",
    reason: generateRecommendationReasonLLM(protocol, params),
    riskLevel: assessProtocolRiskLLM(protocol, params)
  })).sort((a, b) => {
    if (params.strategy === "conservative") {
      return b.tvl - a.tvl;
    } else {
      const scoreA = a.tvl + (params.categories.includes(a.category) ? a.tvl * 0.2 : 0);
      const scoreB = b.tvl + (params.categories.includes(b.category) ? b.tvl * 0.2 : 0);
      return scoreB - scoreA;
    }
  }).slice(0, params.diversified ? 6 : 4);
  const totalOpportunities = yieldOpportunities.length + protocolRecommendations.length;
  const averageApy = yieldOpportunities.length > 0 ? yieldOpportunities.reduce((sum, op) => sum + op.apy, 0) / yieldOpportunities.length : 0;
  const totalTvl = protocolRecommendations.reduce(
    (sum, rec) => sum + rec.tvl,
    0
  );
  const riskDistribution = { low: 0, medium: 0, high: 0 };
  [...yieldOpportunities, ...protocolRecommendations].forEach((item) => {
    riskDistribution[item.riskLevel]++;
  });
  return {
    investmentCriteria: criteria,
    yieldOpportunities,
    protocolRecommendations,
    summary: {
      totalOpportunities,
      averageApy,
      totalTvl,
      riskDistribution
    }
  };
}
function assessYieldRiskLLM(pool, params) {
  let riskScore = 0;
  if (pool.apy > 100) riskScore += 3;
  else if (pool.apy > 50) riskScore += 2;
  else if (pool.apy > 20) riskScore += 1;
  if (pool.tvlUsd < 1e6) riskScore += 3;
  else if (pool.tvlUsd < 1e7) riskScore += 2;
  else if (pool.tvlUsd < 5e7) riskScore += 1;
  if (pool.stablecoin) riskScore -= 1;
  if (params.riskTolerance === "low") riskScore += 1;
  else if (params.riskTolerance === "high") riskScore -= 1;
  if (riskScore <= 1) return "low";
  if (riskScore <= 3) return "medium";
  return "high";
}
function assessProtocolRiskLLM(protocol, params) {
  let riskScore = 0;
  const protocolTvl = protocol.tvl || 0;
  if (protocolTvl < 1e7) riskScore += 3;
  else if (protocolTvl < 1e8) riskScore += 2;
  else if (protocolTvl < 1e9) riskScore += 1;
  const highRiskCategories = ["Derivatives", "Cross Chain", "Algo-Stables"];
  const lowRiskCategories = ["Lending", "Liquid Staking", "CDP"];
  if (highRiskCategories.includes(protocol.category)) riskScore += 2;
  else if (lowRiskCategories.includes(protocol.category)) riskScore -= 1;
  if (params.riskTolerance === "low") riskScore += 1;
  else if (params.riskTolerance === "high") riskScore -= 1;
  if (riskScore <= 1) return "low";
  if (riskScore <= 3) return "medium";
  return "high";
}
function generateRecommendationReasonLLM(protocol, params) {
  const reasons = [];
  const protocolTvl = protocol.tvl || 0;
  if (protocolTvl > 5e9) {
    reasons.push("Massive TVL provides exceptional security");
  } else if (protocolTvl > 1e9) {
    reasons.push("High TVL provides strong security");
  }
  if (protocol.category === "Lending" && params.riskTolerance === "low") {
    reasons.push("Established lending protocol with proven track record");
  }
  if (protocol.category === "Dexs" && params.strategy === "yield_focused") {
    reasons.push("DEX with strong liquidity and yield opportunities");
  }
  if (protocol.category === "Liquid Staking" && params.timeHorizon === "long") {
    reasons.push("Liquid staking ideal for long-term strategies");
  }
  if (params.categories.includes(protocol.category)) {
    reasons.push(`Matches your ${protocol.category.toLowerCase()} preference`);
  }
  return reasons.length > 0 ? reasons[0] : "Solid protocol fundamentals";
}
function extractInvestmentCriteriaLegacy(query) {
  const lowerQuery = query.toLowerCase();
  let targetApy = 8;
  const apyMatch = lowerQuery.match(/(\d+)%?\s*(apy|yield|return)/);
  if (apyMatch) {
    targetApy = parseInt(apyMatch[1]);
  } else if (lowerQuery.includes("high yield") || lowerQuery.includes("high return")) {
    targetApy = 15;
  } else if (lowerQuery.includes("conservative") || lowerQuery.includes("safe")) {
    targetApy = 5;
  }
  let riskTolerance = "medium";
  if (lowerQuery.includes("conservative") || lowerQuery.includes("safe") || lowerQuery.includes("low risk")) {
    riskTolerance = "low";
  } else if (lowerQuery.includes("aggressive") || lowerQuery.includes("high risk") || lowerQuery.includes("risky")) {
    riskTolerance = "high";
  }
  let minTvl = 1e7;
  if (riskTolerance === "low") {
    minTvl = 1e8;
  } else if (riskTolerance === "high") {
    minTvl = 1e6;
  }
  const chains = [];
  const chainKeywords = {
    ethereum: "Ethereum",
    polygon: "Polygon",
    arbitrum: "Arbitrum",
    optimism: "Optimism",
    avalanche: "Avalanche",
    bsc: "BSC"
  };
  for (const [keyword, chain] of Object.entries(chainKeywords)) {
    if (lowerQuery.includes(keyword)) {
      chains.push(chain);
    }
  }
  const categories = [];
  const categoryKeywords = {
    lending: "Lending",
    dex: "Dexs",
    "yield farming": "Yield",
    staking: "Liquid Staking",
    stablecoin: "Stablecoins"
  };
  for (const [keyword, category] of Object.entries(categoryKeywords)) {
    if (lowerQuery.includes(keyword)) {
      categories.push(category);
    }
  }
  return {
    targetApy,
    riskTolerance,
    minTvl,
    chains,
    categories,
    strategy: "balanced",
    excludeRisky: riskTolerance === "low",
    diversified: true
  };
}

// src/actions/riskAnalysisAction.ts
import {
  logger as logger10,
  ModelType as ModelType9
} from "@elizaos/core";
var extractRiskAnalysisTemplate = `Extract risk analysis parameters from the user's request for DeFi protocol safety assessment.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /protocol/{protocol} endpoint returns protocol data with tvl, category, chains (array), audits, audit_note
- Protocol categories: "Dexs", "Lending", "Liquid Staking", "Derivatives", "Yield", "CDP", "Bridge"
- Chain names in proper case: "Ethereum", "Polygon", "Arbitrum", "Optimism", "BSC", "Avalanche"
- Risk assessment based on TVL, audit status, time active, and category characteristics

The user might express risk analysis requests in various ways:
- "Is Aave safe to use?" \u2192 protocols: ["Aave"], riskCategories: ["smart_contract", "liquidity", "governance"]
- "Smart contract risks in DeFi lending" \u2192 analysisScope: "category", category: "Lending", riskCategories: ["smart_contract"]
- "Compare risk levels of Uniswap vs SushiSwap" \u2192 protocols: ["Uniswap", "SushiSwap"], analysisType: "comparison"
- "Liquidity risks in small cap protocols" \u2192 riskCategories: ["liquidity"], tvlFilter: "low", analysisScope: "market"
- "What are the governance risks in DeFi?" \u2192 riskCategories: ["governance"], analysisScope: "general"
- "Security audit status of top protocols" \u2192 riskCategories: ["smart_contract"], analysisScope: "market", focus: "audits"
- "Risk assessment for yield farming" \u2192 category: "Yield", riskCategories: ["smart_contract", "market"]

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "protocols": ["Protocol names if mentioned: Aave/Uniswap/Compound/Curve"],
  "riskCategories": ["smart_contract/liquidity/market/governance/regulatory/operational/technical"],
  "analysisScope": "specific/category/market/general (scope of analysis)",
  "analysisType": "assessment/comparison/overview/audit_review",
  "category": "Dexs/Lending/Liquid Staking/Derivatives if mentioned",
  "chains": ["Chain names if specified: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche"],
  "riskTolerance": "conservative/moderate/aggressive (user's risk preference)",
  "focus": "audits/tvl/governance/technical if specific focus mentioned",
  "timeframe": "current/historical if mentioned",
  "severity": "low/medium/high/all (level of risks to focus on)"
}

Return only the JSON object, no other text.`;
var riskAnalysisAction = {
  name: "RISK_ANALYSIS",
  similes: [
    "risk assessment",
    "safety analysis",
    "security review",
    "protocol risks",
    "smart contract risks",
    "liquidity risks",
    "investment safety",
    "due diligence",
    "risk evaluation",
    "security audit"
  ],
  validate: async (runtime, message) => {
    const userQuestion = message.content.text?.toLowerCase() || "";
    const riskKeywords = [
      "risk",
      "risks",
      "safety",
      "secure",
      "dangerous",
      "audit",
      "security",
      "smart contract",
      "liquidity risk",
      "impermanent loss",
      "rug pull",
      "exploit",
      "hack",
      "vulnerable",
      "safe",
      "unsafe",
      "due diligence"
    ];
    return riskKeywords.some((keyword) => userQuestion.includes(keyword));
  },
  description: "Analyzes DeFi protocol risks and safety concerns using LLM parameter extraction",
  handler: async (runtime, message, state, options, callback) => {
    logger10.info("[RISK_ANALYSIS] Starting risk analysis");
    try {
      const userQuestion = message.content.text || "";
      let extractedParams;
      if (options?.riskParams) {
        extractedParams = options.riskParams;
      } else {
        const prompt = extractRiskAnalysisTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType9.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              protocols: parsed.protocols || [],
              riskCategories: parsed.riskCategories || [
                "smart_contract",
                "liquidity",
                "market"
              ],
              analysisScope: parsed.analysisScope || "specific",
              analysisType: parsed.analysisType || "assessment",
              category: parsed.category || void 0,
              chains: parsed.chains || [],
              riskTolerance: parsed.riskTolerance || "moderate",
              focus: parsed.focus || void 0,
              timeframe: parsed.timeframe || "current",
              severity: parsed.severity || "all"
            };
            logger10.info(
              `[RISK_ANALYSIS] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger10.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            const targetProtocols = extractProtocolsFromQueryLegacy3(userQuestion);
            const riskCategories = extractRiskCategoriesFromQueryLegacy(userQuestion);
            extractedParams = {
              protocols: targetProtocols,
              riskCategories,
              analysisScope: targetProtocols.length > 0 ? "specific" : "general",
              analysisType: "assessment",
              category: void 0,
              chains: [],
              riskTolerance: "moderate",
              focus: void 0,
              timeframe: "current",
              severity: "all"
            };
          }
        } else {
          logger10.warn(
            "[RISK_ANALYSIS] No LLM response received, falling back to regex"
          );
          const targetProtocols = extractProtocolsFromQueryLegacy3(userQuestion);
          const riskCategories = extractRiskCategoriesFromQueryLegacy(userQuestion);
          extractedParams = {
            protocols: targetProtocols,
            riskCategories,
            analysisScope: targetProtocols.length > 0 ? "specific" : "general",
            analysisType: "assessment",
            category: void 0,
            chains: [],
            riskTolerance: "moderate",
            focus: void 0,
            timeframe: "current",
            severity: "all"
          };
        }
      }
      logger10.info(
        `[RISK_ANALYSIS] Analyzing risks for protocols: ${extractedParams.protocols.join(", ") || "general"}, categories: ${extractedParams.riskCategories.join(", ")}`
      );
      const defiLlamaService = runtime.getService(
        DefiLlamaService.serviceType
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      let riskData = {};
      if (extractedParams.protocols.length > 0) {
        const protocolDataPromises = extractedParams.protocols.map(
          async (protocol) => {
            try {
              const protocolSlug = protocol.toLowerCase().replace(/\s+/g, "-");
              const protocolInfo = await defiLlamaService.getProtocol(protocolSlug);
              return { protocol, protocolInfo };
            } catch (error) {
              logger10.warn(
                `[RISK_ANALYSIS] Failed to fetch data for ${protocol}: ${error}`
              );
              return null;
            }
          }
        );
        const protocolResults = await Promise.allSettled(protocolDataPromises);
        riskData = {
          protocols: protocolResults.filter(
            (result) => result.status === "fulfilled" && result.value !== null
          ).map((result) => result.value)
        };
      } else {
        const [protocols, chains] = await Promise.all([
          defiLlamaService.getProtocols(),
          defiLlamaService.getChains()
        ]);
        let filteredProtocols = protocols;
        if (extractedParams.category) {
          filteredProtocols = protocols.filter(
            (p) => p.category === extractedParams.category
          );
        }
        riskData = {
          protocols: filteredProtocols.slice(0, 10).map((protocol) => ({
            protocol: protocol.name,
            protocolInfo: protocol
          }))
        };
      }
      const structuredData = buildRiskAnalysisDataLLM(
        riskData.protocols || [],
        extractedParams
      );
      logger10.info(
        "[RISK_ANALYSIS] Risk data fetched and structured successfully"
      );
      const response = await runtime.useModel(ModelType9.LARGE, {
        prompt: `Respond concisely with risk analysis based on data: ${JSON.stringify(structuredData)}

Question: ${userQuestion}

Provide insights on:
- Key risk factors and security concerns
- Protocol maturity and audit status
- Liquidity and market risks
- Smart contract risks and governance
- Recommendations for risk mitigation

Keep response focused, practical, and under 150 words.`,
        temperature: 0.7,
        stop: ["<END>"]
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze risks at this time.",
          actions: ["RISK_ANALYSIS"],
          source: message.content.source
        });
      }
      return {
        text: response || "Risk analysis completed",
        success: true,
        data: {
          actionName: "RISK_ANALYSIS",
          extractedParams,
          structuredData,
          riskAnalysisCompleted: true,
          protocolsAnalyzed: extractedParams.protocols.length || "market overview",
          riskCategoriesUsed: extractedParams.riskCategories.join(", ") || "general",
          timestamp: Date.now()
        }
      };
    } catch (error) {
      const errorMessage = `Failed to analyze risks: ${error}`;
      logger10.error(`[RISK_ANALYSIS] ${errorMessage}`);
      if (callback) {
        await callback({
          text: "I encountered an error while analyzing risks. Please try again.",
          source: "RISK_ANALYSIS"
        });
      }
      return {
        text: "Error analyzing risks. Please try again.",
        success: false,
        data: {
          actionName: "RISK_ANALYSIS",
          error: errorMessage,
          riskAnalysisCompleted: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "user",
        content: { text: "Is Aave safe to use? What are the main risks?" }
      },
      {
        name: "assistant",
        content: {
          text: "Here's a comprehensive risk analysis of Aave: [analysis based on latest protocol data]",
          source: "RISK_ANALYSIS"
        }
      }
    ],
    [
      {
        name: "user",
        content: {
          text: "What are the smart contract risks in DeFi lending protocols?"
        }
      },
      {
        name: "assistant",
        content: {
          text: "Here are the key smart contract risks in DeFi lending: [detailed risk breakdown]",
          source: "RISK_ANALYSIS"
        }
      }
    ],
    [
      {
        name: "user",
        content: { text: "Compare the risk levels of Uniswap vs SushiSwap" }
      },
      {
        name: "assistant",
        content: {
          text: "Here's a comparative risk analysis of Uniswap vs SushiSwap: [risk comparison]",
          source: "RISK_ANALYSIS"
        }
      }
    ]
  ]
};
function buildRiskAnalysisDataLLM(data, params) {
  const result = {
    targetProtocols: params.protocols.length > 0 ? params.protocols : "market overview",
    riskCategories: params.riskCategories,
    protocolRisks: [],
    marketRisks: null,
    summary: {
      totalProtocols: 0,
      riskLevels: { Low: 0, Medium: 0, High: 0 },
      analysisScope: params.analysisScope
    }
  };
  if (data.length > 0) {
    if (params.protocols.length > 0) {
      result.protocolRisks = data.map((item) => {
        const protocolInfo = item.protocolInfo;
        return {
          name: item.protocol,
          currentTvl: protocolInfo?.tvl || 0,
          category: protocolInfo?.category || "Unknown",
          chain: protocolInfo?.chains?.join(", ") || "Multi-chain",
          auditStatus: protocolInfo?.audits || protocolInfo?.audit_links?.length ? "Audited" : "Unknown",
          riskAssessment: assessProtocolRiskLLM2(protocolInfo, params),
          governance: protocolInfo?.governanceID || "Not Available",
          timeActive: calculateTimeActiveLLM(protocolInfo?.listedAt || 0)
        };
      });
    } else {
      result.marketRisks = {
        protocols: data.slice(0, 10).map((protocol) => ({
          name: protocol.protocol,
          tvl: protocol.protocolInfo?.tvl || 0,
          category: protocol.protocolInfo?.category || "Unknown",
          riskLevel: assessGeneralRiskLLM(protocol.protocolInfo, params)
        })),
        marketTrends: {
          totalTvl: data.reduce(
            (sum, p) => sum + (p.protocolInfo?.tvl || 0),
            0
          ),
          protocolCount: data.length,
          categories: [
            ...new Set(
              data.map((p) => p.protocolInfo?.category).filter((cat) => Boolean(cat))
            )
          ]
        }
      };
    }
    result.summary.totalProtocols = data.length;
    result.summary.riskLevels = calculateRiskDistributionLLM(data, params);
  }
  return result;
}
function assessProtocolRiskLLM2(protocolInfo, params) {
  const riskFactors = {
    smart_contract: "Medium",
    // Default
    liquidity: "Medium",
    market: "Medium",
    governance: "Medium"
  };
  if (protocolInfo?.audits || protocolInfo?.audit_links?.length) {
    riskFactors.smart_contract = "Low";
  } else if (protocolInfo?.listedAt && Date.now() / 1e3 - protocolInfo.listedAt > 365 * 24 * 3600) {
    riskFactors.smart_contract = "Medium";
  } else {
    riskFactors.smart_contract = "High";
  }
  const tvl = protocolInfo?.tvl || 0;
  if (tvl > 5e9) {
    riskFactors.liquidity = "Low";
  } else if (tvl > 1e9) {
    riskFactors.liquidity = "Medium";
  } else if (tvl > 1e8) {
    riskFactors.liquidity = params.riskTolerance === "conservative" ? "High" : "Medium";
  } else {
    riskFactors.liquidity = "High";
  }
  const category = protocolInfo?.category?.toLowerCase() || "";
  if (category.includes("derivatives") || category.includes("leverage")) {
    riskFactors.market = "High";
  } else if (category.includes("lending") || category.includes("liquid staking")) {
    riskFactors.market = params.riskTolerance === "conservative" ? "Medium" : "Low";
  } else if (category.includes("dex")) {
    riskFactors.market = "Medium";
  } else {
    riskFactors.market = "Medium";
  }
  if (protocolInfo?.governanceID) {
    riskFactors.governance = "Low";
  } else if (protocolInfo?.oracles && protocolInfo.oracles.length > 0) {
    riskFactors.governance = protocolInfo.oracles.length >= 2 ? "Low" : "Medium";
  } else if (protocolInfo?.listedAt && Date.now() / 1e3 - protocolInfo.listedAt > 2 * 365 * 24 * 3600) {
    riskFactors.governance = "Medium";
  } else {
    riskFactors.governance = params.riskTolerance === "conservative" ? "High" : "Medium";
  }
  return {
    overall: calculateOverallRiskLLM(riskFactors, params),
    factors: riskFactors,
    confidence: (protocolInfo?.audits || protocolInfo?.audit_links?.length) && tvl > 1e9 ? "High" : tvl > 1e8 ? "Medium" : "Low"
  };
}
function assessGeneralRiskLLM(protocolInfo, params) {
  const tvl = protocolInfo?.tvl || 0;
  const category = protocolInfo?.category?.toLowerCase() || "";
  if (params.riskTolerance === "conservative") {
    if (tvl > 1e10 && !category.includes("derivatives")) return "Low";
    if (tvl > 2e9 && (category.includes("lending") || category.includes("dex")))
      return "Medium";
    return "High";
  } else if (params.riskTolerance === "aggressive") {
    if (tvl > 1e9) return "Low";
    if (tvl > 1e8) return "Medium";
    return "High";
  } else {
    if (tvl > 5e9) return "Low";
    if (tvl > 1e9 && !category.includes("derivatives")) return "Medium";
    if (tvl > 1e8) return "Medium";
    return "High";
  }
}
function calculateTimeActiveLLM(listedAt) {
  if (!listedAt) return "Unknown";
  const daysSince = (Date.now() / 1e3 - listedAt) / 86400;
  if (daysSince > 730) return `${Math.floor(daysSince / 365)} years`;
  if (daysSince > 365) return `${Math.floor(daysSince / 365)} year`;
  if (daysSince > 60) return `${Math.floor(daysSince / 30)} months`;
  if (daysSince > 30) return `${Math.floor(daysSince / 30)} month`;
  return `${Math.floor(daysSince)} days`;
}
function calculateOverallRiskLLM(riskFactors, params) {
  let weights = {
    smart_contract: 0.4,
    liquidity: 0.3,
    market: 0.2,
    governance: 0.1
  };
  if (params.focus === "audits") {
    weights.smart_contract = 0.6;
    weights.liquidity = 0.2;
    weights.market = 0.1;
    weights.governance = 0.1;
  } else if (params.focus === "tvl") {
    weights.liquidity = 0.5;
    weights.smart_contract = 0.3;
    weights.market = 0.1;
    weights.governance = 0.1;
  } else if (params.focus === "governance") {
    weights.governance = 0.4;
    weights.smart_contract = 0.3;
    weights.liquidity = 0.2;
    weights.market = 0.1;
  }
  const riskScores = {
    Low: 1,
    Medium: 2,
    High: 3
  };
  let weightedScore = 0;
  for (const [factor, risk] of Object.entries(riskFactors)) {
    const weight = weights[factor] || 0.1;
    const score = riskScores[risk] || 2;
    weightedScore += weight * score;
  }
  if (params.riskTolerance === "conservative") {
    if (weightedScore <= 1.3) return "Low";
    if (weightedScore <= 2) return "Medium";
    return "High";
  } else if (params.riskTolerance === "aggressive") {
    if (weightedScore <= 1.8) return "Low";
    if (weightedScore <= 2.7) return "Medium";
    return "High";
  } else {
    if (weightedScore <= 1.5) return "Low";
    if (weightedScore <= 2.5) return "Medium";
    return "High";
  }
}
function calculateRiskDistributionLLM(protocols, params) {
  const distribution = { Low: 0, Medium: 0, High: 0 };
  protocols.forEach((protocol) => {
    const risk = assessGeneralRiskLLM(protocol.protocolInfo, params);
    distribution[risk]++;
  });
  return distribution;
}
function extractProtocolsFromQueryLegacy3(query) {
  const protocols = [];
  const lowerQuery = query.toLowerCase();
  const protocolKeywords = {
    aave: "Aave",
    uniswap: "Uniswap",
    compound: "Compound",
    sushiswap: "SushiSwap",
    curve: "Curve",
    pancakeswap: "PancakeSwap",
    balancer: "Balancer",
    maker: "MakerDAO",
    "1inch": "1inch",
    synthetix: "Synthetix",
    yearn: "Yearn Finance",
    convex: "Convex Finance",
    lido: "Lido",
    frax: "Frax",
    gmx: "GMX",
    dydx: "dYdX"
  };
  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {
    if (lowerQuery.includes(keyword)) {
      protocols.push(protocol);
    }
  }
  return protocols;
}
function extractRiskCategoriesFromQueryLegacy(query) {
  const categories = [];
  const lowerQuery = query.toLowerCase();
  const riskCategoryKeywords = {
    smart_contract: [
      "smart contract",
      "contract risk",
      "code risk",
      "bug",
      "exploit"
    ],
    liquidity: ["liquidity", "liquidity risk", "slippage", "depth"],
    market: ["market risk", "price risk", "volatility", "correlation"],
    governance: ["governance", "governance risk", "centralization", "admin"],
    regulatory: ["regulatory", "compliance", "legal", "regulation"],
    operational: ["operational", "team risk", "founder", "development"],
    technical: ["technical", "infrastructure", "oracle", "bridge"]
  };
  for (const [category, keywords] of Object.entries(riskCategoryKeywords)) {
    if (keywords.some((keyword) => lowerQuery.includes(keyword))) {
      categories.push(category);
    }
  }
  if (categories.length === 0) {
    categories.push("smart_contract", "liquidity", "market");
  }
  return categories;
}

// src/actions/stablecoinAction.ts
import {
  logger as logger11,
  ModelType as ModelType10
} from "@elizaos/core";
var extractStablecoinTemplate = `Extract stablecoin analysis parameters from the user's request for stablecoin data and analysis.

User request: "{{userMessage}}"

IMPORTANT: Follow DeFiLlama API specification exactly:
- /stablecoins endpoint returns data with {peggedAssets: []} structure
- Chain names in proper case: "Ethereum", "Tron", "BSC", "Polygon", "Arbitrum", "Avalanche"
- Stablecoin names/symbols as returned by API: "Tether"/"USDT", "USD Coin"/"USDC", "Dai"/"DAI", etc.
- pegMechanism values: "fiat-backed", "crypto-backed", "algorithmic"

The user might express stablecoin requests in various ways:
- "USDC market cap" \u2192 stablecoins: ["USDC"], metrics: ["circulation", "market_cap"]
- "Compare USDT vs USDC stability" \u2192 stablecoins: ["USDT", "USDC"], analysis: "comparison", metrics: ["peg_stability"]
- "Algorithmic stablecoins" \u2192 pegMechanism: "algorithmic"
- "Stablecoins on Ethereum" \u2192 chains: ["Ethereum"]
- "DAI depeg risk analysis" \u2192 stablecoins: ["DAI"], metrics: ["depeg_risk", "peg_stability"]
- "Top 5 stablecoins by market cap" \u2192 count: 5, sortBy: "circulation"
- "Fiat-backed stablecoins" \u2192 pegMechanism: "fiat-backed"

Extract and return ONLY a JSON object following DeFiLlama API format:
{
  "stablecoins": ["Stablecoin symbols if mentioned: USDT/USDC/DAI/FRAX/BUSD/TUSD"],
  "chains": ["Chain names as per /stablecoins endpoint: Ethereum/Tron/BSC/Polygon/Arbitrum"],
  "pegMechanism": ["fiat-backed/crypto-backed/algorithmic if mentioned"],
  "metrics": ["circulation/market_cap/peg_stability/depeg_risk/price if requested"],
  "analysisType": "overview/comparison/ranking/stability_analysis/risk_assessment",
  "sortBy": "circulation/price/name (how to sort results)",
  "count": number (how many results, default 10),
  "includePrices": true/false (if user wants current prices),
  "timeframe": "current/historical if mentioned"
}

Return only the JSON object, no other text.`;
var stablecoinAction = {
  name: "STABLECOIN_ANALYSIS",
  similes: [
    "STABLECOIN_DATA",
    "STABLE_ANALYSIS",
    "USDC_ANALYSIS",
    "TETHER_ANALYSIS",
    "STABLECOIN_MARKET",
    "PEG_ANALYSIS",
    "DEPEG_RISK",
    "STABLECOIN_YIELD",
    "PEG_STABILITY",
    "STABLECOIN_SAFETY",
    "STABLE_COMPARISON",
    "STABLECOIN_BACKING"
  ],
  description: `Simple stablecoin data fetcher. This action:
1. Extracts stablecoin names/symbols from user queries using LLM
2. Fetches current stablecoin data from DeFiLlama API
3. Returns clean, structured stablecoin data for analysis or display
4. Supports multiple stablecoins and basic stablecoin information

USE WHEN: User asks about stablecoin stability, market cap, circulation, or peg analysis.
RETURNS: Raw stablecoin data without extensive analysis - focused on data retrieval.`,
  validate: async (runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    const keywords = [
      "stablecoin",
      "stable coin",
      "usdc",
      "usdt",
      "tether",
      "dai",
      "frax",
      "busd",
      "peg",
      "depeg",
      "circulation",
      "market cap",
      "stablecoin dominance",
      "stable market"
    ];
    return keywords.some((keyword) => text.includes(keyword));
  },
  handler: async (runtime, message, state, options, callback) => {
    try {
      logger11.info("[STABLECOIN_ANALYSIS] Starting stablecoin data fetch");
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        throw new Error("DeFiLlama service not available");
      }
      const userQuestion = message.content.text || "";
      let extractedParams;
      if (options?.stablecoinParams) {
        extractedParams = options.stablecoinParams;
      } else {
        const prompt = extractStablecoinTemplate.replace(
          "{{userMessage}}",
          userQuestion
        );
        const response2 = await runtime.useModel(ModelType10.TEXT_LARGE, {
          prompt
        });
        if (response2) {
          try {
            const cleanedResponse = response2.replace(/^```(?:json)?\n?/, "").replace(/\n?```$/, "").trim();
            const parsed = JSON.parse(cleanedResponse);
            extractedParams = {
              stablecoins: parsed.stablecoins || [],
              chains: parsed.chains || [],
              pegMechanism: parsed.pegMechanism || [],
              metrics: parsed.metrics || [],
              analysisType: parsed.analysisType || "overview",
              sortBy: parsed.sortBy || "circulation",
              count: parsed.count || 10,
              includePrices: parsed.includePrices || false,
              timeframe: parsed.timeframe || "current"
            };
            logger11.info(
              `[STABLECOIN_ANALYSIS] LLM extracted params: ${JSON.stringify(extractedParams)}`
            );
          } catch (parseError) {
            logger11.warn(
              "Failed to parse LLM response, falling back to regex:",
              parseError
            );
            extractedParams = {
              stablecoins: extractStablecoinsFromQueryLegacy(userQuestion),
              chains: [],
              pegMechanism: [],
              metrics: [],
              analysisType: "overview",
              sortBy: "circulation",
              count: 10,
              includePrices: false,
              timeframe: "current"
            };
          }
        } else {
          logger11.warn(
            "[STABLECOIN_ANALYSIS] No LLM response received, falling back to regex"
          );
          extractedParams = {
            stablecoins: extractStablecoinsFromQueryLegacy(userQuestion),
            chains: [],
            pegMechanism: [],
            metrics: [],
            analysisType: "overview",
            sortBy: "circulation",
            count: 10,
            includePrices: false,
            timeframe: "current"
          };
        }
      }
      logger11.info(
        `[STABLECOIN_ANALYSIS] Fetching data for stablecoins: ${extractedParams.stablecoins.join(", ") || "all"}`
      );
      const [stablecoins, stablecoinChains] = await Promise.all([
        defiLlamaService.getStablecoins({
          includePrices: extractedParams.includePrices || false
        }),
        defiLlamaService.getStablecoinChains()
      ]);
      const validatedStablecoins = Array.isArray(stablecoins) ? stablecoins : [];
      if (validatedStablecoins.length === 0) {
        throw new Error("No stablecoin data available from API");
      }
      const stablecoinData = buildStablecoinDataLLM(
        extractedParams,
        validatedStablecoins,
        stablecoinChains
      );
      const response = await runtime.useModel(ModelType10.LARGE, {
        prompt: `Respond concisely with stablecoin analysis based on data: ${JSON.stringify(stablecoinData)}
        and user query: ${JSON.stringify(message.content)}`
      });
      if (callback) {
        await callback({
          text: response || "Unable to analyze stablecoin data at this time.",
          actions: ["STABLECOIN_ANALYSIS"],
          source: message.content.source
        });
      }
      return {
        text: response,
        success: true,
        data: {
          actionName: "STABLECOIN_ANALYSIS",
          extractedParams,
          stablecoinData,
          stablecoinDataFetched: true,
          stablecoinsFound: stablecoinData.stablecoins.length,
          timestamp: Date.now()
        }
      };
    } catch (error) {
      logger11.error("[STABLECOIN_ANALYSIS] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      if (callback) {
        await callback({
          text: `\u274C Failed to fetch stablecoin data: ${errorMessage}`,
          actions: ["STABLECOIN_ANALYSIS"],
          source: message.content.source
        });
      }
      return {
        text: `Error fetching stablecoin data: ${errorMessage}`,
        success: false,
        error: error instanceof Error ? error : new Error(errorMessage),
        data: {
          actionName: "STABLECOIN_ANALYSIS",
          error: errorMessage,
          stablecoinDataFetched: false,
          timestamp: Date.now()
        }
      };
    }
  },
  examples: [
    [
      {
        name: "{{user}}",
        content: {
          text: "What's USDC's current market cap and circulation?"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "USDC currently has $28.1B in circulation across 15 chains, maintaining its $1.00 peg with 99.8% stability. It's the 2nd largest stablecoin by market cap.",
          actions: ["STABLECOIN_ANALYSIS"]
        }
      }
    ],
    [
      {
        name: "{{user}}",
        content: {
          text: "Compare USDT vs USDC vs DAI stability"
        }
      },
      {
        name: "{{agent}}",
        content: {
          text: "USDT: $118B circulation, fiat-backed, 99.9% peg stability. USDC: $28B circulation, fiat-backed, 99.8% stability. DAI: $4.8B circulation, crypto-backed, 99.7% stability. All maintain strong pegs.",
          actions: ["STABLECOIN_ANALYSIS"]
        }
      }
    ]
  ]
};
function buildStablecoinDataLLM(params, allStablecoins, chainData) {
  const data = {
    stablecoins: [],
    totalCirculation: 0,
    chainBreakdown: {},
    timestamp: Date.now()
  };
  let relevantStablecoins = allStablecoins;
  if (params.stablecoins && params.stablecoins.length > 0) {
    relevantStablecoins = allStablecoins.filter(
      (s) => params.stablecoins.some((target) => {
        const targetLower = target.toLowerCase();
        const nameLower = s.name?.toLowerCase() || "";
        const symbolLower = s.symbol?.toLowerCase() || "";
        return nameLower.includes(targetLower) || symbolLower.includes(targetLower) || targetLower.includes(nameLower) || targetLower.includes(symbolLower);
      })
    );
  }
  if (params.chains && params.chains.length > 0) {
    relevantStablecoins = relevantStablecoins.filter(
      (s) => s.chains && params.chains.some(
        (chain) => s.chains.some(
          (sChain) => sChain.toLowerCase().includes(chain.toLowerCase())
        )
      )
    );
  }
  if (params.pegMechanism && params.pegMechanism.length > 0) {
    relevantStablecoins = relevantStablecoins.filter(
      (s) => params.pegMechanism.some(
        (mechanism) => s.pegMechanism?.toLowerCase().includes(mechanism.toLowerCase())
      )
    );
  }
  const sortBy = params.sortBy || "circulation";
  if (sortBy === "circulation") {
    relevantStablecoins = relevantStablecoins.sort((a, b) => {
      const aCirc = a.circulating?.peggedUSD || 0;
      const bCirc = b.circulating?.peggedUSD || 0;
      return bCirc - aCirc;
    });
  } else if (sortBy === "price") {
    relevantStablecoins = relevantStablecoins.sort((a, b) => {
      const aPrice = Math.abs((a.price || 1) - 1);
      const bPrice = Math.abs((b.price || 1) - 1);
      return aPrice - bPrice;
    });
  } else if (sortBy === "name") {
    relevantStablecoins = relevantStablecoins.sort(
      (a, b) => (a.name || "").localeCompare(b.name || "")
    );
  }
  relevantStablecoins = relevantStablecoins.slice(0, params.count || 10);
  relevantStablecoins.forEach((stablecoin) => {
    const circulation = stablecoin.circulating?.peggedUSD || 0;
    data.stablecoins.push({
      id: stablecoin.id,
      name: stablecoin.name || "Unknown",
      symbol: stablecoin.symbol || "Unknown",
      pegType: stablecoin.pegType || "Unknown",
      pegMechanism: stablecoin.pegMechanism || "Unknown",
      circulating: circulation,
      chains: stablecoin.chains || [],
      price: stablecoin.price || 1,
      formatted: formatStablecoinData(stablecoin)
    });
    data.totalCirculation += circulation;
  });
  if (chainData && Array.isArray(chainData)) {
    data.chainBreakdown = chainData.reduce((acc, chain) => {
      if (chain.name && chain.totalCirculating?.peggedUSD) {
        acc[chain.name] = chain.totalCirculating.peggedUSD;
      }
      return acc;
    }, {});
  }
  return data;
}
function extractStablecoinsFromQueryLegacy(query) {
  const stablecoinKeywords = {
    usdt: "tether",
    tether: "tether",
    usdc: "usd-coin",
    "usd coin": "usd-coin",
    dai: "dai",
    frax: "frax",
    busd: "binance-usd",
    "binance usd": "binance-usd",
    tusd: "trueusd",
    "true usd": "trueusd",
    usdp: "paxos-standard",
    "pax dollar": "paxos-standard",
    gusd: "gemini-dollar",
    "gemini dollar": "gemini-dollar",
    usdd: "usdd",
    lusd: "liquity-usd",
    "liquity usd": "liquity-usd",
    ustc: "terrausd",
    "terra usd": "terrausd",
    mimatic: "mimatic",
    "mai finance": "mimatic",
    fei: "fei-usd",
    "fei usd": "fei-usd",
    ust: "terrausd-wormhole"
  };
  const found = [];
  const searchText = query.toLowerCase();
  for (const [keyword, stablecoinId] of Object.entries(stablecoinKeywords)) {
    if (searchText.includes(keyword)) {
      found.push(stablecoinId);
    }
  }
  return [...new Set(found)];
}
function formatStablecoinData(stablecoin) {
  const circulation = formatLargeNumber3(stablecoin.circulating?.peggedUSD || 0);
  const price = stablecoin.price?.toFixed(4) || "1.0000";
  return `${stablecoin.name}: $${circulation} circulation, $${price} price`;
}
function formatLargeNumber3(num) {
  if (num >= 1e12) return (num / 1e12).toFixed(1) + "T";
  if (num >= 1e9) return (num / 1e9).toFixed(1) + "B";
  if (num >= 1e6) return (num / 1e6).toFixed(1) + "M";
  if (num >= 1e3) return (num / 1e3).toFixed(1) + "K";
  return num.toFixed(0);
}

// src/providers/marketDataProvider.ts
import {
  logger as logger12
} from "@elizaos/core";
var marketDataProvider = {
  name: "MARKET_DATA_PROVIDER",
  description: "Provides overall DeFi market context including total TVL, trends, and sector performance",
  dynamic: true,
  get: async (runtime, _message, _state) => {
    try {
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      const [protocols, chains, tvlData] = await Promise.all([
        defiLlamaService.getProtocols(),
        defiLlamaService.getChains(),
        defiLlamaService.getTVL()
      ]);
      const topProtocols = protocols.sort((a, b) => (b.tvl || 0) - (a.tvl || 0)).slice(0, 10);
      const topChains = chains.sort((a, b) => (b.tvl || 0) - (a.tvl || 0)).slice(0, 8);
      const sectors = {};
      for (const protocol of protocols) {
        const category = protocol.category || "Other";
        if (!sectors[category]) {
          sectors[category] = { tvl: 0, count: 0 };
        }
        sectors[category].tvl += protocol.tvl || 0;
        sectors[category].count++;
      }
      const topSectors = Object.entries(sectors).sort(([, a], [, b]) => b.tvl - a.tvl).slice(0, 6);
      const totalTvl = tvlData.totalLiquidityUSD || 0;
      const contextText = `DeFi Market Context:

Total DeFi TVL: $${formatNumber(totalTvl)}
Active Protocols: ${protocols.length}
Supported Chains: ${chains.length}

Top 5 Protocols by TVL:
${topProtocols.map((p, i) => `${i + 1}. ${p.name}: $${formatNumber(p.tvl || 0)}`).join("\n")}

Top 5 Chains by TVL:
${topChains.map((c, i) => `${i + 1}. ${c.name}: $${formatNumber(c.tvl || 0)}`).join("\n")}

Top Sectors by TVL:
${topSectors.map(([sector, data], i) => `${i + 1}. ${sector}: $${formatNumber(data.tvl)} (${data.count} protocols)`).join("\n")}

Market Health: ${getMarketHealth(protocols)}
Recent Activity: Active trading and liquidity flows across chains`;
      return {
        text: contextText,
        values: {
          totalTvl,
          protocolCount: protocols.length,
          chainCount: chains.length,
          topProtocols: topProtocols.slice(0, 5),
          topChains: topChains.slice(0, 5),
          topSectors: topSectors.slice(0, 3)
        },
        data: {
          protocols: topProtocols,
          chains: topChains,
          sectors: topSectors,
          marketHealth: getMarketHealth(protocols)
        }
      };
    } catch (error) {
      logger12.error("Error in market data provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }
};
function formatNumber(num) {
  if (num === void 0 || num === null || isNaN(num)) return "N/A";
  if (num >= 1e9) return (num / 1e9).toFixed(1) + "B";
  if (num >= 1e6) return (num / 1e6).toFixed(1) + "M";
  if (num >= 1e3) return (num / 1e3).toFixed(1) + "K";
  return num.toFixed(0);
}
function getMarketHealth(protocols) {
  if (protocols.length < 50) return "Limited";
  if (protocols.length < 200) return "Developing";
  if (protocols.length < 500) return "Healthy";
  return "Mature";
}

// src/providers/stablecoinContextProvider.ts
import {
  logger as logger13
} from "@elizaos/core";
var stablecoinContextProvider = {
  name: "STABLECOIN_CONTEXT_PROVIDER",
  description: "Provides stablecoin market context including market cap, dominance, and risk assessment",
  dynamic: true,
  get: async (runtime, _message, _state) => {
    try {
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      const stablecoins = await defiLlamaService.getStablecoins();
      if (!stablecoins || stablecoins.length === 0) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      const processedStables = stablecoins.map((coin) => {
        const current = Object.values(coin.circulating || {}).reduce(
          (total, value) => total + (typeof value === "number" ? value : 0),
          0
        );
        const prevDay = Object.values(coin.circulatingPrevDay || {}).reduce(
          (total, value) => total + (typeof value === "number" ? value : 0),
          0
        );
        const change24h = prevDay > 0 ? (current - prevDay) / prevDay * 100 : 0;
        return {
          symbol: coin.symbol,
          name: coin.name,
          mcap: current,
          change24h,
          pegType: coin.pegType || "USD",
          mechanism: coin.pegMechanism || "Collateralized"
        };
      });
      const topStables = processedStables.sort((a, b) => b.mcap - a.mcap).slice(0, 6);
      const totalStableMarket = topStables.reduce((sum, s) => sum + s.mcap, 0);
      const usdtDominance = topStables.find((s) => s.symbol === "USDT")?.mcap || 0;
      const usdcShare = topStables.find((s) => s.symbol === "USDC")?.mcap || 0;
      const dominanceRatio = (usdtDominance + usdcShare) / totalStableMarket * 100;
      const contextText = `Stablecoin Market Context:

Total Market Cap: $${formatNumber2(totalStableMarket)}
Market Concentration: ${dominanceRatio.toFixed(1)}% (USDT+USDC)

Top Stablecoins:
${topStables.map((s, i) => {
        const share = (s.mcap / totalStableMarket * 100).toFixed(1);
        const change = s.change24h ? formatChange2(s.change24h) : "N/A";
        return `${i + 1}. ${s.symbol}: $${formatNumber2(s.mcap)} (${share}%) ${change}`;
      }).join("\n")}

Market Health: ${getStableMarketHealth(dominanceRatio, topStables.length)}
Peg Mechanisms: Diverse (Collateralized, Algorithmic, Hybrid)
Risk Assessment: ${getRiskAssessment(dominanceRatio)}`;
      return {
        text: contextText,
        values: {
          totalMarketCap: totalStableMarket,
          dominanceRatio,
          topStablecoins: topStables
        },
        data: {
          stablecoins: processedStables,
          marketHealth: getStableMarketHealth(
            dominanceRatio,
            topStables.length
          ),
          riskAssessment: getRiskAssessment(dominanceRatio)
        }
      };
    } catch (error) {
      logger13.error("Error in stablecoin context provider:", error);
      return {
        text: "",
        values: {},
        data: {}
      };
    }
  }
};
function formatNumber2(num) {
  if (num >= 1e9) return (num / 1e9).toFixed(1) + "B";
  if (num >= 1e6) return (num / 1e6).toFixed(1) + "M";
  if (num >= 1e3) return (num / 1e3).toFixed(1) + "K";
  return num.toFixed(0);
}
function formatChange2(change) {
  const sign = change >= 0 ? "+" : "";
  return `(${sign}${change.toFixed(2)}%)`;
}
function getStableMarketHealth(dominance, totalStables) {
  if (dominance > 95) return "Highly Concentrated";
  if (dominance > 85) return "Moderately Concentrated";
  if (dominance > 75) return "Balanced";
  return "Decentralized";
}
function getRiskAssessment(dominance) {
  if (dominance > 90) return "High concentration risk";
  if (dominance > 80) return "Moderate concentration risk";
  return "Well-distributed risk";
}

// src/providers/protocolSlugsProvider.ts
import {
  logger as logger14
} from "@elizaos/core";
var protocolSlugsProvider = {
  name: "PROTOCOL_SLUGS_PROVIDER",
  description: "Provides protocol slug mappings and name resolution to help agents find the correct protocol identifiers for DeFiLlama API calls",
  dynamic: true,
  get: async (runtime, message, _state) => {
    try {
      const defiLlamaService = runtime.getService(
        "defillama"
      );
      if (!defiLlamaService) {
        return {
          text: "",
          values: {},
          data: {}
        };
      }
      const protocols = await defiLlamaService.getProtocols();
      const nameToSlug = {};
      const slugToName = {};
      const aliasToSlug = {};
      for (const protocol of protocols) {
        const slug = protocol.slug;
        const name = protocol.name.toLowerCase();
        nameToSlug[name] = slug;
        slugToName[slug] = protocol.name;
        aliasToSlug[name.replace(/\s+/g, "")] = slug;
        aliasToSlug[name.replace(/\s+/g, "-")] = slug;
        if (name.includes("maker") || name.includes("makerdao")) {
          aliasToSlug["makerdao"] = slug;
          aliasToSlug["maker"] = slug;
        }
        if (name.includes("sky") && name.includes("lending")) {
          aliasToSlug["makerdao"] = slug;
          aliasToSlug["maker"] = slug;
        }
        const words = name.split(" ");
        if (words.length > 1) {
          aliasToSlug[words[0]] = slug;
          aliasToSlug[words.join("")] = slug;
        }
      }
      const topProtocols = protocols.sort((a, b) => (b.tvl || 0) - (a.tvl || 0)).slice(0, 20).map((p) => `${p.name} (${p.slug})`);
      const messageText = message.content.text?.toLowerCase() || "";
      const foundProtocols = [];
      for (const [alias, slug] of Object.entries(aliasToSlug)) {
        if (messageText.includes(alias)) {
          const protocolName = slugToName[slug];
          foundProtocols.push({
            name: protocolName,
            slug,
            confidence: messageText === alias ? "exact" : "high"
          });
        }
      }
      const uniqueProtocols = foundProtocols.filter((p, i, arr) => arr.findIndex((x) => x.slug === p.slug) === i).sort((a, b) => {
        const order = { exact: 0, high: 1, medium: 2, low: 3 };
        return (order[a.confidence] || 9) - (order[b.confidence] || 9);
      }).slice(0, 5);
      const contextText = uniqueProtocols.length > 0 ? `Protocol Matches Found:
${uniqueProtocols.map((p) => `- ${p.name} \u2192 ${p.slug} (${p.confidence} match)`).join("\n")}

Use these exact slugs for API calls.` : `No specific protocols detected in message.

Top 20 Available Protocols:
${topProtocols.slice(0, 10).join(", ")}
${topProtocols.slice(10).join(", ")}

Total available protocols: ${protocols.length}

For protocol lookups, use exact protocol slugs. Common rebrands:
- MakerDAO \u2192 Sky Lending (slug varies - check current data)`;
      return {
        text: contextText,
        values: {
          availableProtocols: protocols.length,
          foundProtocols: uniqueProtocols,
          topProtocols: topProtocols.slice(0, 10),
          nameToSlug: Object.keys(nameToSlug).slice(0, 50),
          // Limit for performance
          hasMatches: uniqueProtocols.length > 0
        },
        data: {
          nameToSlug,
          slugToName,
          aliasToSlug,
          foundProtocols: uniqueProtocols,
          topProtocols,
          allProtocols: protocols
        }
      };
    } catch (error) {
      logger14.error("Error in protocol slugs provider:", error);
      return {
        text: "Unable to load protocol mappings at this time.",
        values: {},
        data: {}
      };
    }
  }
};

// src/index.ts
var configSchema = z.object({
  DEFILLAMA_API_KEY: z.string().optional().transform((val) => {
    if (!val) {
      logger15.info("No DeFiLlama API key provided - using public endpoints");
    }
    return val;
  }),
  RATE_LIMIT_PER_MINUTE: z.string().optional().transform((val) => val ? parseInt(val) : 300),
  MAX_CONCURRENT_REQUESTS: z.string().optional().transform((val) => val ? parseInt(val) : 10)
});
var defiLlamaPlugin = {
  name: "plugin-defillama",
  description: "DeFiLlama integration for DeFi market data, analytics, and yield information",
  config: {
    DEFILLAMA_API_KEY: process.env.DEFILLAMA_API_KEY,
    RATE_LIMIT_PER_MINUTE: process.env.RATE_LIMIT_PER_MINUTE,
    MAX_CONCURRENT_REQUESTS: process.env.MAX_CONCURRENT_REQUESTS
  },
  async init(config) {
    logger15.info("Initializing DeFiLlama plugin");
    try {
      const validatedConfig = await configSchema.parseAsync(config);
      for (const [key, value] of Object.entries(validatedConfig)) {
        if (value !== void 0) {
          process.env[key] = String(value);
        }
      }
      logger15.info("DeFiLlama plugin configuration loaded", {
        rateLimitPerMinute: validatedConfig.RATE_LIMIT_PER_MINUTE
      });
      return Promise.resolve();
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new Error(
          `Invalid DeFiLlama plugin configuration: ${error.errors.map((e) => e.message).join(", ")}`
        );
      }
      throw error;
    }
  },
  services: [DefiLlamaService],
  actions: [
    protocolDataAction,
    yieldSearchAction,
    marketTrendsAction,
    historicalDataAction,
    crossChainAction,
    feesVolumeAction,
    priceDataAction,
    defiRecommendationAction,
    riskAnalysisAction,
    stablecoinAction
  ],
  providers: [
    marketDataProvider,
    stablecoinContextProvider,
    protocolSlugsProvider
  ],
  evaluators: [],
  // Plugin metadata
  routes: [],
  events: {}
};
var index_default = defiLlamaPlugin;
export {
  DefiLlamaService,
  index_default as default,
  defiLlamaPlugin
};
//# sourceMappingURL=index.js.map