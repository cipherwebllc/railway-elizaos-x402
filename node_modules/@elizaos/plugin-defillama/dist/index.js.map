{"version":3,"sources":["../src/index.ts","../src/services/defiLlamaService.ts","../src/actions/protocolDataAction.ts","../src/actions/yieldSearchAction.ts","../src/actions/marketTrendsAction.ts","../src/actions/historicalDataAction.ts","../src/actions/crossChainAction.ts","../src/actions/feesVolumeAction.ts","../src/actions/priceDataAction.ts","../src/actions/defiRecommendationAction.ts","../src/actions/riskAnalysisAction.ts","../src/actions/stablecoinAction.ts","../src/providers/marketDataProvider.ts","../src/providers/stablecoinContextProvider.ts","../src/providers/protocolSlugsProvider.ts"],"sourcesContent":["/**\n * @module plugin-defillama\n * @description DeFiLlama plugin for ElizaOS - provides DeFi market data, analytics, and yield information\n */\n\nimport { Plugin, logger } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\n// Services\nimport { DefiLlamaService } from \"./services/defiLlamaService\";\n\n// Actions\nimport { protocolDataAction } from \"./actions/protocolDataAction\";\nimport { yieldSearchAction } from \"./actions/yieldSearchAction\";\nimport { marketTrendsAction } from \"./actions/marketTrendsAction\";\nimport { historicalDataAction } from \"./actions/historicalDataAction\";\nimport { crossChainAction } from \"./actions/crossChainAction\";\nimport { feesVolumeAction } from \"./actions/feesVolumeAction\";\nimport { priceDataAction } from \"./actions/priceDataAction\";\nimport { defiRecommendationAction } from \"./actions/defiRecommendationAction\";\nimport { riskAnalysisAction } from \"./actions/riskAnalysisAction\";\nimport { stablecoinAction } from \"./actions/stablecoinAction\";\n\n// Providers (Essential context only - Actions handle user interactions via Services)\nimport { marketDataProvider } from \"./providers/marketDataProvider\";\nimport { stablecoinContextProvider } from \"./providers/stablecoinContextProvider\";\nimport { protocolSlugsProvider } from \"./providers/protocolSlugsProvider\";\n\n// Export types for external use\nexport * from \"./types\";\nexport { DefiLlamaService };\n\n/**\n * Configuration schema for the DeFiLlama plugin\n */\nconst configSchema = z.object({\n  DEFILLAMA_API_KEY: z\n    .string()\n    .optional()\n    .transform((val) => {\n      if (!val) {\n        logger.info(\"No DeFiLlama API key provided - using public endpoints\");\n      }\n      return val;\n    }),\n  RATE_LIMIT_PER_MINUTE: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseInt(val) : 300)),\n  MAX_CONCURRENT_REQUESTS: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseInt(val) : 10)),\n});\n\n/**\n * DeFiLlama plugin for ElizaOS\n *\n * Provides comprehensive DeFi market data, protocol analytics, yield information,\n * and monitoring capabilities through the DeFiLlama API.\n */\nexport const defiLlamaPlugin: Plugin = {\n  name: \"plugin-defillama\",\n  description:\n    \"DeFiLlama integration for DeFi market data, analytics, and yield information\",\n\n  config: {\n    DEFILLAMA_API_KEY: process.env.DEFILLAMA_API_KEY,\n    RATE_LIMIT_PER_MINUTE: process.env.RATE_LIMIT_PER_MINUTE,\n    MAX_CONCURRENT_REQUESTS: process.env.MAX_CONCURRENT_REQUESTS,\n  },\n\n  async init(config: Record<string, string>): Promise<void> {\n    logger.info(\"Initializing DeFiLlama plugin\");\n\n    try {\n      const validatedConfig = await configSchema.parseAsync(config);\n\n      // Set environment variables from validated config\n      for (const [key, value] of Object.entries(validatedConfig)) {\n        if (value !== undefined) {\n          process.env[key] = String(value);\n        }\n      }\n\n      logger.info(\"DeFiLlama plugin configuration loaded\", {\n        rateLimitPerMinute: validatedConfig.RATE_LIMIT_PER_MINUTE,\n      });\n\n      // Ensure promise resolves\n      return Promise.resolve();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(\n          `Invalid DeFiLlama plugin configuration: ${error.errors.map((e) => e.message).join(\", \")}`,\n        );\n      }\n      throw error;\n    }\n  },\n\n  services: [DefiLlamaService],\n\n  actions: [\n    protocolDataAction,\n    yieldSearchAction,\n    marketTrendsAction,\n    historicalDataAction,\n    crossChainAction,\n    feesVolumeAction,\n    priceDataAction,\n    defiRecommendationAction,\n    riskAnalysisAction,\n    stablecoinAction,\n  ],\n\n  providers: [\n    marketDataProvider,\n    stablecoinContextProvider,\n    protocolSlugsProvider,\n  ],\n\n  evaluators: [],\n\n  // Plugin metadata\n  routes: [],\n  events: {},\n};\n\nexport default defiLlamaPlugin;\n","import {\n  ActionResult,\n  IAgentRuntime,\n  logger,\n  Service,\n  ServiceType,\n} from \"@elizaos/core\";\nimport type {\n  APIRequest,\n  Bridge,\n  Chain,\n  Protocol,\n  ProtocolDetails,\n  YieldPool,\n  Stablecoin,\n  TVLData,\n  HistoricalData,\n  RateLimitStatus,\n  DefiLlamaConfig,\n  DefiLlamaError,\n  YieldChartData,\n  DexVolume,\n  ProtocolFees,\n  CoinPrice,\n  HistoricalPrice,\n} from \"../types\";\n\ninterface QueuedRequest<T> {\n  request: APIRequest;\n  resolve: (value: T) => void;\n  reject: (error: Error) => void;\n  timestamp: number;\n}\n\nexport class DefiLlamaService extends Service {\n  static serviceType = \"defillama\";\n  capabilityDescription =\n    \"DeFiLlama API integration for DeFi market data and analytics\";\n\n  private defiConfig: DefiLlamaConfig;\n  private requestQueue: QueuedRequest<any>[] = [];\n  private requestCount = 0;\n  private resetTime: number;\n  private isProcessingQueue = false;\n  private rateLimitStatus: RateLimitStatus;\n  private queueProcessInterval?: NodeJS.Timeout;\n  private rateLimitResetInterval?: NodeJS.Timeout;\n\n  constructor(runtime: IAgentRuntime) {\n    super(runtime);\n\n    this.defiConfig = {\n      apiBaseUrl: \"https://api.llama.fi\",\n      rateLimitPerMinute: Number(process.env.RATE_LIMIT_PER_MINUTE) || 300,\n      maxConcurrentRequests: Number(process.env.MAX_CONCURRENT_REQUESTS) || 10,\n      retryAttempts: 3,\n      retryDelay: 1000,\n    };\n\n    this.resetTime = Date.now() + 60000; // Reset every minute\n    this.rateLimitStatus = {\n      remaining: this.defiConfig.rateLimitPerMinute,\n      resetTime: this.resetTime,\n      limit: this.defiConfig.rateLimitPerMinute,\n    };\n  }\n\n  static async start(runtime: IAgentRuntime): Promise<DefiLlamaService> {\n    logger.info(\"Starting DeFiLlama service\");\n    const service = new DefiLlamaService(runtime);\n\n    // Start rate limit reset timer\n    service.rateLimitResetInterval = setInterval(() => {\n      service.requestCount = 0;\n      service.resetTime = Date.now() + 60000;\n      service.rateLimitStatus.remaining = service.defiConfig.rateLimitPerMinute;\n      service.rateLimitStatus.resetTime = service.resetTime;\n    }, 60000);\n\n    // Start queue processor\n    service.queueProcessInterval = setInterval(\n      () => service.processQueue(),\n      100,\n    );\n\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime): Promise<void> {\n    logger.info(\"Stopping DeFiLlama service\");\n    // Cleanup would go here if needed\n  }\n\n  async stop(): Promise<void> {\n    // Clear intervals\n    if (this.queueProcessInterval) {\n      clearInterval(this.queueProcessInterval);\n    }\n    if (this.rateLimitResetInterval) {\n      clearInterval(this.rateLimitResetInterval);\n    }\n\n    // Clear any pending requests\n    this.requestQueue = [];\n  }\n\n  // API Methods\n\n  async getProtocols(): Promise<ProtocolDetails[]> {\n    return this.makeRequest<ProtocolDetails[]>({\n      endpoint: \"/protocols\",\n      priority: \"medium\",\n    });\n  }\n\n  async getProtocol(slug: string): Promise<ProtocolDetails> {\n    return this.makeRequest<ProtocolDetails>({\n      endpoint: `/protocol/${slug}`,\n      priority: \"high\",\n    });\n  }\n\n  async getTVL(protocol?: string): Promise<TVLData> {\n    if (protocol) {\n      // Get TVL for specific protocol\n      const tvlValue = await this.makeRequest<number>({\n        endpoint: `/tvl/${protocol}`,\n        priority: \"medium\",\n      });\n      return {\n        date: new Date().toISOString(),\n        totalLiquidityUSD: tvlValue,\n      };\n    } else {\n      // Get total TVL from all chains\n      const chains = await this.makeRequest<Chain[]>({\n        endpoint: \"/v2/chains\",\n        priority: \"medium\",\n      });\n      const totalTVL = chains.reduce((sum, chain) => sum + (chain.tvl || 0), 0);\n      return {\n        date: new Date().toISOString(),\n        totalLiquidityUSD: totalTVL,\n      };\n    }\n  }\n\n  async getYields(): Promise<YieldPool[]> {\n    const response = await this.makeRequest<{\n      status: string;\n      data: YieldPool[];\n    }>({\n      endpoint: \"/pools\",\n      priority: \"medium\",\n    });\n    return response.data || [];\n  }\n\n  async getChains(): Promise<Chain[]> {\n    return this.makeRequest<Chain[]>({\n      endpoint: \"/v2/chains\",\n      priority: \"low\",\n    });\n  }\n\n  async getHistoricalTVL(\n    protocol: string,\n    period: string,\n  ): Promise<HistoricalData[]> {\n    const endpoint = `/protocol/${protocol}`;\n    const data = await this.makeRequest<{\n      chainTvls: Record<\n        string,\n        {\n          tvl: Array<{\n            date: number;\n            totalLiquidityUSD: number;\n          }>;\n        }\n      >;\n    }>({\n      endpoint,\n      priority: \"medium\",\n    });\n\n    // Filter based on period\n    const now = Date.now() / 1000;\n    const periodSeconds = this.parsePeriod(period);\n    const startTime = now - periodSeconds;\n\n    // Aggregate all chain TVL data into a single array\n    const allTvlData: HistoricalData[] = [];\n    const dateMap = new Map<number, number>();\n\n    // Combine TVL data from all chains\n    for (const chain of Object.values(data.chainTvls)) {\n      if (chain.tvl) {\n        for (const tvlPoint of chain.tvl) {\n          if (tvlPoint.date >= startTime) {\n            const existingValue = dateMap.get(tvlPoint.date) || 0;\n            dateMap.set(\n              tvlPoint.date,\n              existingValue + tvlPoint.totalLiquidityUSD,\n            );\n          }\n        }\n      }\n    }\n\n    // Convert map to array and sort by date\n    for (const [date, totalLiquidityUSD] of dateMap) {\n      allTvlData.push({ date, totalLiquidityUSD });\n    }\n\n    return allTvlData.sort((a, b) => a.date - b.date);\n  }\n\n  async getBridges(params?: { includeChains?: boolean }): Promise<Bridge[]> {\n    const queryParams = params\n      ? { includeChains: String(params.includeChains) }\n      : undefined;\n    const response = await this.makeRequest<{ bridges: Bridge[] }>({\n      endpoint: \"/bridges\",\n      priority: \"low\",\n      params: queryParams as Record<string, string>,\n    });\n    return response.bridges || [];\n  }\n\n  async getStablecoins(params?: {\n    includePrices?: boolean;\n  }): Promise<Stablecoin[]> {\n    const queryParams = params\n      ? { includePrices: String(params.includePrices) }\n      : undefined;\n    const response = await this.makeRequest<{ peggedAssets: Stablecoin[] }>({\n      endpoint: \"/stablecoins\",\n      priority: \"medium\",\n      params: queryParams as Record<string, string>,\n    });\n    return response.peggedAssets;\n  }\n\n  async getStablecoinChains(): Promise<Record<string, any>> {\n    return this.makeRequest<Record<string, any>>({\n      endpoint: \"/stablecoinchains\",\n      priority: \"low\",\n    });\n  }\n\n  // Additional endpoints based on DeFiLlama API specification\n\n  async getYieldChart(poolId: string): Promise<YieldChartData[]> {\n    return this.makeRequest<YieldChartData[]>({\n      endpoint: `/chart/${poolId}`,\n      priority: \"medium\",\n    });\n  }\n\n  async getDexVolumes(params?: {\n    excludeTotalDataChart?: boolean;\n    excludeTotalDataChartBreakdown?: boolean;\n  }): Promise<DexVolume[]> {\n    return this.makeRequest<DexVolume[]>({\n      endpoint: \"/overview/dexs\",\n      priority: \"medium\",\n      params: params as Record<string, string>,\n    });\n  }\n\n  async getDexVolumesByChain(\n    chain: string,\n    params?: {\n      excludeTotalDataChart?: boolean;\n      excludeTotalDataChartBreakdown?: boolean;\n    },\n  ): Promise<DexVolume[]> {\n    return this.makeRequest<DexVolume[]>({\n      endpoint: `/overview/dexs/${chain}`,\n      priority: \"medium\",\n      params: params as Record<string, string>,\n    });\n  }\n\n  async getProtocolFees(params?: {\n    excludeTotalDataChart?: boolean;\n    excludeTotalDataChartBreakdown?: boolean;\n    dataType?: string;\n  }): Promise<ProtocolFees[]> {\n    return this.makeRequest<ProtocolFees[]>({\n      endpoint: \"/overview/fees\",\n      priority: \"medium\",\n      params: params as Record<string, string>,\n    });\n  }\n\n  async getProtocolFeesByChain(\n    chain: string,\n    params?: {\n      excludeTotalDataChart?: boolean;\n      excludeTotalDataChartBreakdown?: boolean;\n      dataType?: string;\n    },\n  ): Promise<ProtocolFees[]> {\n    return this.makeRequest<ProtocolFees[]>({\n      endpoint: `/overview/fees/${chain}`,\n      priority: \"medium\",\n      params: params as Record<string, string>,\n    });\n  }\n\n  async getProtocolFeesById(protocolId: string): Promise<ProtocolFees> {\n    return this.makeRequest<ProtocolFees>({\n      endpoint: `/summary/fees/${protocolId}`,\n      priority: \"high\",\n    });\n  }\n\n  async getCoinPrices(\n    coins: string[],\n    searchWidth?: string,\n  ): Promise<{ coins: Record<string, CoinPrice> }> {\n    const params: Record<string, string> = {};\n    if (searchWidth) {\n      params.searchWidth = searchWidth;\n    }\n\n    return this.makeRequest<{ coins: Record<string, CoinPrice> }>({\n      endpoint: `/prices/current/${coins.join(\",\")}`,\n      params,\n      priority: \"high\",\n    });\n  }\n\n  async getHistoricalPrices(\n    coins: string[],\n    timestamp: number,\n  ): Promise<{ coins: Record<string, HistoricalPrice> }> {\n    return this.makeRequest<{ coins: Record<string, HistoricalPrice> }>({\n      endpoint: `/prices/historical/${timestamp}/${coins.join(\",\")}`,\n      priority: \"medium\",\n    });\n  }\n\n  async getBatchHistoricalPrices(\n    coins: string[],\n    searchWidth?: string,\n  ): Promise<Record<string, { price: number; timestamp: number }>> {\n    const params: Record<string, string> = {\n      coins: coins.join(\",\"),\n    };\n    if (searchWidth) {\n      params.searchWidth = searchWidth;\n    }\n\n    return this.makeRequest<\n      Record<string, { price: number; timestamp: number }>\n    >({\n      endpoint: \"/batchHistorical\",\n      params,\n      priority: \"medium\",\n    });\n  }\n\n  async getFirstPrices(\n    coins: string[],\n  ): Promise<{ coins: Record<string, { price: number; timestamp: number }> }> {\n    return this.makeRequest<{\n      coins: Record<string, { price: number; timestamp: number }>;\n    }>({\n      endpoint: `/prices/first/${coins.join(\",\")}`,\n      priority: \"low\",\n    });\n  }\n\n  // Rate Limiting Methods\n\n  async getRateLimitStatus(): Promise<RateLimitStatus> {\n    return this.rateLimitStatus;\n  }\n\n  async batchRequests<T>(requests: APIRequest[]): Promise<T[]> {\n    // Sort by priority\n    const sortedRequests = requests.sort((a, b) => {\n      const priorityOrder = { high: 0, medium: 1, low: 2 };\n      return priorityOrder[a.priority] - priorityOrder[b.priority];\n    });\n\n    const results = await Promise.all(\n      sortedRequests.map((req) => this.makeRequest<T>(req)),\n    );\n\n    return results;\n  }\n\n  // Private Methods\n\n  private async makeRequest<T>(request: APIRequest): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.requestQueue.push({\n        request,\n        resolve,\n        reject,\n        timestamp: Date.now(),\n      });\n\n      // Start processing queue\n      this.processQueue();\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.isProcessingQueue || this.requestQueue.length === 0) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n\n    try {\n      const now = Date.now();\n\n      // Reset counter if time window passed\n      if (now >= this.resetTime) {\n        this.requestCount = 0;\n        this.resetTime = now + 60000;\n        this.rateLimitStatus.remaining = this.defiConfig.rateLimitPerMinute;\n        this.rateLimitStatus.resetTime = this.resetTime;\n      }\n\n      // Process requests up to rate limit\n      const availableSlots =\n        this.defiConfig.rateLimitPerMinute - this.requestCount;\n      const requestsToProcess = Math.min(\n        availableSlots,\n        this.defiConfig.maxConcurrentRequests,\n        this.requestQueue.length,\n      );\n\n      if (requestsToProcess <= 0) {\n        return;\n      }\n\n      // Sort queue by priority and timestamp\n      this.requestQueue.sort((a, b) => {\n        const priorityOrder = { high: 0, medium: 1, low: 2 };\n        const priorityDiff =\n          priorityOrder[a.request.priority] - priorityOrder[b.request.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n        return a.timestamp - b.timestamp;\n      });\n\n      // Process batch\n      const batch = this.requestQueue.splice(0, requestsToProcess);\n      this.requestCount += batch.length;\n      this.rateLimitStatus.remaining =\n        this.defiConfig.rateLimitPerMinute - this.requestCount;\n\n      await Promise.all(\n        batch.map(async (item) => {\n          try {\n            const result = await this.executeRequest(item.request);\n            item.resolve(result);\n          } catch (error) {\n            item.reject(error as Error);\n          }\n        }),\n      );\n    } finally {\n      this.isProcessingQueue = false;\n    }\n  }\n\n  private async executeRequest(request: APIRequest): Promise<any> {\n    // Determine the correct base URL based on endpoint\n    let url: string;\n    if (\n      request.endpoint.startsWith(\"/stablecoins\") ||\n      request.endpoint.startsWith(\"/stablecoin\")\n    ) {\n      url = `https://stablecoins.llama.fi${request.endpoint}`;\n    } else if (\n      request.endpoint.startsWith(\"/pools\") ||\n      request.endpoint.startsWith(\"/chart/\")\n    ) {\n      url = `https://yields.llama.fi${request.endpoint}`;\n    } else if (request.endpoint.startsWith(\"/bridges\")) {\n      url = `https://bridges.llama.fi${request.endpoint}`;\n    } else if (\n      request.endpoint.startsWith(\"/prices/\") ||\n      request.endpoint === \"/batchHistorical\"\n    ) {\n      url = `https://coins.llama.fi${request.endpoint}`;\n    } else if (request.endpoint.startsWith(\"https://\")) {\n      url = request.endpoint;\n    } else {\n      url = `${this.defiConfig.apiBaseUrl}${request.endpoint}`;\n    }\n\n    const params = new URLSearchParams(request.params || {});\n    const fullUrl = params.toString() ? `${url}?${params}` : url;\n\n    for (let attempt = 0; attempt < this.defiConfig.retryAttempts; attempt++) {\n      try {\n        logger.debug(`DeFiLlama API request: ${fullUrl}`);\n\n        // Add timeout to the fetch request\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n\n        const response = await fetch(fullUrl, {\n          method: \"GET\",\n          headers: {\n            Accept: \"application/json\",\n            \"User-Agent\": \"ElizaOS-DeFiLlama-Plugin/1.0\",\n          },\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          // Check if this is a retryable error\n          const shouldRetry = this.shouldRetryError(response.status);\n          if (!shouldRetry && attempt === 0) {\n          }\n\n          throw new Error(\n            `API request failed: ${response.status} ${response.statusText}`,\n          );\n        }\n\n        const data = await response.json();\n        return data;\n      } catch (error) {\n        logger.error(`DeFiLlama API error (attempt ${attempt + 1}):`, error);\n\n        // Check if this is the last attempt or if we shouldn't retry this error\n        const isLastAttempt = attempt >= this.defiConfig.retryAttempts - 1;\n        const isRetryableError =\n          error instanceof Error &&\n          (error.name === \"AbortError\" || // Timeout\n            error.message.includes(\"500\") || // Server error\n            error.message.includes(\"502\") || // Bad Gateway\n            error.message.includes(\"503\") || // Service Unavailable\n            error.message.includes(\"429\")); // Rate limit\n\n        if (!isLastAttempt && isRetryableError) {\n          // Calculate exponential backoff with jitter\n          const baseDelay = this.defiConfig.retryDelay * Math.pow(2, attempt);\n          const jitter = Math.random() * 1000; // Add up to 1 second of jitter\n          const delay = baseDelay + jitter;\n\n          logger.debug(`Retrying in ${delay}ms...`);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } else {\n          const defiError: DefiLlamaError = {\n            code: \"API_ERROR\",\n            message: \"Failed to fetch data from DeFiLlama API\",\n            details: error,\n            suggestions: [\n              \"Try again later\",\n              \"Check your internet connection\",\n              error instanceof Error && error.message.includes(\"404\")\n                ? \"The requested resource may not exist\"\n                : \"This may be a temporary service issue\",\n            ],\n            fallbackAvailable: false,\n          };\n\n          throw new Error(JSON.stringify(defiError));\n        }\n      }\n    }\n  }\n\n  private shouldRetryError(statusCode: number): boolean {\n    // Don't retry client errors (4xx) except rate limiting\n    if (statusCode >= 400 && statusCode < 500) {\n      return statusCode === 429; // Only retry rate limit errors\n    }\n\n    // Retry server errors (5xx)\n    if (statusCode >= 500) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parsePeriod(period: string): number {\n    const units: Record<string, number> = {\n      \"1d\": 86400,\n      \"7d\": 604800,\n      \"30d\": 2592000,\n      \"90d\": 7776000,\n      \"1y\": 31536000,\n    };\n\n    return units[period] || 604800; // Default to 7 days\n  }\n}\n","/**\n * Protocol Data Action\n *\n * Direct DeFi protocol data fetcher that retrieves protocol information\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Protocol name/symbol resolution from natural language queries using LLM\n * - Current protocol metrics (TVL, rankings, category data)\n * - Multi-protocol batch data retrieval\n * - Smart protocol validation using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract protocols from user query using LLM\n * 2. Fetch protocol data from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\n// Simple type for protocol data\ninterface ProtocolData {\n  name: string;\n  slug: string;\n  tvl: number;\n  rank: number;\n  category: string;\n  chains: number;\n  change_1d: number;\n  change_7d: number;\n  change_30d: number;\n  formatted: string;\n}\n\nconst extractProtocolsTemplate = `Extract protocol and analysis information from the user's request for DeFi protocol data.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- Protocol responses use proper case names: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n- Category names match API format: \"Dexs\", \"Lending\", \"Liquid Staking\", \"Derivatives\", \"Yield\", \"CDP\", \"Bridge\"\n- Chain filtering should use proper case as returned by /v2/chains endpoint\n\nThe user might express protocol requests in various ways:\n- \"What's Aave's TVL?\" → specific protocol: \"Aave\"\n- \"Compare Uniswap and SushiSwap\" → multiple protocols: [\"Uniswap\", \"SushiSwap\"]\n- \"Top lending protocols\" → category: \"lending\"\n- \"Show me DEX rankings\" → category: \"dex\"\n- \"Best yield farming protocols\" → category: \"yield\"\n- \"Ethereum DeFi protocols\" → chain: \"Ethereum\"\n- \"Protocol analysis for MakerDAO and Compound\" → protocols: [\"MakerDAO\", \"Compound\"]\n- \"TVL comparison of top 5 protocols\" → analysis: \"top_ranking\", count: 5\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"protocols\": [\"Protocol names if specifically mentioned\"],\n  \"categories\": [\"Category names if mentioned: Dexs/Lending/Liquid Staking/Derivatives/Yield/CDP/Bridge\"],\n  \"chains\": [\"Chain names as per /v2/chains endpoint: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche\"],\n  \"analysisType\": \"specific/comparison/ranking/category_analysis/overview\",\n  \"metrics\": [\"tvl/ranking/volume/fees/apy if specifically requested\"],\n  \"count\": number (if user wants top N protocols),\n  \"timeframe\": \"24h/7d/30d if mentioned for changes\",\n  \"includeDetails\": true/false (if user wants detailed breakdown)\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const protocolDataAction: Action = {\n  name: \"PROTOCOL_DATA\",\n  similes: [\n    \"GET_PROTOCOL\",\n    \"PROTOCOL_INFO\",\n    \"PROTOCOL_TVL\",\n    \"PROTOCOL_STATS\",\n    \"COMPARE_PROTOCOLS\",\n    \"PROTOCOL_ANALYSIS\",\n    \"PROTOCOL_METRICS\",\n    \"PROTOCOL_RESEARCH\",\n    \"COMPETITIVE_ANALYSIS\",\n    \"PROTOCOL_INTELLIGENCE\",\n    \"MARKET_POSITION\",\n    \"PROTOCOL_HEALTH\",\n  ],\n  description: `Simple DeFi protocol data fetcher. This action:\n1. Extracts protocol names/categories from user queries using LLM\n2. Fetches current protocol data from DeFiLlama API\n3. Returns clean, structured protocol data for analysis or display\n4. Supports multiple protocols and basic protocol information\n\nUSE WHEN: User asks about specific protocols, TVL data, or protocol comparisons.\nRETURNS: Raw protocol data without extensive analysis - focused on data retrieval.`,\n\n  validate: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state: State | undefined,\n  ): Promise<boolean> => {\n    const text = message.content.text?.toLowerCase() || \"\";\n\n    // Check for protocol keywords\n    const protocolKeywords = [\n      \"protocol\",\n      \"tvl\",\n      \"total value locked\",\n      \"defi\",\n      \"ranking\",\n      \"compare\",\n      \"aave\",\n      \"compound\",\n      \"uniswap\",\n      \"curve\",\n      \"makerdao\",\n      \"top protocols\",\n      \"market share\",\n      \"liquidity\",\n      \"dex\",\n      \"dexs\",\n      \"decentralized exchange\",\n      \"trading\",\n      \"swap\",\n      \"swapping\",\n      \"amm\",\n      \"automated market maker\",\n      \"pancakeswap\",\n      \"sushiswap\",\n      \"balancer\",\n      \"1inch\",\n      \"0x\",\n      \"exchange\",\n    ];\n\n    return protocolKeywords.some((keyword) => text.includes(keyword));\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    try {\n      logger.info(\"[PROTOCOL_DATA] Starting protocol data fetch\");\n\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const userQuestion = message.content.text || \"\";\n\n      // Extract protocol information using LLM first, with fallback to regex\n      let extractedParams: any = {};\n\n      // Check if we have explicit params in options\n      if (options?.protocolParams) {\n        extractedParams = options.protocolParams;\n      } else {\n        // Use LLM to extract protocol information\n        const prompt = extractProtocolsTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              protocols: parsed.protocols || [],\n              categories: parsed.categories || [],\n              chains: parsed.chains || [],\n              analysisType: parsed.analysisType || \"overview\",\n              metrics: parsed.metrics || [],\n              count: parsed.count || 10,\n              timeframe: parsed.timeframe || \"24h\",\n              includeDetails: parsed.includeDetails || false,\n            };\n\n            logger.info(\n              `[PROTOCOL_DATA] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            extractedParams = {\n              protocols: [],\n              categories: [extractCategoryFromQueryLegacy(userQuestion)].filter(\n                Boolean,\n              ),\n              chains: [],\n              analysisType: \"overview\",\n              metrics: [],\n              count: 10,\n              timeframe: \"24h\",\n              includeDetails: false,\n            };\n          }\n        } else {\n          logger.warn(\n            \"[PROTOCOL_DATA] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          extractedParams = {\n            protocols: [],\n            categories: [extractCategoryFromQueryLegacy(userQuestion)].filter(\n              Boolean,\n            ),\n            chains: [],\n            analysisType: \"overview\",\n            metrics: [],\n            count: 10,\n            timeframe: \"24h\",\n            includeDetails: false,\n          };\n        }\n      }\n\n      logger.info(\n        `[PROTOCOL_DATA] Processing request with categories: ${extractedParams.categories.join(\", \")}, protocols: ${extractedParams.protocols.join(\", \")}`,\n      );\n\n      // Fetch protocol data\n      const [protocols, chains] = await Promise.all([\n        defiLlamaService.getProtocols(),\n        defiLlamaService.getChains(),\n      ]);\n\n      // Validate API responses\n      const validatedProtocols = Array.isArray(protocols) ? protocols : [];\n\n      if (validatedProtocols.length === 0) {\n        throw new Error(\"No protocol data available from API\");\n      }\n\n      // Extract target protocols using LLM-extracted parameters\n      const targetProtocols = extractProtocolsFromDataLLM(\n        extractedParams,\n        validatedProtocols,\n      );\n\n      logger.info(\n        `[PROTOCOL_DATA] Found protocols: ${targetProtocols.map((p) => p.name).join(\", \")}`,\n      );\n\n      // Filter and structure protocol data\n      const protocolData = buildProtocolData(\n        targetProtocols,\n        validatedProtocols,\n        extractedParams.categories[0], // Use first category if multiple\n        extractedParams.count,\n      );\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with protocol analysis based on data: ${JSON.stringify(protocolData)}\n        and user query: ${JSON.stringify(message.content)}`,\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to analyze protocol data at this time.\",\n          actions: ['PROTOCOL_DATA'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response,\n        success: true,\n        data: {\n          actionName: \"PROTOCOL_DATA\",\n          extractedParams,\n          targetProtocols,\n          protocolData,\n          protocolDataFetched: true,\n          protocolsFound: protocolData.protocols.length,\n          timestamp: Date.now(),\n        },\n      };\n    } catch (error) {\n      logger.error(\"[PROTOCOL_DATA] Error:\", error);\n\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n\n      if (callback) {\n        await callback({\n          text: `❌ Failed to fetch protocol data: ${errorMessage}`,\n          actions: [\"PROTOCOL_DATA\"],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: `Error fetching protocol data: ${errorMessage}`,\n        success: false,\n        error: error instanceof Error ? error : new Error(errorMessage),\n        data: {\n          actionName: \"PROTOCOL_DATA\",\n          error: errorMessage,\n          protocolDataFetched: false,\n          timestamp: Date.now(),\n        },\n      };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"What is Aave's current TVL and ranking?\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Aave currently ranks #2 in DeFi with $12.8B TVL, up 2.3% over 24h. It's the leading lending protocol with deployments across 8 chains.\",\n          actions: [\"PROTOCOL_DATA\"],\n        },\n      },\n    ],\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"Compare Uniswap and SushiSwap TVL\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Uniswap: $5.2B TVL (Rank #5), SushiSwap: $890M TVL (Rank #23). Uniswap leads with 5.8x higher TVL in the DEX category.\",\n          actions: [\"PROTOCOL_DATA\"],\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for protocol data extraction and formatting\n\nfunction extractProtocolsFromDataLLM(params: any, protocols: any[]): any[] {\n  let foundProtocols: any[] = [];\n\n  // If specific protocols mentioned, search for them\n  if (params.protocols && params.protocols.length > 0) {\n    for (const protocolName of params.protocols) {\n      const protocol = findProtocolByName(protocolName, protocols);\n      if (protocol) {\n        foundProtocols.push(protocol);\n      }\n    }\n  }\n\n  // If categories specified, filter by category\n  if (params.categories && params.categories.length > 0) {\n    for (const category of params.categories) {\n      const categoryProtocols = protocols.filter(\n        (p) =>\n          p.category && p.category.toLowerCase() === category.toLowerCase(),\n      );\n      foundProtocols.push(...categoryProtocols);\n    }\n  }\n\n  // If chains specified, filter by chain (this would need chain-specific protocol data)\n  if (params.chains && params.chains.length > 0) {\n    // Note: This would need additional logic to filter by chains\n    // For now, we'll include all protocols that support the specified chains\n    const chainProtocols = protocols.filter(\n      (p) =>\n        p.chains &&\n        params.chains.some((chain: string) =>\n          p.chains.some(\n            (pChain: string) => pChain.toLowerCase() === chain.toLowerCase(),\n          ),\n        ),\n    );\n    foundProtocols.push(...chainProtocols);\n  }\n\n  // Remove duplicates\n  foundProtocols = foundProtocols.filter(\n    (protocol, index, self) =>\n      index === self.findIndex((p) => p.slug === protocol.slug),\n  );\n\n  // If no specific protocols found, return top protocols\n  if (foundProtocols.length === 0) {\n    foundProtocols = protocols.slice(0, params.count || 10);\n  }\n\n  return foundProtocols;\n}\n\nfunction findProtocolByName(name: string, protocols: any[]): any | null {\n  const searchName = name.toLowerCase();\n\n  // Try exact matches first\n  let protocol = protocols.find(\n    (p) =>\n      p.name.toLowerCase() === searchName ||\n      p.slug.toLowerCase() === searchName ||\n      p.symbol?.toLowerCase() === searchName,\n  );\n\n  if (protocol) return protocol;\n\n  // Try partial matches\n  protocol = protocols.find(\n    (p) =>\n      p.name.toLowerCase().includes(searchName) ||\n      searchName.includes(p.name.toLowerCase()) ||\n      (p.slug && p.slug.toLowerCase().includes(searchName)) ||\n      (p.symbol && searchName.includes(p.symbol.toLowerCase())),\n  );\n\n  return protocol || null;\n}\n\nfunction extractCategoryFromQueryLegacy(query: string): string | null {\n  const searchText = query.toLowerCase();\n\n  // Category mapping with keywords based on actual API categories\n  const categoryMappings = {\n    Dexs: [\n      \"dex\",\n      \"dexs\",\n      \"decentralized exchange\",\n      \"trading\",\n      \"swap\",\n      \"swapping\",\n      \"amm\",\n      \"automated market maker\",\n      \"trading experience\",\n      \"best trading\",\n      \"trading platform\",\n      \"exchange protocols\",\n    ],\n    Lending: [\n      \"lending\",\n      \"borrow\",\n      \"borrowing\",\n      \"loan\",\n      \"loans\",\n      \"credit\",\n      \"lending protocol\",\n      \"borrowing platform\",\n      \"lend\",\n    ],\n    \"Liquid Staking\": [\n      \"liquid staking\",\n      \"staking\",\n      \"stake\",\n      \"validator\",\n      \"liquid stake\",\n      \"staking protocol\",\n      \"staking platform\",\n    ],\n    Derivatives: [\n      \"derivatives\",\n      \"perp\",\n      \"perpetual\",\n      \"futures\",\n      \"options\",\n      \"derivative protocol\",\n      \"trading derivatives\",\n    ],\n    Yield: [\n      \"yield\",\n      \"yield farming\",\n      \"farming\",\n      \"liquidity mining\",\n      \"yield protocol\",\n      \"yield platform\",\n      \"yields\",\n    ],\n    CDP: [\n      \"cdp\",\n      \"collateralized debt position\",\n      \"collateral\",\n      \"debt position\",\n      \"cdp protocol\",\n      \"maker\",\n      \"makerdao\",\n    ],\n    Bridge: [\n      \"bridge\",\n      \"cross-chain\",\n      \"cross chain\",\n      \"bridging\",\n      \"bridge protocol\",\n    ],\n  };\n\n  // Check each category\n  for (const [category, keywords] of Object.entries(categoryMappings)) {\n    if (keywords.some((keyword) => searchText.includes(keyword))) {\n      return category;\n    }\n  }\n\n  return null; // No specific category detected\n}\n\nfunction buildProtocolData(\n  targetProtocols: any[],\n  allProtocols: any[],\n  categoryFilter: string | null = null,\n  count: number = 10,\n): any {\n  const data: any = {\n    protocols: [],\n    totalTvl: 0,\n    categoryBreakdown: {},\n    timestamp: Date.now(),\n  };\n\n  let relevantProtocols = allProtocols;\n\n  // Filter by category if specified\n  if (categoryFilter) {\n    relevantProtocols = allProtocols.filter(\n      (p) => p.category === categoryFilter,\n    );\n  }\n\n  // If specific protocols found, use those\n  if (targetProtocols.length > 0) {\n    relevantProtocols = targetProtocols;\n  }\n\n  // Sort by TVL and take top protocols\n  relevantProtocols = relevantProtocols\n    .sort((a, b) => (b.tvl || 0) - (a.tvl || 0))\n    .slice(0, count);\n\n  // Build protocol data\n  relevantProtocols.forEach((protocol, index) => {\n    data.protocols.push({\n      name: protocol.name,\n      slug: protocol.slug,\n      tvl: protocol.tvl || 0,\n      rank: calculateProtocolRank(protocol, allProtocols),\n      category: protocol.category || \"Unknown\",\n      chains: protocol.chains?.length || 0,\n      change_1d: protocol.change_1d || 0,\n      change_7d: protocol.change_7d || 0,\n      change_30d: protocol.change_30d || 0,\n      formatted: formatProtocolData(protocol),\n    });\n\n    data.totalTvl += protocol.tvl || 0;\n  });\n\n  // Build category breakdown\n  data.categoryBreakdown = allProtocols.reduce((acc: any, p: any) => {\n    const category = p.category || \"Other\";\n    acc[category] = (acc[category] || 0) + (p.tvl || 0);\n    return acc;\n  }, {});\n\n  return data;\n}\n\n// Utility functions\n\nfunction calculateProtocolRank(protocol: any, allProtocols: any[]): number {\n  const sorted = allProtocols.sort((a, b) => (b.tvl || 0) - (a.tvl || 0));\n  return sorted.findIndex((p) => p.slug === protocol.slug) + 1;\n}\n\nfunction formatProtocolData(protocol: any): string {\n  const tvl = formatTvl(protocol.tvl || 0);\n  const change = formatChange(protocol.change_1d);\n  return `${protocol.name}: $${tvl} TVL (${change} 24h)`;\n}\n\nfunction formatTvl(tvl: number): string {\n  if (tvl >= 1e9) return (tvl / 1e9).toFixed(1) + \"B\";\n  if (tvl >= 1e6) return (tvl / 1e6).toFixed(1) + \"M\";\n  if (tvl >= 1e3) return (tvl / 1e3).toFixed(1) + \"K\";\n  return tvl.toFixed(0);\n}\n\nfunction formatChange(change: number | undefined): string {\n  if (!change) return \"N/A\";\n  const sign = change >= 0 ? \"+\" : \"\";\n  return `${sign}${change.toFixed(1)}%`;\n}\n","/**\n * Yield Search Action\n *\n * Direct yield opportunity fetcher that retrieves yield farming data\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Asset/protocol/chain filtering from natural language queries using LLM\n * - Current yield pool data (APY, TVL, chains, protocols)\n * - Multi-filter yield pool retrieval\n * - Smart yield filtering using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract yield criteria from user query using LLM\n * 2. Fetch yield data from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\n// Simple type for yield data\ninterface YieldData {\n  pool: string;\n  project: string;\n  symbol: string;\n  chain: string;\n  tvlUsd: number;\n  apy: number;\n  apyBase: number;\n  apyReward: number;\n  rewardTokens: string[];\n  underlyingTokens: string[];\n  poolMeta: string;\n  formatted: string;\n}\n\nconst extractYieldTemplate = `Extract yield search criteria from the user's request for DeFi yield farming opportunities.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /pools endpoint returns data with chain names in proper case: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n- Protocol names as returned by API: \"Aave\", \"Compound\", \"Uniswap\", \"Curve\", etc.\n- Asset symbols as in underlyingTokens/symbol fields: \"USDC\", \"ETH\", \"WBTC\", etc.\n\nThe user might express yield requests in various ways:\n- \"Best USDC yields\" → asset: \"USDC\", sortBy: \"apy\"\n- \"Aave staking opportunities\" → protocol: \"Aave\"\n- \"High APY farming above 15%\" → minApy: 15, riskTolerance: \"high\"\n- \"Safe stablecoin yields on Polygon\" → chains: [\"Polygon\"], assets: [\"stablecoins\"], riskTolerance: \"low\"\n- \"Ethereum lending yields under 10%\" → chains: [\"Ethereum\"], maxApy: 10, categories: [\"lending\"]\n- \"Auto-compounding WETH farms\" → assets: [\"WETH\"], features: [\"auto-compound\"]\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"assets\": [\"Asset symbols if mentioned: USDC/ETH/WBTC/DAI/stablecoins\"],\n  \"protocols\": [\"Protocol names if mentioned: Aave/Compound/Uniswap/Curve\"],\n  \"chains\": [\"Chain names as per /pools endpoint: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche\"],\n  \"minApy\": number (minimum APY if specified),\n  \"maxApy\": number (maximum APY if specified),\n  \"minTvl\": number (minimum TVL in USD if specified),\n  \"riskTolerance\": \"low/medium/high/any (based on user preference)\",\n  \"categories\": [\"lending/dex/staking/farming if mentioned\"],\n  \"features\": [\"auto-compound/rewards/stable if mentioned\"],\n  \"sortBy\": \"apy/tvl/project (how to sort results)\",\n  \"limit\": number (how many results, default 15)\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const yieldSearchAction: Action = {\n  name: \"YIELD_SEARCH\",\n  similes: [\n    \"FIND_YIELDS\",\n    \"YIELD_FARMING\",\n    \"BEST_APY\",\n    \"STAKING_YIELDS\",\n    \"FARM_SEARCH\",\n    \"APY_SEARCH\",\n    \"YIELD_OPPORTUNITIES\",\n    \"FARMING_OPTIONS\",\n    \"STAKE_REWARDS\",\n    \"LIQUIDITY_MINING\",\n  ],\n  description: `Simple yield opportunity finder. This action:\n1. Extracts yield search criteria from user queries using LLM\n2. Fetches current yield pool data from DeFiLlama API\n3. Returns clean, structured yield data for analysis or display\n4. Supports filtering by protocol, asset, chain, and APY ranges\n\nUSE WHEN: User asks about yield farming, staking rewards, APY opportunities, or specific yield strategies.\nRETURNS: Raw yield data without extensive analysis - focused on data retrieval.`,\n\n  validate: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state: State | undefined,\n  ): Promise<boolean> => {\n    const text = message.content.text?.toLowerCase() || \"\";\n\n    const yieldKeywords = [\n      \"yield\",\n      \"apy\",\n      \"apr\",\n      \"farming\",\n      \"staking\",\n      \"returns\",\n      \"interest\",\n      \"earn\",\n      \"best yields\",\n      \"high apy\",\n      \"stable yields\",\n      \"usdc yield\",\n      \"eth yield\",\n      \"stablecoin yield\",\n      \"farm\",\n      \"stake\",\n      \"liquidity mining\",\n      \"rewards\",\n      \"yield opportunities\",\n      \"passive income\",\n      \"compound\",\n      \"auto-compound\",\n    ];\n\n    return yieldKeywords.some((keyword) => text.includes(keyword));\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    try {\n      logger.info(\"[YIELD_SEARCH] Starting yield data fetch\");\n\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const userQuestion = message.content.text || \"\";\n\n      // Extract yield criteria using LLM first, with fallback to regex\n      let yieldCriteria: any;\n\n      // Check if we have explicit criteria in options\n      if (options?.yieldParams) {\n        yieldCriteria = options.yieldParams;\n      } else {\n        // Use LLM to extract yield criteria\n        const prompt = extractYieldTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            yieldCriteria = {\n              assets: parsed.assets || [],\n              protocols: parsed.protocols || [],\n              chains: parsed.chains || [],\n              minApy: parsed.minApy || 0,\n              maxApy: parsed.maxApy || 1000,\n              minTvl: parsed.minTvl || 0,\n              riskTolerance: parsed.riskTolerance || \"any\",\n              categories: parsed.categories || [],\n              features: parsed.features || [],\n              sortBy: parsed.sortBy || \"apy\",\n              limit: parsed.limit || 15,\n            };\n\n            logger.info(\n              `[YIELD_SEARCH] LLM extracted criteria: ${JSON.stringify(yieldCriteria)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            yieldCriteria = extractYieldCriteriaLegacy(userQuestion);\n          }\n        } else {\n          logger.warn(\n            \"[YIELD_SEARCH] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          yieldCriteria = extractYieldCriteriaLegacy(userQuestion);\n        }\n      }\n\n      logger.info(\n        `[YIELD_SEARCH] Fetching yields with criteria: ${JSON.stringify(yieldCriteria)}`,\n      );\n\n      // Fetch yield data\n      const yields = await defiLlamaService.getYields();\n\n      // Validate API response\n      const validatedYields = Array.isArray(yields) ? yields : [];\n\n      if (validatedYields.length === 0) {\n        throw new Error(\"No yield data available from API\");\n      }\n\n      // Filter and structure yield data\n      const yieldData = buildYieldData(yieldCriteria, validatedYields);\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with yield analysis based on data: ${JSON.stringify(yieldData)}\n        and user query: ${JSON.stringify(message.content)}`,\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to fetch yield data at this time.\",\n          actions: ['YIELD_SEARCH'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response,\n        success: true,\n        data: {\n          actionName: \"YIELD_SEARCH\",\n          extractedCriteria: yieldCriteria,\n          yieldData,\n          yieldDataFetched: true,\n          yieldsFound: yieldData.yields.length,\n          timestamp: Date.now(),\n        },\n      };\n    } catch (error) {\n      logger.error(\"[YIELD_SEARCH] Error:\", error);\n\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n\n      if (callback) {\n        await callback({\n          text: `❌ Failed to fetch yield data: ${errorMessage}`,\n          actions: [\"YIELD_SEARCH\"],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: `Error fetching yield data: ${errorMessage}`,\n        success: false,\n        error: error instanceof Error ? error : new Error(errorMessage),\n        data: {\n          actionName: \"YIELD_SEARCH\",\n          error: errorMessage,\n          yieldDataFetched: false,\n          timestamp: Date.now(),\n        },\n      };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"What are the best USDC yields right now?\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Best USDC yields: Aave V3 Polygon 4.2% APY ($45M TVL), Compound V3 3.8% APY ($120M TVL), Venus BSC 5.1% APY ($12M TVL). All are stable lending yields with low risk.\",\n          actions: [\"YIELD_SEARCH\"],\n        },\n      },\n    ],\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"Find me high APY farming opportunities above 15%\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"High APY opportunities: PancakeSwap CAKE-BNB 18.5% APY, TraderJoe AVAX-USDC 22.1% APY, SpookySwap BOO-FTM 28.3% APY. Note: Higher APY carries increased impermanent loss and smart contract risks.\",\n          actions: [\"YIELD_SEARCH\"],\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for yield data extraction and formatting\n\nfunction extractYieldCriteriaLegacy(query: string): any {\n  const searchText = query.toLowerCase();\n\n  const criteria: any = {\n    assets: [],\n    protocols: [],\n    chains: [],\n    minApy: 0,\n    maxApy: 1000,\n    riskLevel: \"any\",\n  };\n\n  // Extract asset preferences\n  const assetKeywords = {\n    usdc: \"usdc\",\n    usdt: \"usdt\",\n    dai: \"dai\",\n    eth: \"eth\",\n    weth: \"weth\",\n    btc: \"btc\",\n    wbtc: \"wbtc\",\n    matic: \"matic\",\n    avax: \"avax\",\n    bnb: \"bnb\",\n    stablecoin: [\"usdc\", \"usdt\", \"dai\", \"frax\", \"busd\"],\n  };\n\n  for (const [keyword, assets] of Object.entries(assetKeywords)) {\n    if (searchText.includes(keyword)) {\n      criteria.assets.push(...(Array.isArray(assets) ? assets : [assets]));\n    }\n  }\n\n  // Extract protocol preferences\n  const protocolKeywords = {\n    aave: \"aave\",\n    compound: \"compound\",\n    uniswap: \"uniswap\",\n    sushiswap: \"sushiswap\",\n    pancakeswap: \"pancakeswap\",\n    curve: \"curve\",\n    yearn: \"yearn\",\n    convex: \"convex\",\n    lido: \"lido\",\n    maker: \"maker\",\n  };\n\n  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {\n    if (searchText.includes(keyword)) {\n      criteria.protocols.push(protocol);\n    }\n  }\n\n  // Extract chain preferences\n  const chainKeywords = {\n    ethereum: \"Ethereum\",\n    polygon: \"Polygon\",\n    arbitrum: \"Arbitrum\",\n    optimism: \"Optimism\",\n    avalanche: \"Avalanche\",\n    bsc: \"BSC\",\n    fantom: \"Fantom\",\n    solana: \"Solana\",\n  };\n\n  for (const [keyword, chain] of Object.entries(chainKeywords)) {\n    if (searchText.includes(keyword)) {\n      criteria.chains.push(chain);\n    }\n  }\n\n  // Extract APY requirements\n  const apyMatch = searchText.match(/(\\d+)%?\\s*(apy|apr|yield)/i);\n  if (apyMatch) {\n    const apy = parseInt(apyMatch[1]);\n    if (\n      searchText.includes(\"above\") ||\n      searchText.includes(\"over\") ||\n      searchText.includes(\"high\")\n    ) {\n      criteria.minApy = apy;\n    } else if (searchText.includes(\"under\") || searchText.includes(\"below\")) {\n      criteria.maxApy = apy;\n    }\n  }\n\n  // Extract risk preferences\n  if (\n    searchText.includes(\"safe\") ||\n    searchText.includes(\"stable\") ||\n    searchText.includes(\"low risk\")\n  ) {\n    criteria.riskLevel = \"low\";\n  } else if (\n    searchText.includes(\"high risk\") ||\n    searchText.includes(\"aggressive\")\n  ) {\n    criteria.riskLevel = \"high\";\n  }\n\n  return criteria;\n}\n\nfunction buildYieldData(criteria: any, allYields: any[]): any {\n  const data: any = {\n    yields: [],\n    totalTvl: 0,\n    averageApy: 0,\n    timestamp: Date.now(),\n  };\n\n  let filteredYields = allYields;\n\n  // Filter by assets (case-insensitive for robustness)\n  if (criteria.assets && criteria.assets.length > 0) {\n    filteredYields = filteredYields.filter((y) => {\n      const symbol = y.symbol?.toLowerCase() || \"\";\n      const underlying =\n        y.underlyingTokens?.map((t: string) => t.toLowerCase()) || [];\n      return criteria.assets.some((asset: string) => {\n        const searchAsset = asset.toLowerCase();\n        if (searchAsset === \"stablecoins\") {\n          return [\"usdc\", \"usdt\", \"dai\", \"frax\", \"busd\"].some(\n            (stable) =>\n              symbol.includes(stable) ||\n              underlying.some((u: string) => u.includes(stable)),\n          );\n        }\n        return (\n          symbol.includes(searchAsset) ||\n          underlying.some((u: string) => u.includes(searchAsset))\n        );\n      });\n    });\n  }\n\n  // Filter by protocols (case-insensitive)\n  if (criteria.protocols && criteria.protocols.length > 0) {\n    filteredYields = filteredYields.filter((y) =>\n      criteria.protocols.some((protocol: string) =>\n        y.project?.toLowerCase().includes(protocol.toLowerCase()),\n      ),\n    );\n  }\n\n  // Filter by chains (case-insensitive)\n  if (criteria.chains && criteria.chains.length > 0) {\n    filteredYields = filteredYields.filter((y) =>\n      criteria.chains.some((chain: string) =>\n        y.chain?.toLowerCase().includes(chain.toLowerCase()),\n      ),\n    );\n  }\n\n  // Filter by APY range\n  filteredYields = filteredYields.filter((y) => {\n    const apy = y.apy || 0;\n    return apy >= (criteria.minApy || 0) && apy <= (criteria.maxApy || 1000);\n  });\n\n  // Filter by TVL if specified\n  if (criteria.minTvl && criteria.minTvl > 0) {\n    filteredYields = filteredYields.filter(\n      (y) => (y.tvlUsd || 0) >= criteria.minTvl,\n    );\n  }\n\n  // Filter by risk level\n  if (criteria.riskTolerance === \"low\") {\n    filteredYields = filteredYields.filter((y) => {\n      const apy = y.apy || 0;\n      const tvl = y.tvlUsd || 0;\n      // Conservative: lower APY, higher TVL\n      return apy < 15 && tvl > 1000000; // < 15% APY, > $1M TVL\n    });\n  } else if (criteria.riskTolerance === \"high\") {\n    filteredYields = filteredYields.filter((y) => {\n      const apy = y.apy || 0;\n      // Aggressive: higher APY\n      return apy > 20; // > 20% APY\n    });\n  }\n\n  // Sort based on criteria\n  const sortBy = criteria.sortBy || \"apy\";\n  if (sortBy === \"apy\") {\n    filteredYields = filteredYields.sort((a, b) => (b.apy || 0) - (a.apy || 0));\n  } else if (sortBy === \"tvl\") {\n    filteredYields = filteredYields.sort(\n      (a, b) => (b.tvlUsd || 0) - (a.tvlUsd || 0),\n    );\n  } else if (sortBy === \"project\") {\n    filteredYields = filteredYields.sort((a, b) =>\n      (a.project || \"\").localeCompare(b.project || \"\"),\n    );\n  }\n\n  // Take top results based on limit\n  filteredYields = filteredYields.slice(0, criteria.limit || 15);\n\n  // Build yield data\n  filteredYields.forEach((yieldPool) => {\n    data.yields.push({\n      pool: yieldPool.pool,\n      project: yieldPool.project || \"Unknown\",\n      symbol: yieldPool.symbol || \"Unknown\",\n      chain: yieldPool.chain || \"Unknown\",\n      tvlUsd: yieldPool.tvlUsd || 0,\n      apy: yieldPool.apy || 0,\n      apyBase: yieldPool.apyBase || 0,\n      apyReward: yieldPool.apyReward || 0,\n      rewardTokens: yieldPool.rewardTokens || [],\n      underlyingTokens: yieldPool.underlyingTokens || [],\n      poolMeta: yieldPool.poolMeta || \"\",\n      formatted: formatYieldData(yieldPool),\n    });\n\n    data.totalTvl += yieldPool.tvlUsd || 0;\n  });\n\n  // Calculate average APY\n  if (data.yields.length > 0) {\n    data.averageApy =\n      data.yields.reduce((sum: number, y: any) => sum + y.apy, 0) /\n      data.yields.length;\n  }\n\n  return data;\n}\n\n// Utility functions\n\nfunction formatYieldData(yieldPool: any): string {\n  const apy = (yieldPool.apy || 0).toFixed(1);\n  const tvl = formatLargeNumber(yieldPool.tvlUsd || 0);\n  return `${yieldPool.project} ${yieldPool.symbol}: ${apy}% APY, $${tvl} TVL`;\n}\n\nfunction formatLargeNumber(num: number): string {\n  if (num >= 1e9) return (num / 1e9).toFixed(1) + \"B\";\n  if (num >= 1e6) return (num / 1e6).toFixed(1) + \"M\";\n  if (num >= 1e3) return (num / 1e3).toFixed(1) + \"K\";\n  return num.toFixed(0);\n}\n","/**\n * Market Trends Action\n *\n * Direct market trends data fetcher that retrieves trend information\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Time period/category filtering from natural language queries using LLM\n * - Current market trend data (TVL changes, chain performance, sector trends)\n * - Multi-timeframe trend analysis\n * - Smart trend filtering using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract trend criteria from user query using LLM\n * 2. Fetch market data from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\nimport type { ProtocolDetails, Chain, ProtocolFees, DexVolume } from \"../types\";\n\ninterface TrendCriteria {\n  timeframe: \"1d\" | \"7d\" | \"30d\";\n  focus: \"protocols\" | \"chains\" | \"categories\" | \"all\";\n  category?: string;\n  sortBy: \"tvl\" | \"volume\" | \"change\";\n  direction: \"winners\" | \"losers\" | \"all\";\n  limit: number;\n}\n\ninterface TrendItem {\n  name: string;\n  type: \"protocol\" | \"chain\" | \"category\";\n  tvl: number;\n  change_1d: number;\n  change_7d: number;\n  rank: number;\n  category?: string;\n  formatted?: string;\n}\n\ninterface StructuredTrendData {\n  trends: TrendItem[];\n  totalTvl: number;\n  marketSentiment: \"bullish\" | \"bearish\" | \"neutral\";\n  timestamp: number;\n}\n\n// Simple type for trend data\ninterface TrendData {\n  name: string;\n  type: \"protocol\" | \"chain\" | \"category\";\n  tvl: number;\n  change_1d: number;\n  change_7d: number;\n  change_30d: number;\n  rank: number;\n  category?: string;\n  formatted: string;\n}\n\nconst extractMarketTrendsTemplate = `Extract market trends analysis parameters from the user's request for DeFi market trend data.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /protocols endpoint returns protocol data with tvl, change_1d, change_7d, category\n- /chains endpoint returns chain data with tvl (no change data available)\n- /overview/fees and /overview/dexs endpoints provide additional performance metrics\n- Protocol categories: \"Dexs\", \"Lending\", \"Liquid Staking\", \"Derivatives\", \"Yield\", \"CDP\", \"Bridge\"\n- Chain names in proper case: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n\nThe user might express market trends requests in various ways:\n- \"Best performing DeFi protocols this week\" → focus: \"protocols\", timeframe: \"7d\", direction: \"winners\"\n- \"Chain performance trends last 30 days\" → focus: \"chains\", timeframe: \"30d\", analysisType: \"performance\"\n- \"DEX sector analysis\" → focus: \"categories\", category: \"Dexs\", sortBy: \"tvl\"\n- \"Top 5 lending protocols by TVL\" → focus: \"protocols\", category: \"Lending\", sortBy: \"tvl\", limit: 5\n- \"Market losers today\" → direction: \"losers\", timeframe: \"1d\"\n- \"DeFi market overview\" → focus: \"all\", analysisType: \"overview\"\n- \"Volume leaders this month\" → sortBy: \"volume\", timeframe: \"30d\"\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"focus\": \"protocols/chains/categories/all (what to analyze)\",\n  \"timeframe\": \"1d/7d/30d (time period for analysis)\",\n  \"direction\": \"winners/losers/all (performance filter)\",\n  \"category\": \"Dexs/Lending/Liquid Staking/Derivatives if mentioned\",\n  \"sortBy\": \"tvl/volume/change (how to rank results)\",\n  \"analysisType\": \"performance/overview/ranking/comparison\",\n  \"limit\": number (how many results, default 10),\n  \"includeMetrics\": [\"tvl/volume/fees/change if specifically requested\"],\n  \"marketScope\": \"overall/sector/chain if specified\"\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const marketTrendsAction: Action = {\n  name: \"MARKET_TRENDS\",\n  similes: [\n    \"MARKET_ANALYSIS\",\n    \"TREND_ANALYSIS\",\n    \"MARKET_OVERVIEW\",\n    \"DEFI_TRENDS\",\n    \"SECTOR_PERFORMANCE\",\n    \"CHAIN_TRENDS\",\n    \"PROTOCOL_TRENDS\",\n    \"TVL_TRENDS\",\n    \"MARKET_SENTIMENT\",\n    \"PERFORMANCE_ANALYSIS\",\n  ],\n  description: `Simple market trends data fetcher. This action:\n1. Extracts trend analysis criteria from user queries using LLM\n2. Fetches current market trend data from DeFiLlama API\n3. Returns clean, structured trend data for analysis or display\n4. Supports filtering by time period, category, and specific metrics\n\nUSE WHEN: User asks about market trends, sector performance, protocol rankings, or DeFi market analysis.\nRETURNS: Raw trend data without extensive analysis - focused on data retrieval.`,\n\n  validate: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state: State | undefined,\n  ): Promise<boolean> => {\n    const text = message.content.text?.toLowerCase() || \"\";\n\n    const trendKeywords = [\n      \"trend\",\n      \"trends\",\n      \"market\",\n      \"performance\",\n      \"growth\",\n      \"decline\",\n      \"sector\",\n      \"category\",\n      \"ranking\",\n      \"winners\",\n      \"losers\",\n      \"best performing\",\n      \"worst performing\",\n      \"market overview\",\n      \"defi market\",\n      \"tvl growth\",\n      \"volume trends\",\n      \"chain performance\",\n      \"protocol ranking\",\n    ];\n\n    return trendKeywords.some((keyword) => text.includes(keyword));\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    try {\n      logger.info(\"[MARKET_TRENDS] Starting market trends data fetch\");\n\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const userQuestion = message.content.text || \"\";\n\n      // Extract trend criteria using LLM first, with fallback to regex\n      let extractedParams: any;\n\n      // Check if we have explicit params in options\n      if (options?.trendParams) {\n        extractedParams = options.trendParams;\n      } else {\n        // Use LLM to extract criteria\n        const prompt = extractMarketTrendsTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              focus: parsed.focus || \"protocols\",\n              timeframe: parsed.timeframe || \"7d\",\n              direction: parsed.direction || \"all\",\n              category: parsed.category || undefined,\n              sortBy: parsed.sortBy || \"tvl\",\n              analysisType: parsed.analysisType || \"performance\",\n              limit: parsed.limit || 10,\n              includeMetrics: parsed.includeMetrics || [],\n              marketScope: parsed.marketScope || \"overall\",\n            };\n\n            logger.info(\n              `[MARKET_TRENDS] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            extractedParams = {\n              ...extractTrendCriteriaLegacy(userQuestion),\n              analysisType: \"performance\",\n              includeMetrics: [],\n              marketScope: \"overall\",\n            };\n          }\n        } else {\n          logger.warn(\n            \"[MARKET_TRENDS] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          extractedParams = {\n            ...extractTrendCriteriaLegacy(userQuestion),\n            analysisType: \"performance\",\n            includeMetrics: [],\n            marketScope: \"overall\",\n          };\n        }\n      }\n\n      logger.info(\n        `[MARKET_TRENDS] Fetching trends with criteria: ${JSON.stringify(extractedParams)}`,\n      );\n\n      // Fetch market data\n      const [protocols, chains, dexVolumes, protocolFees] = await Promise.all([\n        defiLlamaService.getProtocols(),\n        defiLlamaService.getChains(),\n        defiLlamaService\n          .getDexVolumes({\n            excludeTotalDataChart: true,\n            excludeTotalDataChartBreakdown: true,\n          })\n          .catch(() => null),\n        defiLlamaService\n          .getProtocolFees({\n            excludeTotalDataChart: true,\n            excludeTotalDataChartBreakdown: true,\n            dataType: \"dailyFees\",\n          })\n          .catch(() => null),\n      ]);\n\n      // Validate API responses\n      const validatedProtocols = Array.isArray(protocols) ? protocols : [];\n      const validatedChains = Array.isArray(chains) ? chains : [];\n      const validatedDexVolumes = Array.isArray(dexVolumes) ? dexVolumes : null;\n      const validatedProtocolFees = Array.isArray(protocolFees)\n        ? protocolFees\n        : null;\n\n      if (validatedProtocols.length === 0) {\n        throw new Error(\"No market data available from API\");\n      }\n\n      // Build trend data\n      const trendData = buildTrendDataLLM(\n        extractedParams,\n        validatedProtocols,\n        validatedChains,\n        validatedDexVolumes,\n        validatedProtocolFees,\n      );\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with market trends analysis based on data: ${JSON.stringify(trendData)}\n        and user query: ${JSON.stringify(message.content)}`,\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to analyze market trends at this time.\",\n          actions: ['MARKET_TRENDS'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response,\n        success: true,\n        data: {\n          actionName: \"MARKET_TRENDS\",\n          extractedParams,\n          trendData,\n          trendDataFetched: true,\n          trendsFound: trendData.trends.length,\n          timestamp: Date.now(),\n        },\n      };\n    } catch (error) {\n      logger.error(\"[MARKET_TRENDS] Error:\", error);\n\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n\n      if (callback) {\n        await callback({\n          text: `❌ Failed to fetch trend data: ${errorMessage}`,\n          actions: [\"MARKET_TRENDS\"],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: `Error fetching trend data: ${errorMessage}`,\n        success: false,\n        error: error instanceof Error ? error : new Error(errorMessage),\n        data: {\n          actionName: \"MARKET_TRENDS\",\n          error: errorMessage,\n          trendDataFetched: false,\n          timestamp: Date.now(),\n        },\n      };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"What are the best performing DeFi protocols this week?\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Top DeFi performers this week: Aave +12.3% (rank #2), Uniswap +8.7% (rank #5), Curve +15.2% (rank #7). Lending and DEX categories showing strong growth with increased TVL inflows.\",\n          actions: [\"MARKET_TRENDS\"],\n        },\n      },\n    ],\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"Show me chain performance trends over the last 30 days\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"30-day chain trends: Arbitrum +18.5% TVL growth, Polygon +12.1%, Base +22.3%. Ethereum stable at +2.1%. L2s outperforming with increased adoption and lower fees driving growth.\",\n          actions: [\"MARKET_TRENDS\"],\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for trend data extraction and formatting\n\nfunction buildTrendDataLLM(\n  params: any,\n  protocols: ProtocolDetails[],\n  chains: Chain[],\n  dexVolumes: DexVolume[] | null,\n  protocolFees: ProtocolFees[] | null,\n): StructuredTrendData {\n  const data: StructuredTrendData = {\n    trends: [],\n    totalTvl: 0,\n    marketSentiment: \"neutral\",\n    timestamp: Date.now(),\n  };\n\n  let items: TrendItem[] = [];\n\n  // Build trend items based on focus\n  if (params.focus === \"chains\") {\n    items = chains.map((chain) => ({\n      name: chain.name,\n      type: \"chain\",\n      tvl: chain.tvl || 0,\n      change_1d: 0, // chains don't have change data in basic endpoint\n      change_7d: 0,\n      rank: 0,\n    }));\n  } else if (params.focus === \"categories\") {\n    // Group protocols by category\n    const categoryTvl: { [key: string]: any } = {};\n    protocols.forEach((protocol) => {\n      const category = protocol.category || \"Other\";\n      if (!categoryTvl[category]) {\n        categoryTvl[category] = {\n          name: category,\n          type: \"category\",\n          tvl: 0,\n          change_1d: 0,\n          change_7d: 0,\n          count: 0,\n        };\n      }\n      categoryTvl[category].tvl += (protocol as any).tvl || 0;\n      categoryTvl[category].change_1d += (protocol as any).change_1d || 0;\n      categoryTvl[category].change_7d += (protocol as any).change_7d || 0;\n      categoryTvl[category].count += 1;\n    });\n\n    // Average the changes\n    items = Object.values(categoryTvl).map((cat: any) => ({\n      ...cat,\n      change_1d: cat.count > 0 ? cat.change_1d / cat.count : 0,\n      change_7d: cat.count > 0 ? cat.change_7d / cat.count : 0,\n    }));\n  } else {\n    // Protocols\n    items = protocols.map((protocol, index) => ({\n      name: protocol.name,\n      type: \"protocol\" as const,\n      tvl: protocol.tvl || 0,\n      change_1d: protocol.change_1d || 0,\n      change_7d: protocol.change_7d || 0,\n      rank: index + 1,\n      category: protocol.category,\n    }));\n  }\n\n  // Filter by category if specified\n  if (params.category) {\n    items = items.filter(\n      (item) =>\n        item.category === params.category || item.name === params.category,\n    );\n  }\n\n  // Filter by direction\n  const getChangeValue = (item: TrendItem, timeframe: string): number => {\n    if (timeframe === \"1d\") return item.change_1d;\n    if (timeframe === \"7d\") return item.change_7d;\n    return item.change_1d; // fallback\n  };\n\n  if (params.direction === \"winners\") {\n    items = items.filter((item) => getChangeValue(item, params.timeframe) > 0);\n  } else if (params.direction === \"losers\") {\n    items = items.filter((item) => getChangeValue(item, params.timeframe) < 0);\n  }\n\n  // Sort items based on criteria\n  if (params.sortBy === \"tvl\") {\n    items.sort((a, b) => (b.tvl || 0) - (a.tvl || 0));\n  } else if (params.sortBy === \"change\") {\n    items.sort(\n      (a, b) =>\n        getChangeValue(b, params.timeframe) -\n        getChangeValue(a, params.timeframe),\n    );\n  } else if (params.sortBy === \"volume\" && dexVolumes) {\n    // For volume sorting, try to match with DEX volume data using improved matching\n    items.forEach((item) => {\n      const volumeData = findMatchingProtocolByName(dexVolumes, item.name);\n      if (volumeData) {\n        // Add volume data for sorting\n        (item as any).volume = volumeData.total24h || 0;\n      }\n    });\n    items.sort((a, b) => ((b as any).volume || 0) - ((a as any).volume || 0));\n  } else {\n    // Default to change-based sorting\n    items.sort(\n      (a, b) =>\n        getChangeValue(b, params.timeframe) -\n        getChangeValue(a, params.timeframe),\n    );\n  }\n\n  // Take top items based on limit\n  items = items.slice(0, params.limit);\n\n  // Build trend data\n  items.forEach((item) => {\n    data.trends.push({\n      name: item.name,\n      type: item.type,\n      tvl: item.tvl,\n      change_1d: item.change_1d,\n      change_7d: item.change_7d,\n      rank: item.rank,\n      category: item.category,\n      formatted: formatTrendDataLLM(item, params.timeframe),\n    });\n\n    data.totalTvl += item.tvl || 0;\n  });\n\n  // Calculate market sentiment based on average change\n  const avgChange =\n    items.length > 0\n      ? items.reduce(\n          (sum, item) => sum + getChangeValue(item, params.timeframe),\n          0,\n        ) / items.length\n      : 0;\n\n  data.marketSentiment =\n    avgChange > 5 ? \"bullish\" : avgChange < -5 ? \"bearish\" : \"neutral\";\n\n  return data;\n}\n\nfunction extractTrendCriteriaLegacy(query: string): TrendCriteria {\n  const searchText = query.toLowerCase();\n\n  const criteria: TrendCriteria = {\n    timeframe: \"7d\", // default\n    focus: \"protocols\", // protocols, chains, categories, all\n    category: undefined,\n    sortBy: \"tvl\", // tvl, volume, change\n    direction: \"all\", // winners, losers, all\n    limit: 10,\n  };\n\n  // Extract timeframe\n  if (\n    searchText.includes(\"24h\") ||\n    searchText.includes(\"24 hour\") ||\n    searchText.includes(\"today\")\n  ) {\n    criteria.timeframe = \"1d\";\n  } else if (\n    searchText.includes(\"week\") ||\n    searchText.includes(\"7d\") ||\n    searchText.includes(\"7 day\")\n  ) {\n    criteria.timeframe = \"7d\";\n  } else if (\n    searchText.includes(\"month\") ||\n    searchText.includes(\"30d\") ||\n    searchText.includes(\"30 day\")\n  ) {\n    criteria.timeframe = \"30d\";\n  }\n\n  // Extract focus area\n  if (\n    searchText.includes(\"chain\") ||\n    searchText.includes(\"blockchain\") ||\n    searchText.includes(\"network\")\n  ) {\n    criteria.focus = \"chains\";\n  } else if (searchText.includes(\"category\") || searchText.includes(\"sector\")) {\n    criteria.focus = \"categories\";\n  } else if (\n    searchText.includes(\"protocol\") ||\n    searchText.includes(\"project\")\n  ) {\n    criteria.focus = \"protocols\";\n  }\n\n  // Extract category filter\n  const categoryKeywords = {\n    dex: \"Dexs\",\n    lending: \"Lending\",\n    staking: \"Liquid Staking\",\n    derivatives: \"Derivatives\",\n    yield: \"Yield\",\n    bridge: \"Bridge\",\n    cdp: \"CDP\",\n    insurance: \"Insurance\",\n  };\n\n  for (const [keyword, category] of Object.entries(categoryKeywords)) {\n    if (searchText.includes(keyword)) {\n      criteria.category = category;\n      break;\n    }\n  }\n\n  // Extract performance direction\n  if (\n    searchText.includes(\"winner\") ||\n    searchText.includes(\"best\") ||\n    searchText.includes(\"top\") ||\n    searchText.includes(\"gain\")\n  ) {\n    criteria.direction = \"winners\";\n  } else if (\n    searchText.includes(\"loser\") ||\n    searchText.includes(\"worst\") ||\n    searchText.includes(\"declining\") ||\n    searchText.includes(\"loss\")\n  ) {\n    criteria.direction = \"losers\";\n  }\n\n  // Extract sort preference\n  if (searchText.includes(\"volume\") || searchText.includes(\"trading\")) {\n    criteria.sortBy = \"volume\";\n  } else if (\n    searchText.includes(\"tvl\") ||\n    searchText.includes(\"value locked\")\n  ) {\n    criteria.sortBy = \"tvl\";\n  }\n\n  return criteria;\n}\n\n// Utility functions\n\nfunction formatTrendDataLLM(item: TrendItem, timeframe: string): string {\n  const getChangeForFormat = (item: TrendItem, timeframe: string): number => {\n    if (timeframe === \"1d\") return item.change_1d;\n    if (timeframe === \"7d\") return item.change_7d;\n    return item.change_1d; // fallback\n  };\n\n  const change = getChangeForFormat(item, timeframe).toFixed(1);\n  const tvl = formatLargeNumber(item.tvl || 0);\n  const sign = parseFloat(change) >= 0 ? \"+\" : \"\";\n\n  return `${item.name}: $${tvl} TVL, ${sign}${change}% (${timeframe})`;\n}\n\nfunction formatLargeNumber(num: number): string {\n  if (num >= 1e12) return (num / 1e12).toFixed(1) + \"T\";\n  if (num >= 1e9) return (num / 1e9).toFixed(1) + \"B\";\n  if (num >= 1e6) return (num / 1e6).toFixed(1) + \"M\";\n  if (num >= 1e3) return (num / 1e3).toFixed(1) + \"K\";\n  return num.toFixed(0);\n}\n\n/**\n * Common protocol name mappings for better matching accuracy\n * Maps user-friendly names to API-specific protocol names\n */\nconst PROTOCOL_NAME_MAPPINGS: { [key: string]: string[] } = {\n  // Uniswap variations\n  uniswap: [\"uniswap-v3\", \"uniswap-v2\", \"uniswap\"],\n  uni: [\"uniswap-v3\", \"uniswap-v2\", \"uniswap\"],\n  \"uniswap v3\": [\"uniswap-v3\"],\n  \"uniswap v2\": [\"uniswap-v2\"],\n\n  // Curve variations\n  curve: [\"curve-dex\", \"curve\"],\n  crv: [\"curve-dex\", \"curve\"],\n\n  // Compound variations\n  compound: [\"compound-v3\", \"compound-v2\", \"compound\"],\n  comp: [\"compound-v3\", \"compound-v2\", \"compound\"],\n\n  // Aave variations\n  aave: [\"aave-v3\", \"aave-v2\", \"aave\"],\n  \"aave v3\": [\"aave-v3\"],\n  \"aave v2\": [\"aave-v2\"],\n\n  // Balancer variations\n  balancer: [\"balancer-v2\", \"balancer\"],\n  bal: [\"balancer-v2\", \"balancer\"],\n\n  // SushiSwap variations\n  sushiswap: [\"sushiswap\", \"sushi\"],\n  sushi: [\"sushiswap\", \"sushi\"],\n\n  // PancakeSwap variations\n  pancakeswap: [\"pancakeswap\", \"pancake\"],\n  pancake: [\"pancakeswap\", \"pancake\"],\n  pcs: [\"pancakeswap\"],\n\n  // 1inch variations\n  \"1inch\": [\"1inch\", \"1inch-liquidity-protocol\"],\n  oneinch: [\"1inch\", \"1inch-liquidity-protocol\"],\n\n  // MakerDAO variations\n  makerdao: [\"makerdao\", \"maker\"],\n  maker: [\"makerdao\", \"maker\"],\n  dai: [\"makerdao\"],\n\n  // Lido variations\n  lido: [\"lido\", \"lido-liquid-staking\"],\n  steth: [\"lido\"],\n\n  // Rocket Pool variations\n  \"rocket pool\": [\"rocket-pool\"],\n  rocketpool: [\"rocket-pool\"],\n  rpl: [\"rocket-pool\"],\n\n  // Frax variations\n  frax: [\"frax-finance\", \"frax\"],\n  \"frax finance\": [\"frax-finance\"],\n\n  // Convex variations\n  convex: [\"convex-finance\"],\n  \"convex finance\": [\"convex-finance\"],\n  cvx: [\"convex-finance\"],\n};\n\n/**\n * Improved name matching algorithm with multi-stage approach\n * 1. Exact name match (case-insensitive)\n * 2. Common protocol name mappings\n * 3. Contains match (fallback to original approach)\n *\n * @param protocols Array of protocols to search through\n * @param targetName Name to find matches for\n * @returns Matching protocol or null if no match found\n */\nfunction findMatchingProtocolByName<T extends { name?: string }>(\n  protocols: T[],\n  targetName: string,\n): T | null {\n  if (!protocols || protocols.length === 0 || !targetName) {\n    return null;\n  }\n\n  const normalizedTarget = targetName.toLowerCase().trim();\n\n  // Stage 1: Exact name match (case-insensitive)\n  const exactMatch = protocols.find(\n    (protocol) => protocol.name?.toLowerCase().trim() === normalizedTarget,\n  );\n  if (exactMatch) {\n    return exactMatch;\n  }\n\n  // Stage 2: Common protocol name mappings\n  const mappedNames = PROTOCOL_NAME_MAPPINGS[normalizedTarget];\n  if (mappedNames) {\n    for (const mappedName of mappedNames) {\n      const mappedMatch = protocols.find(\n        (protocol) =>\n          protocol.name?.toLowerCase().trim() === mappedName.toLowerCase(),\n      );\n      if (mappedMatch) {\n        return mappedMatch;\n      }\n    }\n\n    // Also try contains match for mapped names\n    for (const mappedName of mappedNames) {\n      const mappedContainsMatch = protocols.find(\n        (protocol) =>\n          protocol.name?.toLowerCase().includes(mappedName.toLowerCase()) ||\n          mappedName.toLowerCase().includes(protocol.name?.toLowerCase() || \"\"),\n      );\n      if (mappedContainsMatch) {\n        return mappedContainsMatch;\n      }\n    }\n  }\n\n  // Stage 3: Contains match (original approach, but more careful)\n  // Only proceed if the target name is reasonably specific (3+ characters)\n  if (normalizedTarget.length >= 3) {\n    const containsMatch = protocols.find((protocol) => {\n      const protocolName = protocol.name?.toLowerCase().trim() || \"\";\n\n      // Bidirectional contains check to reduce false positives\n      return (\n        protocolName.includes(normalizedTarget) ||\n        normalizedTarget.includes(protocolName)\n      );\n    });\n\n    if (containsMatch) {\n      return containsMatch;\n    }\n  }\n\n  // No match found\n  return null;\n}\n","/**\n * Historical Data Action\n *\n * Direct historical data fetcher that retrieves time-series information\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Protocol/timeframe filtering from natural language queries using LLM\n * - Historical TVL, price, and protocol data\n * - Multi-timeframe data retrieval (24h, 7d, 30d, 90d, 1y)\n * - Smart period extraction using LLM and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract protocols and timeframe from user query using LLM\n * 2. Fetch historical data from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\nimport type { ProtocolDetails, Chain, HistoricalData } from \"../types\";\n\ninterface HistoricalProtocolData {\n  protocol: string;\n  protocolInfo?: {\n    tvl?: number;\n    category?: string;\n    chain?: string;\n    chainTvls?: Record<string, number>; // Added for chain-specific TVL\n    chains?: string[]; // Added for chain names\n  };\n  historicalTVL?: Array<{\n    totalLiquidityUSD: number;\n    date: number;\n  }>;\n}\n\ninterface MarketOverviewData {\n  protocols: Array<{\n    name: string;\n    tvl: number;\n    category: string;\n    change_7d?: number;\n  }>;\n  chains?: Array<{\n    name: string;\n    tvl: number;\n  }>;\n}\n\ninterface StructuredHistoricalData {\n  timeframe: string;\n  protocolsAnalyzed: string[] | string;\n  protocolData: Array<{\n    name: string;\n    currentTvl: number;\n    category: string;\n    chain: string;\n    historicalPoints: number;\n    latestChange: number;\n  }>;\n  marketData: MarketOverviewData | null;\n  summary: {\n    totalProtocols: number;\n    dataPoints: number;\n    timeRange: string;\n  };\n}\n\nconst extractHistoricalTemplate = `Extract historical data analysis parameters from the user's request for time-series DeFi data.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /protocol/{protocol} endpoint returns historical TVL data with chainTvls.tvl[].{date, totalLiquidityUSD}\n- /protocols endpoint returns current protocol data with tvl, category, chains\n- /v2/historicalChainTvl/{chain} returns historical chain-level TVL data\n- Chain names in proper case: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n- Protocol names as returned by API: \"Aave\", \"Uniswap\", \"Compound\", \"Curve\", etc.\n\nThe user might express historical data requests in various ways:\n- \"Aave TVL growth over 6 months\" → protocols: [\"Aave\"], timeframe: \"6m\", dataType: \"tvl\"\n- \"Compare Uniswap vs SushiSwap last year\" → protocols: [\"Uniswap\", \"SushiSwap\"], timeframe: \"1y\", analysisType: \"comparison\"\n- \"DeFi trends last 30 days\" → timeframe: \"30d\", analysisType: \"market_overview\"\n- \"Ethereum TVL historical performance\" → chains: [\"Ethereum\"], timeframe: \"1y\", dataType: \"tvl\"\n- \"Protocol performance since January\" → timeframe: \"custom\", analysisType: \"performance\"\n- \"Weekly growth analysis for lending protocols\" → category: \"Lending\", timeframe: \"7d\", analysisType: \"growth\"\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"protocols\": [\"Protocol names if mentioned: Aave/Uniswap/Compound/Curve\"],\n  \"chains\": [\"Chain names as per API: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche\"],\n  \"timeframe\": \"24h/7d/30d/90d/180d/1y/custom (time period requested)\",\n  \"dataType\": \"tvl/volume/fees/price (what historical data to analyze)\",\n  \"analysisType\": \"growth/comparison/trends/performance/market_overview\",\n  \"category\": [\"Lending/Dexs/Derivatives if mentioned\"],\n  \"granularity\": \"daily/weekly/monthly (data point frequency if specified)\",\n  \"includeBreakdown\": true/false (if user wants chain/token breakdown),\n  \"compareToMarket\": true/false (if user wants market comparison),\n  \"count\": number (how many protocols/chains to analyze, default 10)\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const historicalDataAction: Action = {\n  name: \"HISTORICAL_DATA\",\n  similes: [\n    \"historical analysis\",\n    \"price history\",\n    \"tvl trends\",\n    \"protocol growth\",\n    \"historical comparison\",\n    \"time series\",\n    \"trend analysis\",\n    \"historical performance\",\n    \"past data\",\n    \"historical metrics\",\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    const userQuestion = message.content.text?.toLowerCase() || \"\";\n\n    const historicalKeywords = [\n      \"historical\",\n      \"history\",\n      \"past\",\n      \"trend\",\n      \"growth\",\n      \"over time\",\n      \"time series\",\n      \"charts\",\n      \"performance\",\n      \"since\",\n      \"ago\",\n      \"previous\",\n      \"last week\",\n      \"last month\",\n      \"last year\",\n      \"compare\",\n      \"timeline\",\n    ];\n\n    return historicalKeywords.some((keyword) => userQuestion.includes(keyword));\n  },\n  description:\n    \"Retrieves historical data and trends from DeFiLlama using LLM parameter extraction\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: any,\n    options: any,\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    logger.info(\"[HISTORICAL_DATA] Starting historical data analysis\");\n\n    try {\n      const userQuestion = message.content.text || \"\";\n\n      // Extract historical criteria using LLM first, with fallback to regex\n      let extractedParams: any;\n\n      // Check if we have explicit params in options\n      if (options?.historicalParams) {\n        extractedParams = options.historicalParams;\n      } else {\n        // Use LLM to extract criteria\n        const prompt = extractHistoricalTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              protocols: parsed.protocols || [],\n              chains: parsed.chains || [],\n              timeframe: parsed.timeframe || \"30d\",\n              dataType: parsed.dataType || \"tvl\",\n              analysisType: parsed.analysisType || \"trends\",\n              category: parsed.category || [],\n              granularity: parsed.granularity || \"daily\",\n              includeBreakdown: parsed.includeBreakdown || false,\n              compareToMarket: parsed.compareToMarket || false,\n              count: parsed.count || 10,\n            };\n\n            logger.info(\n              `[HISTORICAL_DATA] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            const timeframe = extractTimeframeFromQueryLegacy(userQuestion);\n            const targetProtocols =\n              extractProtocolsFromQueryLegacy(userQuestion);\n            extractedParams = {\n              protocols: targetProtocols,\n              chains: [],\n              timeframe: timeframe,\n              dataType: \"tvl\",\n              analysisType: \"trends\",\n              category: [],\n              granularity: \"daily\",\n              includeBreakdown: false,\n              compareToMarket: false,\n              count: 10,\n            };\n          }\n        } else {\n          logger.warn(\n            \"[HISTORICAL_DATA] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          const timeframe = extractTimeframeFromQueryLegacy(userQuestion);\n          const targetProtocols = extractProtocolsFromQueryLegacy(userQuestion);\n          extractedParams = {\n            protocols: targetProtocols,\n            chains: [],\n            timeframe: timeframe,\n            dataType: \"tvl\",\n            analysisType: \"trends\",\n            category: [],\n            granularity: \"daily\",\n            includeBreakdown: false,\n            compareToMarket: false,\n            count: 10,\n          };\n        }\n      }\n\n      logger.info(\n        `[HISTORICAL_DATA] Fetching data for timeframe: ${extractedParams.timeframe}, protocols: ${extractedParams.protocols.join(\", \") || \"all\"}`,\n      );\n\n      // Fetch historical data\n      const defiLlamaService = runtime.getService<DefiLlamaService>(\n        DefiLlamaService.serviceType,\n      );\n\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      let historicalData: any = {};\n\n      if (extractedParams.protocols.length > 0) {\n        // Fetch specific protocol historical data\n        const protocolDataPromises = extractedParams.protocols.map(\n          async (protocol: string) => {\n            try {\n              const protocolSlug = protocol.toLowerCase().replace(/\\s+/g, \"-\");\n              const [protocolInfo, historicalTVL] = await Promise.all([\n                defiLlamaService.getProtocol(protocolSlug),\n                defiLlamaService.getHistoricalTVL(\n                  protocolSlug,\n                  extractedParams.timeframe,\n                ),\n              ]);\n              return { protocol, protocolInfo, historicalTVL };\n            } catch (error) {\n              logger.warn(\n                `[HISTORICAL_DATA] Failed to fetch data for ${protocol}: ${error}`,\n              );\n              return null;\n            }\n          },\n        );\n\n        const protocolResults = await Promise.allSettled(protocolDataPromises);\n        historicalData.protocols = protocolResults\n          .filter(\n            (\n              result,\n            ): result is PromiseFulfilledResult<{\n              protocol: string;\n              protocolInfo: ProtocolDetails;\n              historicalTVL: HistoricalData[];\n            }> => result.status === \"fulfilled\" && result.value !== null,\n          )\n          .map((result) => result.value);\n      } else {\n        // Fetch general market data\n        const [protocols, chains] = await Promise.all([\n          defiLlamaService.getProtocols(),\n          defiLlamaService.getChains(),\n        ]);\n\n        // Filter by category if specified\n        let filteredProtocols = protocols;\n        if (extractedParams.category && extractedParams.category.length > 0) {\n          filteredProtocols = protocols.filter((p: any) =>\n            extractedParams.category.some((cat: string) =>\n              p.category?.toLowerCase().includes(cat.toLowerCase()),\n            ),\n          );\n        }\n\n        historicalData.protocols = filteredProtocols.slice(\n          0,\n          extractedParams.count,\n        );\n        historicalData.chains = chains.slice(0, 5); // Top 5 chains\n      }\n\n      // Structure data for LLM response\n      const structuredData = buildHistoricalDataLLM(\n        historicalData,\n        extractedParams,\n      );\n\n      logger.info(\"[HISTORICAL_DATA] Data fetched and structured successfully\");\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with historical analysis based on data: ${JSON.stringify(structuredData)}\n\nQuestion: ${userQuestion}\n\nProvide insights on:\n- Historical trends and patterns in the specified timeframe\n- Key performance changes and growth metrics\n- Significant events or inflection points\n- Comparative analysis if multiple protocols mentioned\n\nKeep response focused, data-driven, and under 150 words.`,\n        temperature: 0.7,\n        stop: [\"<END>\"],\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to analyze historical data at this time.\",\n          actions: ['HISTORICAL_DATA'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response || \"Historical analysis completed\",\n        success: true,\n        data: {\n          actionName: \"HISTORICAL_DATA\",\n          extractedParams,\n          structuredData,\n          historicalDataFetched: true,\n          protocolsAnalyzed:\n            extractedParams.protocols.length || \"market overview\",\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    } catch (error) {\n      const errorMessage = `Failed to fetch historical data: ${error}`;\n      logger.error(`[HISTORICAL_DATA] ${errorMessage}`);\n\n      if (callback) {\n        await callback({\n          text: \"I encountered an error while fetching historical data. Please try again.\",\n          source: \"HISTORICAL_DATA\",\n        });\n      }\n\n      return {\n        text: \"Error fetching historical data. Please try again.\",\n        success: false,\n        data: {\n          actionName: \"HISTORICAL_DATA\",\n          error: errorMessage,\n          historicalDataFetched: false,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"user\",\n        content: { text: \"Show me Aave's TVL growth over the last 6 months\" },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's Aave's TVL historical analysis over the past 6 months: [analysis based on latest DeFiLlama data]\",\n          source: \"HISTORICAL_DATA\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"Compare Uniswap and SushiSwap performance over the last year\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's a comparative analysis of Uniswap vs SushiSwap performance over the past year: [detailed historical comparison]\",\n          source: \"HISTORICAL_DATA\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"What are the major DeFi trends from the past 30 days?\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Based on the last 30 days of data, here are the major DeFi trends: [market trend analysis]\",\n          source: \"HISTORICAL_DATA\",\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for historical data extraction and formatting\n\nfunction buildHistoricalDataLLM(\n  data: any,\n  params: any,\n): StructuredHistoricalData {\n  const result: StructuredHistoricalData = {\n    timeframe: params.timeframe,\n    protocolsAnalyzed:\n      params.protocols.length > 0 ? params.protocols : \"market overview\",\n    protocolData: [],\n    marketData: null,\n    summary: {\n      totalProtocols: 0,\n      dataPoints: 0,\n      timeRange: params.timeframe,\n    },\n  };\n\n  if (data.protocols && data.protocols.length > 0) {\n    if (params.protocols.length > 0) {\n      // Process specific protocol data\n      result.protocolData = data.protocols.map(\n        (item: HistoricalProtocolData) => {\n          // Calculate current TVL from chainTvls if not directly available\n          const currentTvl =\n            item.protocolInfo?.tvl ||\n            (item.protocolInfo?.chainTvls\n              ? Object.values(\n                  item.protocolInfo.chainTvls as Record<string, number>,\n                ).reduce((sum: number, val: number) => sum + val, 0)\n              : 0);\n\n          return {\n            name: item.protocol,\n            currentTvl: currentTvl,\n            category: item.protocolInfo?.category || \"Unknown\",\n            chain: item.protocolInfo?.chains?.join(\", \") || \"Multi-chain\",\n            historicalPoints: item.historicalTVL?.length || 0,\n            latestChange: calculateChangeLLM(item.historicalTVL),\n          };\n        },\n      );\n    } else {\n      // Process market overview data\n      result.marketData = {\n        protocols: data.protocols\n          .slice(0, params.count)\n          .map(\n            (protocol: {\n              name: string;\n              tvl: number;\n              category: string;\n              change_7d?: number;\n            }) => ({\n              name: protocol.name,\n              tvl: protocol.tvl || 0,\n              category: protocol.category || \"Unknown\",\n              change_7d: protocol.change_7d || 0,\n            }),\n          ),\n        chains:\n          data.chains\n            ?.slice(0, 5)\n            .map((chain: { name: string; tvl: number }) => ({\n              name: chain.name,\n              tvl: chain.tvl || 0,\n            })) || [],\n      };\n    }\n\n    result.summary.totalProtocols = data.protocols.length;\n    result.summary.dataPoints = data.protocols.reduce(\n      (sum: number, item: HistoricalProtocolData) =>\n        sum + (item.historicalTVL?.length || 1),\n      0,\n    );\n  }\n\n  // Handle chain-specific data if available\n  if (data.chains && params.chains.length > 0) {\n    result.summary.totalProtocols = data.chains.length;\n    result.summary.dataPoints = data.chains.reduce(\n      (sum: number, item: any) => sum + (item.historicalTVL?.length || 1),\n      0,\n    );\n  }\n\n  return result;\n}\n\nfunction calculateChangeLLM(\n  historicalData:\n    | Array<{ totalLiquidityUSD: number; date: number }>\n    | undefined,\n): number {\n  if (!historicalData || historicalData.length < 2) return 0;\n\n  const latest = historicalData[historicalData.length - 1];\n  const previous = historicalData[0];\n\n  if (!latest?.totalLiquidityUSD || !previous?.totalLiquidityUSD) return 0;\n\n  return (\n    ((latest.totalLiquidityUSD - previous.totalLiquidityUSD) /\n      previous.totalLiquidityUSD) *\n    100\n  );\n}\n\nfunction extractTimeframeFromQueryLegacy(query: string): string {\n  const lowerQuery = query.toLowerCase();\n\n  // Map common time expressions to API periods\n  const timeFramePatterns = {\n    \"24h\": [\"24h\", \"24 hour\", \"1 day\", \"today\", \"daily\"],\n    \"7d\": [\"7d\", \"7 day\", \"week\", \"weekly\", \"last week\"],\n    \"30d\": [\"30d\", \"30 day\", \"month\", \"monthly\", \"last month\"],\n    \"90d\": [\"90d\", \"90 day\", \"3 month\", \"quarter\", \"quarterly\"],\n    \"365d\": [\"365d\", \"year\", \"yearly\", \"annual\", \"last year\", \"12 month\"],\n  };\n\n  for (const [period, patterns] of Object.entries(timeFramePatterns)) {\n    if (patterns.some((pattern) => lowerQuery.includes(pattern))) {\n      return period;\n    }\n  }\n\n  return \"30d\"; // Default timeframe\n}\n\nfunction extractProtocolsFromQueryLegacy(query: string): string[] {\n  const protocols: string[] = [];\n  const lowerQuery = query.toLowerCase();\n\n  const protocolKeywords = {\n    aave: \"Aave\",\n    uniswap: \"Uniswap\",\n    compound: \"Compound\",\n    sushiswap: \"SushiSwap\",\n    curve: \"Curve\",\n    pancakeswap: \"PancakeSwap\",\n    balancer: \"Balancer\",\n    maker: \"MakerDAO\",\n    \"1inch\": \"1inch\",\n    synthetix: \"Synthetix\",\n    yearn: \"Yearn Finance\",\n    convex: \"Convex Finance\",\n    lido: \"Lido\",\n    frax: \"Frax\",\n  };\n\n  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      protocols.push(protocol);\n    }\n  }\n\n  return protocols;\n}\n","/**\n * Cross Chain Action\n *\n * Direct cross-chain analysis tool that compares DeFi opportunities across chains\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Multi-chain comparison from natural language queries using LLM\n * - Cross-chain yield opportunities and protocol analysis\n * - Bridge data and cross-chain strategy suggestions\n * - Smart chain filtering using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract chains and analysis criteria from user query using LLM\n * 2. Fetch multi-chain data from DeFiLlama\n * 3. Return structured cross-chain data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\ninterface CrossChainCriteria {\n  targetChains: string[];\n  analysisType: \"comparison\" | \"arbitrage\" | \"yield\" | \"general\";\n  minTvl: number;\n  focusCategories: string[];\n}\n\ninterface ChainAnalysis {\n  name: string;\n  tvl: number;\n  protocolCount: number;\n  topProtocols: Array<{\n    name: string;\n    tvl: number;\n    category: string;\n  }>;\n  dominanceMetrics: {\n    totalMarketShare: number;\n    categoryLeader: string;\n  };\n}\n\ninterface BridgeOpportunity {\n  name: string;\n  displayName: string;\n  volume24h: number;\n  supportedChains: string[];\n  category: string;\n}\n\ninterface CrossChainYield {\n  protocol: string;\n  chain: string;\n  apy: number;\n  tvl: number;\n  category: string;\n  riskLevel: \"low\" | \"medium\" | \"high\";\n}\n\ninterface StructuredCrossChainData {\n  analysisType: string;\n  targetChains: string[];\n  chainAnalysis: ChainAnalysis[];\n  bridgeOpportunities: BridgeOpportunity[];\n  crossChainYields: CrossChainYield[];\n  summary: {\n    totalTvlAcrossChains: number;\n    totalProtocols: number;\n    averageYield: number;\n    topChainByTvl: string;\n  };\n}\n\nconst extractCrossChainTemplate = `Extract cross-chain analysis parameters from the user's request for multi-chain DeFi analysis.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- Chain names as per /v2/chains and /bridges endpoints: \"Ethereum\", \"Arbitrum\", \"Optimism\", \"Polygon\", \"Avalanche\", \"Fantom\", \"BSC\"\n- Bridge data uses proper case chain names in chains array\n- Yield data matches chain names from /pools endpoint\n\nThe user might express cross-chain requests in various ways:\n- \"Compare Ethereum vs Arbitrum DeFi\" → chains: [\"Ethereum\", \"Arbitrum\"], analysis: \"comparison\"\n- \"Best bridges to move assets\" → analysis: \"bridge\", focus: [\"bridge protocols\"]\n- \"Cross-chain yield farming opportunities\" → analysis: \"yield\", focus: [\"yield farming\"]\n- \"Arbitrage between Polygon and BSC\" → chains: [\"Polygon\", \"BSC\"], analysis: \"arbitrage\"\n- \"Layer 2 protocol comparison\" → chains: [\"Arbitrum\", \"Optimism\", \"Polygon\"], analysis: \"comparison\"\n- \"Multi-chain lending protocols\" → focus: [\"lending\"], analysis: \"comparison\"\n- \"Migrate from Ethereum to cheaper chains\" → sourceChain: \"Ethereum\", analysis: \"migration\"\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"targetChains\": [\"Chain names as per DeFiLlama API: Ethereum/Arbitrum/Optimism/Polygon/Avalanche/Fantom/BSC\"],\n  \"sourceChain\": \"Source chain if migration mentioned\",\n  \"analysisType\": \"comparison/arbitrage/yield/bridge/migration/general\",\n  \"focusCategories\": [\"Category focus: lending/dex/staking/bridge/yield if mentioned\"],\n  \"minTvlPreference\": \"large/medium/small/any (based on user preference)\",\n  \"riskTolerance\": \"low/medium/high (if mentioned)\",\n  \"specificProtocols\": [\"Protocol names if specifically mentioned\"],\n  \"metrics\": [\"tvl/volume/fees/apy if specific metrics requested\"],\n  \"timeframe\": \"24h/7d/30d if historical comparison mentioned\",\n  \"includeDetails\": true/false (if user wants detailed breakdown)\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const crossChainAction: Action = {\n  name: \"CROSS_CHAIN_ANALYSIS\",\n  similes: [\n    \"cross chain\",\n    \"multi chain\",\n    \"bridge assets\",\n    \"chain comparison\",\n    \"arbitrage opportunities\",\n    \"L2 analysis\",\n    \"chain migration\",\n    \"cross chain yield\",\n    \"bridge protocols\",\n    \"multi chain defi\",\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    const userQuestion = message.content.text?.toLowerCase() || \"\";\n\n    const crossChainKeywords = [\n      \"cross chain\",\n      \"multi chain\",\n      \"bridge\",\n      \"arbitrage\",\n      \"l2\",\n      \"layer 2\",\n      \"polygon\",\n      \"arbitrum\",\n      \"optimism\",\n      \"avalanche\",\n      \"chains\",\n      \"chain comparison\",\n      \"migrate\",\n      \"move assets\",\n      \"different chains\",\n      \"across chains\",\n    ];\n\n    return crossChainKeywords.some((keyword) => userQuestion.includes(keyword));\n  },\n  description:\n    \"Analyzes cross-chain DeFi opportunities and comparisons using LLM-based parameter extraction\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    logger.info(\"[CROSS_CHAIN] Starting cross-chain analysis\");\n\n    try {\n      const userQuestion = message.content.text || \"\";\n\n      // Extract cross-chain criteria using LLM first, with fallback to regex\n      let criteria: CrossChainCriteria;\n\n      // Check if we have explicit criteria in options\n      if (options?.crossChainParams) {\n        criteria = options.crossChainParams as CrossChainCriteria;\n      } else {\n        // Use LLM to extract cross-chain criteria\n        const prompt = extractCrossChainTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            criteria = {\n              targetChains: parsed.targetChains || [],\n              analysisType: parsed.analysisType || \"general\",\n              minTvl: parseMinTvlFromPreference(parsed.minTvlPreference),\n              focusCategories: parsed.focusCategories || [],\n            };\n\n            // Ensure we have target chains\n            if (criteria.targetChains.length === 0) {\n              if (parsed.sourceChain) {\n                criteria.targetChains = [\n                  parsed.sourceChain,\n                  \"Arbitrum\",\n                  \"Polygon\",\n                  \"Optimism\",\n                ];\n              } else {\n                criteria.targetChains = [\n                  \"Ethereum\",\n                  \"Arbitrum\",\n                  \"Polygon\",\n                  \"Optimism\",\n                ];\n              }\n            }\n\n            logger.info(\n              `[CROSS_CHAIN] LLM extracted criteria: ${JSON.stringify(criteria)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            criteria = extractCrossChainCriteriaLegacy(userQuestion);\n          }\n        } else {\n          logger.warn(\n            \"[CROSS_CHAIN] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          criteria = extractCrossChainCriteriaLegacy(userQuestion);\n        }\n      }\n\n      logger.info(\n        `[CROSS_CHAIN] Analyzing chains: ${criteria.targetChains.join(\", \")}, type: ${criteria.analysisType}`,\n      );\n\n      // Fetch cross-chain data\n      const defiLlamaService = runtime.getService<DefiLlamaService>(\n        DefiLlamaService.serviceType,\n      );\n\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const [protocols, chains, yields, bridges] = await Promise.all([\n        defiLlamaService.getProtocols(),\n        defiLlamaService.getChains(),\n        defiLlamaService.getYields(),\n        defiLlamaService.getBridges({ includeChains: true }),\n      ]);\n\n      // Structure cross-chain analysis\n      const structuredData = buildCrossChainAnalysis(\n        protocols,\n        chains,\n        yields,\n        bridges,\n        criteria,\n      );\n\n      logger.info(\"[CROSS_CHAIN] Cross-chain analysis completed successfully\");\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with cross-chain analysis based on data: ${JSON.stringify(structuredData)}\n\nQuestion: ${userQuestion}\n\nProvide insights on:\n- Key differences and opportunities across chains\n- Best protocols and yields on each chain\n- Bridge recommendations for asset movement\n- Strategic cross-chain opportunities\n\nKeep response focused, practical, and under 150 words.`,\n        temperature: 0.7,\n        stop: [\"<END>\"],\n      });\n\n      if (callback) {\n        await callback({\n          text:\n            response ||\n            \"Unable to analyze cross-chain opportunities at this time.\",\n          actions: ['CROSS_CHAIN_ANALYSIS'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response || \"Cross-chain analysis completed\",\n        success: true,\n        data: {\n          actionName: \"CROSS_CHAIN_ANALYSIS\",\n          extractedCriteria: criteria,\n          structuredData,\n          crossChainAnalysisCompleted: true,\n          chainsAnalyzed: structuredData.chainAnalysis.length,\n          bridgesFound: structuredData.bridgeOpportunities.length,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    } catch (error) {\n      const errorMessage = `Failed to analyze cross-chain opportunities: ${error}`;\n      logger.error(`[CROSS_CHAIN] ${errorMessage}`);\n\n      if (callback) {\n        await callback({\n          text: \"I encountered an error while analyzing cross-chain opportunities. Please try again.\",\n          source: \"CROSS_CHAIN_ANALYSIS\",\n        });\n      }\n\n      return {\n        text: \"Error analyzing cross-chain opportunities. Please try again.\",\n        success: false,\n        data: {\n          actionName: \"CROSS_CHAIN_ANALYSIS\",\n          error: errorMessage,\n          crossChainAnalysisCompleted: false,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"user\",\n        content: { text: \"Compare DeFi opportunities on Ethereum vs Arbitrum\" },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's a comprehensive comparison of DeFi opportunities on Ethereum vs Arbitrum: [detailed analysis]\",\n          source: \"CROSS_CHAIN_ANALYSIS\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"What are the best bridges to move assets between chains?\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here are the top bridges for cross-chain asset movement: [bridge recommendations with security analysis]\",\n          source: \"CROSS_CHAIN_ANALYSIS\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: { text: \"Find cross-chain arbitrage opportunities\" },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Based on current data, here are potential cross-chain arbitrage opportunities: [arbitrage analysis]\",\n          source: \"CROSS_CHAIN_ANALYSIS\",\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for cross-chain data extraction and formatting\n\nfunction parseMinTvlFromPreference(preference?: string): number {\n  switch (preference?.toLowerCase()) {\n    case \"large\":\n      return 500000000; // $500M\n    case \"medium\":\n      return 50000000; // $50M\n    case \"small\":\n      return 5000000; // $5M\n    case \"any\":\n      return 1000000; // $1M\n    default:\n      return 50000000; // Default $50M\n  }\n}\n\nfunction extractCrossChainCriteriaLegacy(query: string): CrossChainCriteria {\n  const lowerQuery = query.toLowerCase();\n\n  // Extract target chains\n  const chains: string[] = [];\n  const chainKeywords = {\n    ethereum: \"Ethereum\",\n    arbitrum: \"Arbitrum\",\n    optimism: \"Optimism\",\n    polygon: \"Polygon\",\n    avalanche: \"Avalanche\",\n    fantom: \"Fantom\",\n    bsc: \"BSC\",\n    \"binance smart chain\": \"BSC\",\n  };\n\n  for (const [keyword, chain] of Object.entries(chainKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      chains.push(chain);\n    }\n  }\n\n  // If no specific chains mentioned, include major ones\n  if (chains.length === 0) {\n    chains.push(\"Ethereum\", \"Arbitrum\", \"Polygon\", \"Optimism\");\n  }\n\n  // Determine analysis type\n  let analysisType: \"comparison\" | \"arbitrage\" | \"yield\" | \"general\" =\n    \"general\";\n  if (\n    lowerQuery.includes(\"compare\") ||\n    lowerQuery.includes(\"comparison\") ||\n    lowerQuery.includes(\"vs\")\n  ) {\n    analysisType = \"comparison\";\n  } else if (\n    lowerQuery.includes(\"arbitrage\") ||\n    lowerQuery.includes(\"price difference\")\n  ) {\n    analysisType = \"arbitrage\";\n  } else if (\n    lowerQuery.includes(\"yield\") ||\n    lowerQuery.includes(\"farming\") ||\n    lowerQuery.includes(\"apy\")\n  ) {\n    analysisType = \"yield\";\n  }\n\n  // Extract minimum TVL preference\n  let minTvl = 50000000; // Default $50M\n  if (lowerQuery.includes(\"large\") || lowerQuery.includes(\"established\")) {\n    minTvl = 500000000; // $500M for large protocols\n  } else if (lowerQuery.includes(\"small\") || lowerQuery.includes(\"emerging\")) {\n    minTvl = 5000000; // $5M for smaller protocols\n  }\n\n  // Extract focus categories\n  const categories: string[] = [];\n  const categoryKeywords = {\n    lending: \"Lending\",\n    dex: \"Dexs\",\n    staking: \"Liquid Staking\",\n    bridge: \"Bridge\",\n    yield: \"Yield\",\n  };\n\n  for (const [keyword, category] of Object.entries(categoryKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      categories.push(category);\n    }\n  }\n\n  return {\n    targetChains: chains,\n    analysisType,\n    minTvl,\n    focusCategories: categories,\n  };\n}\n\nfunction buildCrossChainAnalysis(\n  protocols: Array<{\n    name: string;\n    tvl?: number;\n    category: string;\n    chain?: string;\n  }>,\n  chains: Array<{ name: string; tvl?: number }>,\n  yields: Array<{\n    project: string;\n    chain?: string;\n    apy: number;\n    tvlUsd: number;\n  }>,\n  bridges: Array<{\n    name: string;\n    displayName?: string;\n    lastDailyVolume?: number;\n    chains?: string[];\n  }>,\n  criteria: CrossChainCriteria,\n): StructuredCrossChainData {\n  // Filter chains based on criteria (case-insensitive for robustness)\n  const targetChainData = chains.filter((chain) =>\n    criteria.targetChains.some(\n      (targetChain) => targetChain.toLowerCase() === chain.name.toLowerCase(),\n    ),\n  );\n\n  // Build chain analysis\n  const chainAnalysis: ChainAnalysis[] = targetChainData.map((chain) => {\n    const chainProtocols = protocols.filter(\n      (p) =>\n        p.chain &&\n        chain.name &&\n        p.chain.toLowerCase() === chain.name.toLowerCase() &&\n        (p.tvl || 0) >= criteria.minTvl,\n    );\n\n    const topProtocols = chainProtocols\n      .sort((a, b) => (b.tvl || 0) - (a.tvl || 0))\n      .slice(0, 5)\n      .map((p) => ({\n        name: p.name,\n        tvl: p.tvl || 0,\n        category: p.category,\n      }));\n\n    const totalTvl = chainProtocols.reduce((sum, p) => sum + (p.tvl || 0), 0);\n    const totalMarketTvl = chains.reduce((sum, c) => sum + (c.tvl || 0), 0);\n\n    return {\n      name: chain.name,\n      tvl: chain.tvl || 0,\n      protocolCount: chainProtocols.length,\n      topProtocols,\n      dominanceMetrics: {\n        totalMarketShare:\n          totalMarketTvl > 0 ? ((chain.tvl || 0) / totalMarketTvl) * 100 : 0,\n        categoryLeader: topProtocols[0]?.category || \"Unknown\",\n      },\n    };\n  });\n\n  // Build bridge opportunities (case-insensitive chain matching)\n  const bridgeOpportunities: BridgeOpportunity[] = bridges\n    .filter((bridge) => {\n      if (!bridge.chains) return false;\n      return criteria.targetChains.some((targetChain) =>\n        bridge.chains!.some(\n          (bridgeChain) =>\n            bridgeChain.toLowerCase() === targetChain.toLowerCase(),\n        ),\n      );\n    })\n    .map((bridge) => ({\n      name: bridge.name,\n      displayName: bridge.displayName || bridge.name,\n      volume24h: bridge.lastDailyVolume || 0,\n      supportedChains: bridge.chains || [],\n      category: \"Bridge\",\n    }))\n    .sort((a, b) => b.volume24h - a.volume24h)\n    .slice(0, 6);\n\n  // Build cross-chain yields (case-insensitive chain matching)\n  const crossChainYields: CrossChainYield[] = yields\n    .filter((yieldPool) => {\n      if (!yieldPool.chain) return false;\n      if (\n        !criteria.targetChains.some(\n          (targetChain) =>\n            targetChain.toLowerCase() === yieldPool.chain!.toLowerCase(),\n        )\n      )\n        return false;\n      if (yieldPool.tvlUsd < criteria.minTvl * 0.1) return false; // At least 10% of min TVL\n      return true;\n    })\n    .map((yieldPool) => ({\n      protocol: yieldPool.project,\n      chain: yieldPool.chain!,\n      apy: yieldPool.apy,\n      tvl: yieldPool.tvlUsd,\n      category: \"Yield\",\n      riskLevel: assessCrossChainYieldRisk(yieldPool),\n    }))\n    .sort((a, b) => b.apy - a.apy)\n    .slice(0, 8);\n\n  // Calculate summary\n  const totalTvlAcrossChains = chainAnalysis.reduce(\n    (sum, chain) => sum + chain.tvl,\n    0,\n  );\n  const totalProtocols = chainAnalysis.reduce(\n    (sum, chain) => sum + chain.protocolCount,\n    0,\n  );\n  const averageYield =\n    crossChainYields.length > 0\n      ? crossChainYields.reduce((sum, y) => sum + y.apy, 0) /\n        crossChainYields.length\n      : 0;\n  const topChainByTvl =\n    chainAnalysis.length > 0\n      ? chainAnalysis.sort((a, b) => b.tvl - a.tvl)[0].name\n      : \"Unknown\";\n\n  return {\n    analysisType: criteria.analysisType,\n    targetChains: criteria.targetChains,\n    chainAnalysis,\n    bridgeOpportunities,\n    crossChainYields,\n    summary: {\n      totalTvlAcrossChains,\n      totalProtocols,\n      averageYield,\n      topChainByTvl,\n    },\n  };\n}\n\nfunction assessCrossChainYieldRisk(yieldPool: {\n  apy: number;\n  tvlUsd: number;\n}): \"low\" | \"medium\" | \"high\" {\n  let riskScore = 0;\n\n  // APY risk\n  if (yieldPool.apy > 50) riskScore += 2;\n  else if (yieldPool.apy > 20) riskScore += 1;\n\n  // TVL risk\n  if (yieldPool.tvlUsd < 5000000) riskScore += 2;\n  else if (yieldPool.tvlUsd < 25000000) riskScore += 1;\n\n  if (riskScore <= 0) return \"low\";\n  if (riskScore <= 2) return \"medium\";\n  return \"high\";\n}\n","/**\n * Fees Volume Action\n *\n * Direct fees and volume data fetcher that retrieves protocol economics\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Protocol/chain filtering from natural language queries using LLM\n * - Current fees and volume metrics (revenue, daily fees, trading volume)\n * - Multi-protocol batch data retrieval\n * - Smart filtering using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract protocols/chains from user query using LLM\n * 2. Fetch fees and volume data from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\nimport type { ProtocolFees, DexVolume } from \"../types\";\n\ninterface FeesVolumeCriteria {\n  targetProtocols: string[];\n  chainFilter: string | null;\n  analysisType: \"fees\" | \"volume\" | \"both\";\n}\n\ninterface StructuredFeesVolumeData {\n  criteria: FeesVolumeCriteria;\n  protocolFees: ProtocolFees[];\n  dexVolumes: DexVolume[];\n  summary: {\n    totalDailyFees: number;\n    totalDailyVolume: number;\n    protocolCount: number;\n    avgFeeEfficiency: number;\n  };\n}\n\nconst extractFeesVolumeTemplate = `Extract fees and volume analysis parameters from the user's request for protocol economics data.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /overview/fees endpoint returns {protocols: []} with protocol names, total24h, revenue24h, change_1d, chains\n- /overview/dexs endpoint returns {protocols: []} with protocol names, total24h, total7d, change_1d, change_7d, chains\n- Chain names in proper case: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n- Protocol names as returned by API: \"Uniswap\", \"Aave\", \"Compound\", \"Curve\", etc.\n\nThe user might express fees/volume requests in various ways:\n- \"Uniswap fees analysis\" → protocols: [\"Uniswap\"], analysisType: \"fees\"\n- \"DEX trading volumes\" → analysisType: \"volume\", category: \"dex\"\n- \"Ethereum protocol fees vs volume\" → chains: [\"Ethereum\"], analysisType: \"both\"\n- \"Compare Aave and Compound revenue\" → protocols: [\"Aave\", \"Compound\"], analysisType: \"fees\"\n- \"Top 5 protocols by volume\" → count: 5, sortBy: \"volume\", analysisType: \"volume\"\n- \"Protocol economics on Polygon\" → chains: [\"Polygon\"], analysisType: \"both\"\n- \"Daily fees for lending protocols\" → category: \"lending\", analysisType: \"fees\"\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"protocols\": [\"Protocol names if mentioned: Uniswap/Aave/Compound/Curve\"],\n  \"chains\": [\"Chain names as per API: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche\"],\n  \"analysisType\": \"fees/volume/both (what user wants to analyze)\",\n  \"category\": [\"dex/lending/derivatives if mentioned\"],\n  \"timeframe\": \"24h/7d/30d (time period if specified)\",\n  \"metrics\": [\"revenue/volume/fees/efficiency if specifically requested\"],\n  \"sortBy\": \"fees/volume/name/change (how to sort results)\",\n  \"count\": number (how many results, default 10),\n  \"includeBreakdown\": true/false (if user wants detailed breakdown),\n  \"compareMode\": true/false (if user wants comparison analysis)\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const feesVolumeAction: Action = {\n  name: \"FEE_VOLUME_DATA\",\n  similes: [\n    \"protocol fees\",\n    \"trading volume\",\n    \"revenue analysis\",\n    \"dex volume\",\n    \"protocol economics\",\n    \"fee comparison\",\n    \"volume trends\",\n    \"protocol profitability\",\n    \"trading activity\",\n    \"fee structure\",\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    const userQuestion = message.content.text?.toLowerCase() || \"\";\n\n    const feesVolumeKeywords = [\n      \"fees\",\n      \"revenue\",\n      \"volume\",\n      \"trading\",\n      \"economics\",\n      \"profitability\",\n      \"fee structure\",\n      \"daily fees\",\n      \"trading volume\",\n      \"protocol revenue\",\n      \"dex volume\",\n      \"fee comparison\",\n      \"volume analysis\",\n      \"earnings\",\n    ];\n\n    return feesVolumeKeywords.some((keyword) => userQuestion.includes(keyword));\n  },\n  description:\n    \"Retrieves protocol fees and trading volume data from DeFiLlama using LLM parameter extraction\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: any,\n    options: any,\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    logger.info(\"[FEES_VOLUME] Starting fees and volume data action\");\n\n    try {\n      const userQuestion = message.content.text || \"\";\n\n      // Extract fees/volume criteria using LLM first, with fallback to regex\n      let extractedParams: any;\n\n      // Check if we have explicit params in options\n      if (options?.feesVolumeParams) {\n        extractedParams = options.feesVolumeParams;\n      } else {\n        // Use LLM to extract criteria\n        const prompt = extractFeesVolumeTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              protocols: parsed.protocols || [],\n              chains: parsed.chains || [],\n              analysisType: parsed.analysisType || \"both\",\n              category: parsed.category || [],\n              timeframe: parsed.timeframe || \"24h\",\n              metrics: parsed.metrics || [],\n              sortBy: parsed.sortBy || \"volume\",\n              count: parsed.count || 10,\n              includeBreakdown: parsed.includeBreakdown || false,\n              compareMode: parsed.compareMode || false,\n            };\n\n            logger.info(\n              `[FEES_VOLUME] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            const chainFilter = extractChainFromQueryLegacy(userQuestion);\n            const targetProtocols =\n              extractProtocolsFromQueryLegacy(userQuestion);\n            extractedParams = {\n              protocols: targetProtocols,\n              chains: chainFilter ? [chainFilter] : [],\n              analysisType: \"both\",\n              category: [],\n              timeframe: \"24h\",\n              metrics: [],\n              sortBy: \"volume\",\n              count: 10,\n              includeBreakdown: false,\n              compareMode: false,\n            };\n          }\n        } else {\n          logger.warn(\n            \"[FEES_VOLUME] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          const chainFilter = extractChainFromQueryLegacy(userQuestion);\n          const targetProtocols = extractProtocolsFromQueryLegacy(userQuestion);\n          extractedParams = {\n            protocols: targetProtocols,\n            chains: chainFilter ? [chainFilter] : [],\n            analysisType: \"both\",\n            category: [],\n            timeframe: \"24h\",\n            metrics: [],\n            sortBy: \"volume\",\n            count: 10,\n            includeBreakdown: false,\n            compareMode: false,\n          };\n        }\n      }\n\n      // Extract chain filter from params (use first chain if multiple)\n      const chainFilter =\n        extractedParams.chains && extractedParams.chains.length > 0\n          ? extractedParams.chains[0]\n          : null;\n\n      logger.info(\n        `[FEES_VOLUME] Fetching data for chain: ${chainFilter || \"all\"}, analysis: ${extractedParams.analysisType}`,\n      );\n\n      // Fetch fees and volume data\n      const defiLlamaService = runtime.getService<DefiLlamaService>(\n        DefiLlamaService.serviceType,\n      );\n\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const [feesData, volumeData] = await Promise.all([\n        chainFilter\n          ? defiLlamaService.getProtocolFeesByChain(chainFilter, {\n              excludeTotalDataChart: true,\n              excludeTotalDataChartBreakdown: true,\n              dataType: \"dailyFees\",\n            })\n          : defiLlamaService.getProtocolFees({\n              excludeTotalDataChart: true,\n              excludeTotalDataChartBreakdown: true,\n              dataType: \"dailyFees\",\n            }),\n        chainFilter\n          ? defiLlamaService.getDexVolumesByChain(chainFilter, {\n              excludeTotalDataChart: true,\n              excludeTotalDataChartBreakdown: true,\n            })\n          : defiLlamaService.getDexVolumes({\n              excludeTotalDataChart: true,\n              excludeTotalDataChartBreakdown: true,\n            }),\n      ]);\n\n      // Filter data based on LLM extracted parameters\n      const filteredData = filterFeesVolumeDataLLM(\n        feesData,\n        volumeData,\n        extractedParams,\n      );\n\n      // Structure data for LLM response\n      const structuredData = buildFeesVolumeDataLLM(\n        filteredData,\n        extractedParams,\n      );\n\n      logger.info(\"[FEES_VOLUME] Data fetched and structured successfully\");\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with fees and volume analysis based on data: ${JSON.stringify(structuredData)}\n\nQuestion: ${userQuestion}\n\nProvide insights on:\n- Protocol revenue trends and sustainability\n- Trading volume patterns and market share\n- Fee efficiency and competitive positioning\n- Chain-specific performance if relevant\n\nKeep response focused, data-driven, and under 150 words.`,\n        temperature: 0.7,\n        stop: [\"<END>\"],\n      });\n\n      if (callback) {\n        await callback({\n          text:\n            response || \"Unable to analyze fees and volume data at this time.\",\n          actions: ['FEE_VOLUME_DATA'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response || \"Analysis completed\",\n        success: true,\n        data: {\n          actionName: \"FEES_VOLUME_DATA\",\n          extractedParams,\n          structuredData,\n          feesVolumeDataFetched: true,\n          protocolsAnalyzed: extractedParams.protocols.length || \"all\",\n          chainFilterUsed: chainFilter || \"all\",\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    } catch (error) {\n      const errorMessage = `Failed to fetch fees and volume data: ${error}`;\n      logger.error(`[FEES_VOLUME] ${errorMessage}`);\n\n      if (callback) {\n        await callback({\n          text: \"I encountered an error while fetching fees and volume data. Please try again.\",\n          source: \"FEE_VOLUME_DATA\",\n        });\n      }\n\n      return {\n        text: \"Error fetching fees and volume data. Please try again.\",\n        success: false,\n        data: {\n          actionName: \"FEES_VOLUME_DATA\",\n          error: errorMessage,\n          feesVolumeDataFetched: false,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"user\",\n        content: { text: \"Show me the fee revenue for Uniswap and Aave\" },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's the current fee revenue analysis for Uniswap and Aave: [analysis based on latest DeFiLlama data]\",\n          source: \"FEE_VOLUME_DATA\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"Which protocols generate the most trading volume on Ethereum?\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Based on the latest data, here are the top volume-generating protocols on Ethereum: [detailed breakdown]\",\n          source: \"FEE_VOLUME_DATA\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"Compare DEX trading volumes across different chains\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's a comparison of DEX trading volumes across major chains: [cross-chain analysis]\",\n          source: \"FEE_VOLUME_DATA\",\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for fees/volume data extraction and formatting\n\nfunction filterFeesVolumeDataLLM(\n  feesData: ProtocolFees[],\n  volumeData: DexVolume[],\n  params: any,\n): any {\n  let filteredFees = feesData;\n  let filteredVolume = volumeData;\n\n  // Filter by specific protocols if mentioned (case-insensitive)\n  if (params.protocols && params.protocols.length > 0) {\n    if (Array.isArray(feesData)) {\n      filteredFees = feesData.filter((item: ProtocolFees) =>\n        params.protocols.some((protocol: string) =>\n          item.name?.toLowerCase().includes(protocol.toLowerCase()),\n        ),\n      );\n    }\n\n    if (Array.isArray(volumeData)) {\n      filteredVolume = volumeData.filter((item: DexVolume) =>\n        params.protocols.some((protocol: string) =>\n          item.name?.toLowerCase().includes(protocol.toLowerCase()),\n        ),\n      );\n    }\n  }\n\n  // Filter by category if specified\n  if (params.category && params.category.length > 0) {\n    if (Array.isArray(feesData)) {\n      filteredFees = feesData.filter((item: ProtocolFees) =>\n        params.category.some((cat: string) =>\n          item.category?.toLowerCase().includes(cat.toLowerCase()),\n        ),\n      );\n    }\n    // Note: Volume data doesn't typically have category field in DeFiLlama API\n  }\n\n  return {\n    fees: filteredFees,\n    volume: filteredVolume,\n  };\n}\n\nfunction buildFeesVolumeDataLLM(\n  data: any,\n  params: any,\n): StructuredFeesVolumeData {\n  const result: StructuredFeesVolumeData = {\n    criteria: {\n      targetProtocols: params.protocols || [],\n      chainFilter:\n        params.chains && params.chains.length > 0 ? params.chains[0] : null,\n      analysisType: params.analysisType || \"both\",\n    },\n    protocolFees: [],\n    dexVolumes: [],\n    summary: {\n      totalDailyFees: 0,\n      totalDailyVolume: 0,\n      protocolCount: 0,\n      avgFeeEfficiency: 0,\n    },\n  };\n\n  // Process fees data\n  if (Array.isArray(data.fees)) {\n    let feesArray = data.fees;\n\n    // Sort by fees if specified\n    if (params.sortBy === \"fees\") {\n      feesArray = feesArray.sort(\n        (a: ProtocolFees, b: ProtocolFees) =>\n          (b.total24h || 0) - (a.total24h || 0),\n      );\n    }\n\n    result.protocolFees = feesArray\n      .slice(0, params.count || 10)\n      .map((protocol: ProtocolFees) => ({\n        name: protocol.name || \"Unknown\",\n        total24h: protocol.total24h || 0,\n        revenue24h: protocol.revenue24h || 0,\n        change_1d: protocol.change_1d || 0,\n        category: protocol.category || \"Unknown\",\n      }));\n\n    result.summary.protocolCount = data.fees.length;\n    result.summary.totalDailyFees = data.fees.reduce(\n      (sum: number, p: ProtocolFees) => sum + (p.total24h || 0),\n      0,\n    );\n  }\n\n  // Process volume data\n  if (Array.isArray(data.volume)) {\n    let volumeArray = data.volume;\n\n    // Sort by volume if specified\n    if (params.sortBy === \"volume\") {\n      volumeArray = volumeArray.sort(\n        (a: DexVolume, b: DexVolume) => (b.total24h || 0) - (a.total24h || 0),\n      );\n    }\n\n    result.dexVolumes = volumeArray\n      .slice(0, params.count || 10)\n      .map((dex: DexVolume) => ({\n        name: dex.name || \"Unknown\",\n        total24h: dex.total24h || 0,\n        total7d: dex.total7d || 0,\n        change_1d: dex.change_1d || 0,\n        change_7d: dex.change_7d || 0,\n      }));\n\n    result.summary.totalDailyVolume = data.volume.reduce(\n      (sum: number, d: DexVolume) => sum + (d.total24h || 0),\n      0,\n    );\n  }\n\n  return result;\n}\n\nfunction extractChainFromQueryLegacy(query: string): string | null {\n  const chainKeywords = {\n    ethereum: \"Ethereum\",\n    polygon: \"Polygon\",\n    bsc: \"BSC\",\n    \"binance smart chain\": \"BSC\",\n    arbitrum: \"Arbitrum\",\n    optimism: \"Optimism\",\n    avalanche: \"Avalanche\",\n    solana: \"Solana\",\n    fantom: \"Fantom\",\n  };\n\n  const lowerQuery = query.toLowerCase();\n  for (const [keyword, chain] of Object.entries(chainKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      return chain;\n    }\n  }\n  return null;\n}\n\nfunction extractProtocolsFromQueryLegacy(query: string): string[] {\n  const protocols: string[] = [];\n  const lowerQuery = query.toLowerCase();\n\n  const protocolKeywords = {\n    uniswap: \"Uniswap\",\n    aave: \"Aave\",\n    compound: \"Compound\",\n    sushiswap: \"SushiSwap\",\n    curve: \"Curve\",\n    pancakeswap: \"PancakeSwap\",\n    balancer: \"Balancer\",\n    \"1inch\": \"1inch\",\n    \"0x\": \"0x\",\n    dydx: \"dYdX\",\n    gmx: \"GMX\",\n    synthetix: \"Synthetix\",\n  };\n\n  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      protocols.push(protocol);\n    }\n  }\n\n  return protocols;\n}\n","/**\n * Price Data Action\n *\n * Direct cryptocurrency price fetcher that retrieves current price information\n * from DeFiLlama's price feeds. Returns raw data for LLM processing.\n *\n * Features:\n * - Token symbol and ID resolution from natural language queries\n * - Current price data fetching\n * - Multi-token batch price retrieval\n * - Smart token validation using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract tokens from user query using LLM\n * 2. Fetch prices from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  composePrompt,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\n// Simple type for token price data\ninterface TokenPriceData {\n  token: string;\n  symbol: string;\n  price: number;\n  confidence: number;\n  timestamp: number;\n  formatted: string;\n}\n\nconst extractTokensTemplate = `Extract token information from the user's request for cryptocurrency price data.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- Chain identifiers must be lowercase: ethereum, bsc, polygon, arbitrum, optimism, avax, fantom\n- Token format: {chain}:{address} (e.g., \"ethereum:0x123...\", \"polygon:0x456...\")  \n- CoinGecko format: coingecko:{id} (e.g., \"coingecko:ethereum\", \"coingecko:bitcoin\")\n- All chain names in API parameters MUST be lowercase as per DeFiLlama API spec\n\nThe user might express price requests in various ways:\n- \"What's the price of ETH?\" → token: \"ethereum\"\n- \"Show me BTC and ETH prices\" → tokens: [\"bitcoin\", \"ethereum\"]\n- \"How much is 0x1234...abcd worth on Polygon?\" → contract address with chain\n- \"What's USDC trading at?\" → stablecoin symbol\n- \"Check the value of UNI and LINK\" → multiple DeFi tokens\n- \"Price of Solana and Cardano\" → full token names\n- \"What's the current worth of MATIC?\" → alternative names\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"tokens\": [\n    {\n      \"identifier\": \"Symbol, name, or contract address\",\n      \"chain\": \"LOWERCASE chain identifier (ethereum/polygon/arbitrum/optimism/bsc/avax/fantom) as per DeFiLlama API\",\n      \"type\": \"symbol/name/address/coingecko_id\"\n    }\n  ],\n  \"requestType\": \"single/multiple/comparison\",\n  \"includeDetails\": true/false (if user wants detailed info beyond just price),\n  \"searchWidth\": \"4h/24h/48h (time window for price search if mentioned)\"\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const priceDataAction: Action = {\n  name: \"PRICE_DATA\",\n  similes: [\n    \"GET_PRICE\",\n    \"TOKEN_PRICE\",\n    \"COIN_PRICE\",\n    \"CURRENT_PRICE\",\n    \"PRICE_CHECK\",\n    \"MARKET_PRICE\",\n    \"TOKEN_VALUE\",\n    \"CRYPTO_PRICE\",\n  ],\n  description: `Simple cryptocurrency price data fetcher. This action:\n1. Extracts token symbols/names from user queries using LLM\n2. Fetches current price data from DeFiLlama price feeds\n3. Returns clean, structured price data for analysis or display\n4. Supports multiple tokens and basic price information\n\nUSE WHEN: User asks about specific token prices or needs price data.\nRETURNS: Raw price data without analysis - use ANALYZE_DEFI_DATA for insights.`,\n\n  validate: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state?: State,\n  ): Promise<boolean> => {\n    const text = message.content.text?.toLowerCase() || \"\";\n\n    // Check for price keywords\n    if (\n      !text.includes(\"price\") &&\n      !text.includes(\"worth\") &&\n      !text.includes(\"value\") &&\n      !text.includes(\"cost\")\n    ) {\n      return false;\n    }\n\n    // Extract potential tokens from query\n    const tokens = extractTokensFromQueryLegacy(text, \"\");\n\n    // Validate if we found recognizable tokens\n    return tokens.length > 0;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    try {\n      logger.info(\"[PRICE_DATA] Starting price data fetch\");\n\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const userQuestion = message.content.text || \"\";\n\n      // Extract tokens using LLM first, with fallback to regex\n      let tokens: string[] = [];\n      let searchWidth: string | undefined = undefined;\n\n      // Check if we have explicit tokens in options\n      if (options?.tokens) {\n        tokens = Array.isArray(options.tokens)\n          ? options.tokens\n          : [options.tokens];\n      } else {\n        // Use LLM to extract tokens\n        const prompt = extractTokensTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            if (parsed.tokens && Array.isArray(parsed.tokens)) {\n              for (const tokenInfo of parsed.tokens) {\n                const resolvedToken = resolveTokenToId(\n                  tokenInfo.identifier,\n                  tokenInfo.chain,\n                  tokenInfo.type,\n                );\n                if (resolvedToken) {\n                  tokens.push(resolvedToken);\n                }\n              }\n\n              // Extract searchWidth if specified\n              if (parsed.searchWidth) {\n                searchWidth = parsed.searchWidth;\n              }\n\n              logger.info(\n                `[PRICE_DATA] LLM extracted tokens: ${tokens.join(\", \")}, searchWidth: ${searchWidth || \"default\"}`,\n              );\n            } else {\n              logger.warn(\n                \"[PRICE_DATA] LLM response missing tokens array, falling back to regex\",\n              );\n              tokens = extractTokensFromQueryLegacy(userQuestion, \"\");\n            }\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            tokens = extractTokensFromQueryLegacy(userQuestion, \"\");\n          }\n        } else {\n          logger.warn(\n            \"[PRICE_DATA] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          tokens = extractTokensFromQueryLegacy(userQuestion, \"\");\n        }\n      }\n\n      if (tokens.length === 0) {\n        throw new Error(\"No valid tokens found in query\");\n      }\n\n      // Validate tokens before making API call\n      const validTokens = tokens.filter((token) => {\n        // Check for valid format: either chain:address or coingecko:id\n        const isValidFormat = /^(\\w+:0x[a-fA-F0-9]{40}|coingecko:[\\w-]+)$/.test(\n          token,\n        );\n        if (!isValidFormat) {\n          logger.warn(`[PRICE_DATA] Skipping invalid token format: ${token}`);\n          return false;\n        }\n        return true;\n      });\n\n      if (validTokens.length === 0) {\n        throw new Error(\"No valid token formats found after validation\");\n      }\n\n      if (validTokens.length !== tokens.length) {\n        logger.info(\n          `[PRICE_DATA] Filtered ${tokens.length - validTokens.length} invalid tokens`,\n        );\n      }\n\n      logger.info(\n        `[PRICE_DATA] Fetching prices for validated tokens: ${validTokens.join(\", \")}`,\n      );\n\n      // Fetch current prices\n      const currentPrices = await defiLlamaService.getCoinPrices(\n        validTokens,\n        searchWidth,\n      );\n\n      // Structure response data\n      const priceData: Record<string, any> = {};\n      for (const token of validTokens) {\n        const price = currentPrices.coins?.[token];\n        if (price) {\n          priceData[token] = {\n            token: getTokenDisplayName(token),\n            symbol: price.symbol,\n            price: price.price,\n            confidence: price.confidence,\n            timestamp: price.timestamp,\n            formatted: formatPrice(price.price),\n          };\n        }\n      }\n\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely based on data: ${JSON.stringify(priceData)}\n        and context: ${JSON.stringify(message.content)}`,\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to fetch price data at this time.\",\n          actions: ['PRICE_DATA'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response,\n        success: true,\n        data: {\n          actionName: \"PRICE_DATA\",\n          tokens: validTokens,\n          prices: priceData,\n          priceDataFetched: true,\n          tokensFound: validTokens.length,\n          timestamp: Date.now(),\n        },\n      };\n    } catch (error) {\n      logger.error(\"[PRICE_DATA] Error:\", error);\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n\n      return {\n        text: `Failed to fetch price data: ${errorMessage}`,\n        success: false,\n        error: error instanceof Error ? error : new Error(errorMessage),\n        data: {\n          actionName: \"PRICE_DATA\",\n          error: errorMessage,\n          priceDataFetched: false,\n          timestamp: Date.now(),\n        },\n      };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"What is the current price of ETH?\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Retrieved price data for: Ethereum (ETH): $2,543.67, confidence 99%, updated 2m ago\",\n          actions: [\"PRICE_DATA\"],\n        },\n      },\n    ],\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"Show me BTC and ETH prices\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"Bitcoin (BTC): $43,256.78, confidence 99%, updated 1m ago, Ethereum (ETH): $2,543.67, updated 2m ago\",\n          actions: [\"PRICE_DATA\"],\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for price data extraction and formatting\n\nfunction resolveTokenToId(\n  identifier: string,\n  chain?: string,\n  type?: string,\n): string | null {\n  const lowerIdentifier = identifier.toLowerCase();\n\n  // Handle contract addresses\n  if (type === \"address\" || /^0x[a-fA-F0-9]{40}$/.test(identifier)) {\n    const resolvedChain = chain || guessChainFromContext(lowerIdentifier);\n    return `${resolvedChain}:${identifier}`;\n  }\n\n  // Handle coingecko IDs\n  if (type === \"coingecko_id\" || identifier.startsWith(\"coingecko:\")) {\n    return identifier.startsWith(\"coingecko:\")\n      ? identifier\n      : `coingecko:${identifier}`;\n  }\n\n  // Try token mappings first\n  const tokenMap = getTokenMappings();\n  if (tokenMap[lowerIdentifier]) {\n    return tokenMap[lowerIdentifier];\n  }\n\n  // For unknown tokens, try as coingecko ID but log warning\n  logger.warn(\n    `[PRICE_DATA] Unknown token \"${identifier}\", attempting as coingecko ID`,\n  );\n  return `coingecko:${lowerIdentifier}`;\n}\n\nfunction extractTokensFromQueryLegacy(\n  query: string,\n  assetsFromAI: string,\n): string[] {\n  const found: string[] = [];\n  const searchText = (query + \" \" + assetsFromAI).toLowerCase();\n\n  // 1. Check for contract addresses (0x...)\n  const addressPattern = /0x[a-fA-F0-9]{40}/g;\n  const addresses = searchText.match(addressPattern);\n  if (addresses) {\n    for (const addr of addresses) {\n      // Try to guess chain from context, default to ethereum\n      const chain = guessChainFromContext(searchText);\n      found.push(`${chain}:${addr}`);\n    }\n  }\n\n  // 2. Check for explicit chain:address format\n  const chainAddressPattern = /(\\w+):0x[a-fA-F0-9]{40}/g;\n  const chainAddresses = searchText.match(chainAddressPattern);\n  if (chainAddresses) {\n    found.push(...chainAddresses);\n  }\n\n  // 3. Check for coingecko: format\n  const coingeckoPattern = /coingecko:[\\w-]+/g;\n  const coingeckoIds = searchText.match(coingeckoPattern);\n  if (coingeckoIds) {\n    found.push(...coingeckoIds);\n  }\n\n  // 4. Common token symbol/name mappings (expanded)\n  const tokenMap = getTokenMappings();\n  for (const [token, id] of Object.entries(tokenMap)) {\n    if (searchText.includes(token)) {\n      found.push(id);\n    }\n  }\n\n  // 5. Pattern-based extraction for unknown tokens\n  if (found.length === 0) {\n    const patterns = [\n      /price of ([a-z0-9]+)/i,\n      /([a-z0-9]+) price/i,\n      /how much is ([a-z0-9]+)/i,\n      /value of ([a-z0-9]+)/i,\n      /([a-z0-9]+) worth/i,\n      /([a-z0-9]+) token/i,\n    ];\n\n    for (const pattern of patterns) {\n      const match = searchText.match(pattern);\n      if (match) {\n        const token = match[1].toLowerCase();\n        // First try known mappings\n        if (tokenMap[token]) {\n          found.push(tokenMap[token]);\n        } else {\n          // Try as coingecko ID (many tokens use their symbol as coingecko ID)\n          found.push(`coingecko:${token}`);\n        }\n      }\n    }\n  }\n\n  return Array.from(new Set(found)); // Remove duplicates\n}\n\nfunction guessChainFromContext(text: string): string {\n  const chainKeywords: Record<string, string> = {\n    ethereum: \"ethereum\",\n    eth: \"ethereum\",\n    mainnet: \"ethereum\",\n    polygon: \"polygon\",\n    matic: \"polygon\",\n    arbitrum: \"arbitrum\",\n    arb: \"arbitrum\",\n    optimism: \"optimism\",\n    op: \"optimism\",\n    bsc: \"bsc\",\n    binance: \"bsc\",\n    avalanche: \"avax\",\n    avax: \"avax\",\n    fantom: \"fantom\",\n    ftm: \"fantom\",\n  };\n\n  for (const [keyword, chain] of Object.entries(chainKeywords)) {\n    if (text.includes(keyword)) {\n      return chain;\n    }\n  }\n\n  return \"ethereum\"; // Default to ethereum\n}\n\nfunction getTokenMappings(): Record<string, string> {\n  return {\n    // Major cryptocurrencies\n    bitcoin: \"coingecko:bitcoin\",\n    btc: \"coingecko:bitcoin\",\n    ethereum: \"coingecko:ethereum\",\n    eth: \"coingecko:ethereum\",\n\n    // Stablecoins\n    usdc: \"coingecko:usd-coin\",\n    usdt: \"coingecko:tether\",\n    dai: \"coingecko:dai\",\n    busd: \"coingecko:binance-usd\",\n    frax: \"coingecko:frax\",\n\n    // Layer 1s\n    bnb: \"coingecko:binancecoin\",\n    ada: \"coingecko:cardano\",\n    sol: \"coingecko:solana\",\n    matic: \"coingecko:matic-network\",\n    polygon: \"coingecko:matic-network\",\n    avax: \"coingecko:avalanche-2\",\n    avalanche: \"coingecko:avalanche-2\",\n    dot: \"coingecko:polkadot\",\n    atom: \"coingecko:cosmos\",\n\n    // DeFi tokens\n    link: \"coingecko:chainlink\",\n    uni: \"coingecko:uniswap\",\n    aave: \"coingecko:aave\",\n    comp: \"coingecko:compound-governance-token\",\n    mkr: \"coingecko:maker\",\n    crv: \"coingecko:curve-dao-token\",\n    snx: \"coingecko:havven\",\n    synthetix: \"coingecko:havven\",\n    sushi: \"coingecko:sushi\",\n\n    // Layer 2s\n    arb: \"coingecko:arbitrum\",\n    arbitrum: \"coingecko:arbitrum\",\n    op: \"coingecko:optimism\",\n    optimism: \"coingecko:optimism\",\n\n    // Popular DeFi\n    gmx: \"coingecko:gmx\",\n    ldo: \"coingecko:lido-dao\",\n    rpl: \"coingecko:rocket-pool\",\n    bal: \"coingecko:balancer\",\n    yfi: \"coingecko:yearn-finance\",\n\n    // Meme coins (popular ones)\n    doge: \"coingecko:dogecoin\",\n    shib: \"coingecko:shiba-inu\",\n    pepe: \"coingecko:pepe\",\n  };\n}\n\n// Utility functions\n\nfunction getTokenDisplayName(tokenId: string): string {\n  const nameMap: Record<string, string> = {\n    \"coingecko:bitcoin\": \"Bitcoin\",\n    \"coingecko:ethereum\": \"Ethereum\",\n    \"coingecko:usd-coin\": \"USD Coin\",\n    \"coingecko:tether\": \"Tether\",\n    \"coingecko:dai\": \"Dai\",\n    \"coingecko:binancecoin\": \"BNB\",\n    \"coingecko:cardano\": \"Cardano\",\n    \"coingecko:solana\": \"Solana\",\n    \"coingecko:matic-network\": \"Polygon\",\n    \"coingecko:avalanche-2\": \"Avalanche\",\n    \"coingecko:polkadot\": \"Polkadot\",\n    \"coingecko:chainlink\": \"Chainlink\",\n    \"coingecko:uniswap\": \"Uniswap\",\n    \"coingecko:aave\": \"Aave\",\n    \"coingecko:compound-governance-token\": \"Compound\",\n    \"coingecko:maker\": \"Maker\",\n    \"coingecko:curve-dao-token\": \"Curve\",\n    \"coingecko:havven\": \"Synthetix\",\n  };\n\n  return nameMap[tokenId] || tokenId.split(\":\")[1] || tokenId;\n}\n\nfunction formatPrice(price: number): string {\n  if (price >= 1000) {\n    return price.toLocaleString(\"en-US\", {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    });\n  } else if (price >= 1) {\n    return price.toFixed(4);\n  } else {\n    return price.toFixed(6);\n  }\n}\n\nfunction formatTimestamp(timestamp: number): string {\n  const now = Date.now() / 1000;\n  const diffSeconds = now - timestamp;\n\n  if (diffSeconds < 60) {\n    return \"just now\";\n  } else if (diffSeconds < 3600) {\n    return `${Math.floor(diffSeconds / 60)}m ago`;\n  } else if (diffSeconds < 86400) {\n    return `${Math.floor(diffSeconds / 3600)}h ago`;\n  } else {\n    return `${Math.floor(diffSeconds / 86400)}d ago`;\n  }\n}\n\nfunction formatLargeNumber(num: number): string {\n  if (num >= 1e12) return (num / 1e12).toFixed(1) + \"T\";\n  if (num >= 1e9) return (num / 1e9).toFixed(1) + \"B\";\n  if (num >= 1e6) return (num / 1e6).toFixed(1) + \"M\";\n  if (num >= 1e3) return (num / 1e3).toFixed(1) + \"K\";\n  return num.toFixed(0);\n}\n","/**\n * DeFi Recommendation Action\n *\n * Direct investment recommendation tool that suggests DeFi opportunities\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Investment criteria extraction from natural language queries using LLM\n * - Yield opportunity and protocol recommendations\n * - Risk-adjusted investment suggestions\n * - Smart filtering by APY, TVL, and safety metrics using LLM and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract investment preferences from user query using LLM\n * 2. Fetch protocol and yield data from DeFiLlama\n * 3. Return structured recommendations for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\ninterface InvestmentCriteria {\n  targetApy: number;\n  riskTolerance: \"low\" | \"medium\" | \"high\";\n  minTvl: number;\n  chains: string[];\n  categories: string[];\n}\n\ninterface YieldOpportunity {\n  project: string;\n  symbol: string;\n  apy: number;\n  tvlUsd: number;\n  chain: string;\n  category: string;\n  riskLevel: \"low\" | \"medium\" | \"high\";\n}\n\ninterface ProtocolRecommendation {\n  name: string;\n  tvl: number;\n  category: string;\n  chain: string;\n  reason: string;\n  riskLevel: \"low\" | \"medium\" | \"high\";\n}\n\ninterface StructuredRecommendations {\n  investmentCriteria: InvestmentCriteria;\n  yieldOpportunities: YieldOpportunity[];\n  protocolRecommendations: ProtocolRecommendation[];\n  summary: {\n    totalOpportunities: number;\n    averageApy: number;\n    totalTvl: number;\n    riskDistribution: { low: number; medium: number; high: number };\n  };\n}\n\nconst extractRecommendationTemplate = `Extract DeFi investment recommendation parameters from the user's request for investment advice and opportunities.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /protocols endpoint returns protocol data with tvl, category, chains\n- /pools endpoint returns yield data with {status: \"success\", data: [{apy, tvlUsd, project, symbol, chain}]}\n- Protocol categories: \"Dexs\", \"Lending\", \"Liquid Staking\", \"Derivatives\", \"Yield\", \"CDP\", \"Bridge\"\n- Chain names in proper case: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n- Risk assessment based on TVL, APY levels, and protocol maturity\n\nThe user might express investment requests in various ways:\n- \"Good DeFi yield farming opportunities\" → targetApy: 10, category: \"Yield\", riskTolerance: \"medium\"\n- \"Where should I invest $10k for moderate risk?\" → investmentAmount: 10000, riskTolerance: \"medium\"\n- \"Best low-risk DeFi protocols for beginners\" → riskTolerance: \"low\", categories: [\"Lending\", \"Liquid Staking\"]\n- \"High yield opportunities above 15%\" → targetApy: 15, riskTolerance: \"high\"\n- \"Safe stablecoin farming on Ethereum\" → chains: [\"Ethereum\"], targetApy: 5, riskTolerance: \"low\"\n- \"Conservative DeFi with $100k\" → investmentAmount: 100000, riskTolerance: \"low\", minTvl: 1000000000\n- \"Aggressive yield strategies\" → riskTolerance: \"high\", targetApy: 20\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"targetApy\": number (desired APY percentage, default 8),\n  \"riskTolerance\": \"low/medium/high (investment risk preference)\",\n  \"investmentAmount\": number (investment amount in USD if mentioned),\n  \"minTvl\": number (minimum protocol TVL for safety),\n  \"chains\": [\"Chain names as per API: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche\"],\n  \"categories\": [\"Protocol categories: Dexs/Lending/Liquid Staking/Derivatives/Yield/CDP\"],\n  \"timeHorizon\": \"short/medium/long (investment timeframe)\",\n  \"strategy\": \"conservative/balanced/aggressive/yield_focused\",\n  \"excludeRisky\": true/false (if user wants to avoid high-risk protocols),\n  \"diversified\": true/false (if user wants diversified recommendations)\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const defiRecommendationAction: Action = {\n  name: \"DEFI_RECOMMENDATIONS\",\n  similes: [\n    \"investment advice\",\n    \"recommendations\",\n    \"suggest protocols\",\n    \"yield farming\",\n    \"best opportunities\",\n    \"where to invest\",\n    \"defi strategies\",\n    \"portfolio suggestions\",\n    \"investment ideas\",\n    \"yield opportunities\",\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    const userQuestion = message.content.text?.toLowerCase() || \"\";\n\n    const recommendationKeywords = [\n      \"recommend\",\n      \"suggest\",\n      \"advice\",\n      \"best\",\n      \"should i\",\n      \"where to\",\n      \"invest\",\n      \"yield\",\n      \"farming\",\n      \"opportunities\",\n      \"strategy\",\n      \"portfolio\",\n      \"apy\",\n      \"returns\",\n      \"earnings\",\n      \"profitable\",\n      \"good protocols\",\n    ];\n\n    return recommendationKeywords.some((keyword) =>\n      userQuestion.includes(keyword),\n    );\n  },\n  description:\n    \"Provides DeFi investment recommendations and yield opportunities using LLM parameter extraction\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: Record<string, unknown>,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    logger.info(\"[DEFI_RECOMMENDATIONS] Starting recommendation analysis\");\n\n    try {\n      const userQuestion = message.content.text || \"\";\n\n      // Extract investment criteria using LLM first, with fallback to regex\n      let extractedParams: any;\n\n      // Check if we have explicit params in options\n      if (options?.recommendationParams) {\n        extractedParams = options.recommendationParams;\n      } else {\n        // Use LLM to extract criteria\n        const prompt = extractRecommendationTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              targetApy: parsed.targetApy || 8,\n              riskTolerance: parsed.riskTolerance || \"medium\",\n              investmentAmount: parsed.investmentAmount || 0,\n              minTvl:\n                parsed.minTvl ||\n                (parsed.riskTolerance === \"low\"\n                  ? 100000000\n                  : parsed.riskTolerance === \"high\"\n                    ? 1000000\n                    : 10000000),\n              chains: parsed.chains || [],\n              categories: parsed.categories || [],\n              timeHorizon: parsed.timeHorizon || \"medium\",\n              strategy: parsed.strategy || \"balanced\",\n              excludeRisky: parsed.excludeRisky || false,\n              diversified: parsed.diversified || true,\n            };\n\n            logger.info(\n              `[DEFI_RECOMMENDATIONS] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            extractedParams = extractInvestmentCriteriaLegacy(userQuestion);\n          }\n        } else {\n          logger.warn(\n            \"[DEFI_RECOMMENDATIONS] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          extractedParams = extractInvestmentCriteriaLegacy(userQuestion);\n        }\n      }\n\n      logger.info(\n        `[DEFI_RECOMMENDATIONS] Analyzing with criteria: ${JSON.stringify(extractedParams)}`,\n      );\n\n      // Fetch recommendation data\n      const defiLlamaService = runtime.getService<DefiLlamaService>(\n        DefiLlamaService.serviceType,\n      );\n\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const [protocols, yields] = await Promise.all([\n        defiLlamaService.getProtocols(),\n        defiLlamaService.getYields(),\n      ]);\n\n      // Structure recommendations using LLM extracted parameters\n      const structuredData = buildRecommendationsLLM(\n        protocols,\n        yields,\n        extractedParams,\n      );\n\n      logger.info(\n        \"[DEFI_RECOMMENDATIONS] Recommendations generated successfully\",\n      );\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with investment recommendations based on data: ${JSON.stringify(structuredData)}\n\nQuestion: ${userQuestion}\n\nProvide insights on:\n- Top yield opportunities matching user criteria\n- Protocol recommendations with risk assessment\n- Strategic investment suggestions\n- Risk management considerations\n\nKeep response focused, practical, and under 150 words.`,\n        temperature: 0.7,\n        stop: [\"<END>\"],\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to generate recommendations at this time.\",\n          actions: ['DEFI_RECOMMENDATIONS'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response || \"Investment recommendations generated\",\n        success: true,\n        data: {\n          actionName: \"DEFI_RECOMMENDATIONS\",\n          extractedParams,\n          structuredData,\n          recommendationsGenerated: true,\n          opportunitiesFound: structuredData.yieldOpportunities.length,\n          protocolsRecommended: structuredData.protocolRecommendations.length,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    } catch (error) {\n      const errorMessage = `Failed to generate recommendations: ${error}`;\n      logger.error(`[DEFI_RECOMMENDATIONS] ${errorMessage}`);\n\n      if (callback) {\n        await callback({\n          text: \"I encountered an error while generating recommendations. Please try again.\",\n          source: \"DEFI_RECOMMENDATIONS\",\n        });\n      }\n\n      return {\n        text: \"Error generating recommendations. Please try again.\",\n        success: false,\n        data: {\n          actionName: \"DEFI_RECOMMENDATIONS\",\n          error: errorMessage,\n          recommendationsGenerated: false,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"Recommend some good DeFi yield farming opportunities\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here are the top DeFi yield farming opportunities based on current market conditions: [analysis with recommendations]\",\n          source: \"DEFI_RECOMMENDATIONS\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"Where should I invest $10k for moderate risk and good returns?\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"For $10k with moderate risk tolerance, here are my top protocol recommendations: [detailed investment strategy]\",\n          source: \"DEFI_RECOMMENDATIONS\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"What are the best low-risk DeFi protocols for beginners?\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"For beginners seeking low-risk DeFi exposure, I recommend these established protocols: [beginner-friendly recommendations]\",\n          source: \"DEFI_RECOMMENDATIONS\",\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for recommendation data extraction and formatting\n\nfunction buildRecommendationsLLM(\n  protocols: Array<{\n    name: string;\n    tvl?: number;\n    category: string;\n    chain?: string;\n  }>,\n  yields: Array<{\n    project: string;\n    symbol: string;\n    apy: number;\n    tvlUsd: number;\n    chain?: string;\n    stablecoin?: boolean;\n  }>,\n  params: any,\n): StructuredRecommendations {\n  // Convert LLM parameters to legacy format for compatibility\n  const criteria: InvestmentCriteria = {\n    targetApy: params.targetApy,\n    riskTolerance: params.riskTolerance,\n    minTvl: params.minTvl,\n    chains: params.chains,\n    categories: params.categories,\n  };\n\n  // Filter and score yield opportunities\n  const yieldOpportunities: YieldOpportunity[] = yields\n    .filter((pool) => {\n      // APY filtering based on target and risk tolerance\n      const minApyThreshold =\n        params.riskTolerance === \"low\"\n          ? params.targetApy * 0.3\n          : params.targetApy * 0.5;\n      if (pool.apy < minApyThreshold) return false;\n\n      // TVL filtering based on risk tolerance and minimum requirements\n      const minTvlThreshold =\n        params.riskTolerance === \"low\"\n          ? params.minTvl * 0.5\n          : params.minTvl * 0.1;\n      if (pool.tvlUsd < minTvlThreshold) return false;\n\n      // Chain filtering\n      if (\n        params.chains.length > 0 &&\n        pool.chain &&\n        !params.chains.includes(pool.chain)\n      )\n        return false;\n\n      // Exclude risky pools if requested\n      if (params.excludeRisky && pool.apy > 50) return false;\n\n      return true;\n    })\n    .map((pool) => ({\n      project: pool.project,\n      symbol: pool.symbol,\n      apy: pool.apy,\n      tvlUsd: pool.tvlUsd,\n      chain: pool.chain || \"Multi-chain\",\n      category: \"Yield\",\n      riskLevel: assessYieldRiskLLM(pool, params),\n    }))\n    .sort((a, b) => {\n      // Enhanced scoring based on strategy\n      if (params.strategy === \"conservative\") {\n        return b.tvlUsd - a.tvlUsd; // Prioritize TVL for safety\n      } else if (params.strategy === \"yield_focused\") {\n        return b.apy - a.apy; // Prioritize highest APY\n      } else {\n        // Balanced scoring by APY and TVL\n        const scoreA = a.apy * Math.log(a.tvlUsd + 1);\n        const scoreB = b.apy * Math.log(b.tvlUsd + 1);\n        return scoreB - scoreA;\n      }\n    })\n    .slice(0, params.diversified ? 8 : 5);\n\n  // Filter and recommend protocols\n  const protocolRecommendations: ProtocolRecommendation[] = protocols\n    .filter((protocol) => {\n      const protocolTvl = protocol.tvl || 0;\n      if (protocolTvl < params.minTvl) return false;\n\n      // Category filtering\n      if (\n        params.categories.length > 0 &&\n        !params.categories.includes(protocol.category)\n      )\n        return false;\n\n      // Chain filtering\n      if (\n        params.chains.length > 0 &&\n        protocol.chain &&\n        !params.chains.includes(protocol.chain)\n      )\n        return false;\n\n      // Risk filtering\n      if (params.excludeRisky) {\n        const highRiskCategories = [\n          \"Derivatives\",\n          \"Cross Chain\",\n          \"Algo-Stables\",\n        ];\n        if (highRiskCategories.includes(protocol.category)) return false;\n      }\n\n      return true;\n    })\n    .map((protocol) => ({\n      name: protocol.name,\n      tvl: protocol.tvl || 0,\n      category: protocol.category,\n      chain: protocol.chain || \"Multi-chain\",\n      reason: generateRecommendationReasonLLM(protocol, params),\n      riskLevel: assessProtocolRiskLLM(protocol, params),\n    }))\n    .sort((a, b) => {\n      // Sort based on strategy\n      if (params.strategy === \"conservative\") {\n        return b.tvl - a.tvl;\n      } else {\n        // Consider both TVL and category fit\n        const scoreA =\n          a.tvl + (params.categories.includes(a.category) ? a.tvl * 0.2 : 0);\n        const scoreB =\n          b.tvl + (params.categories.includes(b.category) ? b.tvl * 0.2 : 0);\n        return scoreB - scoreA;\n      }\n    })\n    .slice(0, params.diversified ? 6 : 4);\n\n  // Calculate summary statistics\n  const totalOpportunities =\n    yieldOpportunities.length + protocolRecommendations.length;\n  const averageApy =\n    yieldOpportunities.length > 0\n      ? yieldOpportunities.reduce((sum, op) => sum + op.apy, 0) /\n        yieldOpportunities.length\n      : 0;\n  const totalTvl = protocolRecommendations.reduce(\n    (sum, rec) => sum + rec.tvl,\n    0,\n  );\n\n  const riskDistribution = { low: 0, medium: 0, high: 0 };\n  [...yieldOpportunities, ...protocolRecommendations].forEach((item) => {\n    riskDistribution[item.riskLevel]++;\n  });\n\n  return {\n    investmentCriteria: criteria,\n    yieldOpportunities,\n    protocolRecommendations,\n    summary: {\n      totalOpportunities,\n      averageApy,\n      totalTvl,\n      riskDistribution,\n    },\n  };\n}\n\nfunction assessYieldRiskLLM(\n  pool: { apy: number; tvlUsd: number; stablecoin?: boolean },\n  params: any,\n): \"low\" | \"medium\" | \"high\" {\n  let riskScore = 0;\n\n  // APY risk assessment\n  if (pool.apy > 100) riskScore += 3;\n  else if (pool.apy > 50) riskScore += 2;\n  else if (pool.apy > 20) riskScore += 1;\n\n  // TVL risk assessment\n  if (pool.tvlUsd < 1000000) riskScore += 3;\n  else if (pool.tvlUsd < 10000000) riskScore += 2;\n  else if (pool.tvlUsd < 50000000) riskScore += 1;\n\n  // Stablecoin bonus\n  if (pool.stablecoin) riskScore -= 1;\n\n  // User risk tolerance adjustment\n  if (params.riskTolerance === \"low\") riskScore += 1;\n  else if (params.riskTolerance === \"high\") riskScore -= 1;\n\n  if (riskScore <= 1) return \"low\";\n  if (riskScore <= 3) return \"medium\";\n  return \"high\";\n}\n\nfunction assessProtocolRiskLLM(\n  protocol: { tvl?: number; category: string },\n  params: any,\n): \"low\" | \"medium\" | \"high\" {\n  let riskScore = 0;\n\n  // TVL risk\n  const protocolTvl = protocol.tvl || 0;\n  if (protocolTvl < 10000000) riskScore += 3;\n  else if (protocolTvl < 100000000) riskScore += 2;\n  else if (protocolTvl < 1000000000) riskScore += 1;\n\n  // Category risk\n  const highRiskCategories = [\"Derivatives\", \"Cross Chain\", \"Algo-Stables\"];\n  const lowRiskCategories = [\"Lending\", \"Liquid Staking\", \"CDP\"];\n\n  if (highRiskCategories.includes(protocol.category)) riskScore += 2;\n  else if (lowRiskCategories.includes(protocol.category)) riskScore -= 1;\n\n  // User risk tolerance adjustment\n  if (params.riskTolerance === \"low\") riskScore += 1;\n  else if (params.riskTolerance === \"high\") riskScore -= 1;\n\n  if (riskScore <= 1) return \"low\";\n  if (riskScore <= 3) return \"medium\";\n  return \"high\";\n}\n\nfunction generateRecommendationReasonLLM(\n  protocol: { name: string; tvl?: number; category: string },\n  params: any,\n): string {\n  const reasons = [];\n\n  const protocolTvl = protocol.tvl || 0;\n  if (protocolTvl > 5000000000) {\n    reasons.push(\"Massive TVL provides exceptional security\");\n  } else if (protocolTvl > 1000000000) {\n    reasons.push(\"High TVL provides strong security\");\n  }\n\n  if (protocol.category === \"Lending\" && params.riskTolerance === \"low\") {\n    reasons.push(\"Established lending protocol with proven track record\");\n  }\n\n  if (protocol.category === \"Dexs\" && params.strategy === \"yield_focused\") {\n    reasons.push(\"DEX with strong liquidity and yield opportunities\");\n  }\n\n  if (protocol.category === \"Liquid Staking\" && params.timeHorizon === \"long\") {\n    reasons.push(\"Liquid staking ideal for long-term strategies\");\n  }\n\n  if (params.categories.includes(protocol.category)) {\n    reasons.push(`Matches your ${protocol.category.toLowerCase()} preference`);\n  }\n\n  return reasons.length > 0 ? reasons[0] : \"Solid protocol fundamentals\";\n}\n\nfunction extractInvestmentCriteriaLegacy(query: string): any {\n  const lowerQuery = query.toLowerCase();\n\n  // Extract target APY\n  let targetApy = 8; // Default 8% APY\n  const apyMatch = lowerQuery.match(/(\\d+)%?\\s*(apy|yield|return)/);\n  if (apyMatch) {\n    targetApy = parseInt(apyMatch[1]);\n  } else if (\n    lowerQuery.includes(\"high yield\") ||\n    lowerQuery.includes(\"high return\")\n  ) {\n    targetApy = 15;\n  } else if (\n    lowerQuery.includes(\"conservative\") ||\n    lowerQuery.includes(\"safe\")\n  ) {\n    targetApy = 5;\n  }\n\n  // Extract risk tolerance\n  let riskTolerance: \"low\" | \"medium\" | \"high\" = \"medium\";\n  if (\n    lowerQuery.includes(\"conservative\") ||\n    lowerQuery.includes(\"safe\") ||\n    lowerQuery.includes(\"low risk\")\n  ) {\n    riskTolerance = \"low\";\n  } else if (\n    lowerQuery.includes(\"aggressive\") ||\n    lowerQuery.includes(\"high risk\") ||\n    lowerQuery.includes(\"risky\")\n  ) {\n    riskTolerance = \"high\";\n  }\n\n  // Extract minimum TVL preference\n  let minTvl = 10000000; // Default $10M\n  if (riskTolerance === \"low\") {\n    minTvl = 100000000; // $100M for conservative\n  } else if (riskTolerance === \"high\") {\n    minTvl = 1000000; // $1M for aggressive\n  }\n\n  // Extract chain preferences\n  const chains: string[] = [];\n  const chainKeywords = {\n    ethereum: \"Ethereum\",\n    polygon: \"Polygon\",\n    arbitrum: \"Arbitrum\",\n    optimism: \"Optimism\",\n    avalanche: \"Avalanche\",\n    bsc: \"BSC\",\n  };\n\n  for (const [keyword, chain] of Object.entries(chainKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      chains.push(chain);\n    }\n  }\n\n  // Extract category preferences\n  const categories: string[] = [];\n  const categoryKeywords = {\n    lending: \"Lending\",\n    dex: \"Dexs\",\n    \"yield farming\": \"Yield\",\n    staking: \"Liquid Staking\",\n    stablecoin: \"Stablecoins\",\n  };\n\n  for (const [keyword, category] of Object.entries(categoryKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      categories.push(category);\n    }\n  }\n\n  return {\n    targetApy,\n    riskTolerance,\n    minTvl,\n    chains,\n    categories,\n    strategy: \"balanced\",\n    excludeRisky: riskTolerance === \"low\",\n    diversified: true,\n  };\n}\n","/**\n * Risk Analysis Action\n *\n * Direct risk assessment tool that analyzes DeFi protocol safety\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Protocol/asset risk evaluation from natural language queries using LLM\n * - Smart contract, liquidity, and market risk assessment\n * - Multi-protocol risk comparison\n * - Risk category identification using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract protocols and risk concerns from user query using LLM\n * 2. Fetch protocol data from DeFiLlama\n * 3. Return structured risk data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\ninterface ProtocolInfo {\n  tvl?: number;\n  category?: string;\n  chains?: string[];\n  audits?: string;\n  audit_links?: string[] | null;\n  audit_note?: string;\n  listedAt?: number;\n  twitter?: string;\n  oracles?: string[];\n  governanceID?: string | null;\n}\n\ninterface RiskProtocolData {\n  protocol: string;\n  protocolInfo: ProtocolInfo;\n}\n\ninterface RiskAssessmentFactors {\n  overall: string;\n  factors: {\n    smart_contract: string;\n    liquidity: string;\n    market: string;\n    governance: string;\n  };\n  confidence: string;\n}\n\ninterface ProtocolRiskAssessment {\n  name: string;\n  currentTvl: number;\n  category: string;\n  chain: string;\n  auditStatus: string;\n  riskAssessment: RiskAssessmentFactors;\n  governance: string;\n  timeActive: string;\n}\n\ninterface MarketRiskData {\n  protocols: Array<{\n    name: string;\n    tvl: number;\n    category: string;\n    riskLevel: string;\n  }>;\n  marketTrends: {\n    totalTvl: number;\n    protocolCount: number;\n    categories: string[];\n  };\n}\n\ninterface StructuredRiskData {\n  targetProtocols: string[] | string;\n  riskCategories: string[];\n  protocolRisks: ProtocolRiskAssessment[];\n  marketRisks: MarketRiskData | null;\n  summary: {\n    totalProtocols: number;\n    riskLevels: { Low: number; Medium: number; High: number };\n    analysisScope: string;\n  };\n}\n\ninterface RiskDataCollection {\n  protocols?: RiskProtocolData[];\n}\n\nconst extractRiskAnalysisTemplate = `Extract risk analysis parameters from the user's request for DeFi protocol safety assessment.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /protocol/{protocol} endpoint returns protocol data with tvl, category, chains (array), audits, audit_note\n- Protocol categories: \"Dexs\", \"Lending\", \"Liquid Staking\", \"Derivatives\", \"Yield\", \"CDP\", \"Bridge\"\n- Chain names in proper case: \"Ethereum\", \"Polygon\", \"Arbitrum\", \"Optimism\", \"BSC\", \"Avalanche\"\n- Risk assessment based on TVL, audit status, time active, and category characteristics\n\nThe user might express risk analysis requests in various ways:\n- \"Is Aave safe to use?\" → protocols: [\"Aave\"], riskCategories: [\"smart_contract\", \"liquidity\", \"governance\"]\n- \"Smart contract risks in DeFi lending\" → analysisScope: \"category\", category: \"Lending\", riskCategories: [\"smart_contract\"]\n- \"Compare risk levels of Uniswap vs SushiSwap\" → protocols: [\"Uniswap\", \"SushiSwap\"], analysisType: \"comparison\"\n- \"Liquidity risks in small cap protocols\" → riskCategories: [\"liquidity\"], tvlFilter: \"low\", analysisScope: \"market\"\n- \"What are the governance risks in DeFi?\" → riskCategories: [\"governance\"], analysisScope: \"general\"\n- \"Security audit status of top protocols\" → riskCategories: [\"smart_contract\"], analysisScope: \"market\", focus: \"audits\"\n- \"Risk assessment for yield farming\" → category: \"Yield\", riskCategories: [\"smart_contract\", \"market\"]\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"protocols\": [\"Protocol names if mentioned: Aave/Uniswap/Compound/Curve\"],\n  \"riskCategories\": [\"smart_contract/liquidity/market/governance/regulatory/operational/technical\"],\n  \"analysisScope\": \"specific/category/market/general (scope of analysis)\",\n  \"analysisType\": \"assessment/comparison/overview/audit_review\",\n  \"category\": \"Dexs/Lending/Liquid Staking/Derivatives if mentioned\",\n  \"chains\": [\"Chain names if specified: Ethereum/Polygon/Arbitrum/Optimism/BSC/Avalanche\"],\n  \"riskTolerance\": \"conservative/moderate/aggressive (user's risk preference)\",\n  \"focus\": \"audits/tvl/governance/technical if specific focus mentioned\",\n  \"timeframe\": \"current/historical if mentioned\",\n  \"severity\": \"low/medium/high/all (level of risks to focus on)\"\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const riskAnalysisAction: Action = {\n  name: \"RISK_ANALYSIS\",\n  similes: [\n    \"risk assessment\",\n    \"safety analysis\",\n    \"security review\",\n    \"protocol risks\",\n    \"smart contract risks\",\n    \"liquidity risks\",\n    \"investment safety\",\n    \"due diligence\",\n    \"risk evaluation\",\n    \"security audit\",\n  ],\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    const userQuestion = message.content.text?.toLowerCase() || \"\";\n\n    const riskKeywords = [\n      \"risk\",\n      \"risks\",\n      \"safety\",\n      \"secure\",\n      \"dangerous\",\n      \"audit\",\n      \"security\",\n      \"smart contract\",\n      \"liquidity risk\",\n      \"impermanent loss\",\n      \"rug pull\",\n      \"exploit\",\n      \"hack\",\n      \"vulnerable\",\n      \"safe\",\n      \"unsafe\",\n      \"due diligence\",\n    ];\n\n    return riskKeywords.some((keyword) => userQuestion.includes(keyword));\n  },\n  description:\n    \"Analyzes DeFi protocol risks and safety concerns using LLM parameter extraction\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: any,\n    options: any,\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    logger.info(\"[RISK_ANALYSIS] Starting risk analysis\");\n\n    try {\n      const userQuestion = message.content.text || \"\";\n\n      // Extract risk analysis criteria using LLM first, with fallback to regex\n      let extractedParams: any;\n\n      // Check if we have explicit params in options\n      if (options?.riskParams) {\n        extractedParams = options.riskParams;\n      } else {\n        // Use LLM to extract criteria\n        const prompt = extractRiskAnalysisTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              protocols: parsed.protocols || [],\n              riskCategories: parsed.riskCategories || [\n                \"smart_contract\",\n                \"liquidity\",\n                \"market\",\n              ],\n              analysisScope: parsed.analysisScope || \"specific\",\n              analysisType: parsed.analysisType || \"assessment\",\n              category: parsed.category || undefined,\n              chains: parsed.chains || [],\n              riskTolerance: parsed.riskTolerance || \"moderate\",\n              focus: parsed.focus || undefined,\n              timeframe: parsed.timeframe || \"current\",\n              severity: parsed.severity || \"all\",\n            };\n\n            logger.info(\n              `[RISK_ANALYSIS] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            const targetProtocols =\n              extractProtocolsFromQueryLegacy(userQuestion);\n            const riskCategories =\n              extractRiskCategoriesFromQueryLegacy(userQuestion);\n            extractedParams = {\n              protocols: targetProtocols,\n              riskCategories: riskCategories,\n              analysisScope:\n                targetProtocols.length > 0 ? \"specific\" : \"general\",\n              analysisType: \"assessment\",\n              category: undefined,\n              chains: [],\n              riskTolerance: \"moderate\",\n              focus: undefined,\n              timeframe: \"current\",\n              severity: \"all\",\n            };\n          }\n        } else {\n          logger.warn(\n            \"[RISK_ANALYSIS] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          const targetProtocols = extractProtocolsFromQueryLegacy(userQuestion);\n          const riskCategories =\n            extractRiskCategoriesFromQueryLegacy(userQuestion);\n          extractedParams = {\n            protocols: targetProtocols,\n            riskCategories: riskCategories,\n            analysisScope: targetProtocols.length > 0 ? \"specific\" : \"general\",\n            analysisType: \"assessment\",\n            category: undefined,\n            chains: [],\n            riskTolerance: \"moderate\",\n            focus: undefined,\n            timeframe: \"current\",\n            severity: \"all\",\n          };\n        }\n      }\n\n      logger.info(\n        `[RISK_ANALYSIS] Analyzing risks for protocols: ${extractedParams.protocols.join(\", \") || \"general\"}, categories: ${extractedParams.riskCategories.join(\", \")}`,\n      );\n\n      // Fetch protocol data for risk analysis\n      const defiLlamaService = runtime.getService<DefiLlamaService>(\n        DefiLlamaService.serviceType,\n      );\n\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      let riskData: RiskDataCollection = {};\n\n      if (extractedParams.protocols.length > 0) {\n        // Fetch specific protocol data for risk analysis\n        const protocolDataPromises = extractedParams.protocols.map(\n          async (protocol: string) => {\n            try {\n              const protocolSlug = protocol.toLowerCase().replace(/\\s+/g, \"-\");\n              const protocolInfo =\n                await defiLlamaService.getProtocol(protocolSlug);\n              return { protocol, protocolInfo };\n            } catch (error) {\n              logger.warn(\n                `[RISK_ANALYSIS] Failed to fetch data for ${protocol}: ${error}`,\n              );\n              return null;\n            }\n          },\n        );\n\n        const protocolResults = await Promise.allSettled(protocolDataPromises);\n        riskData = {\n          protocols: protocolResults\n            .filter(\n              (\n                result,\n              ): result is PromiseFulfilledResult<{\n                protocol: string;\n                protocolInfo: any;\n              }> => result.status === \"fulfilled\" && result.value !== null,\n            )\n            .map((result) => result.value),\n        };\n      } else {\n        // Fetch general market data for risk assessment\n        const [protocols, chains] = await Promise.all([\n          defiLlamaService.getProtocols(),\n          defiLlamaService.getChains(),\n        ]);\n\n        // Filter by category if specified\n        let filteredProtocols = protocols;\n        if (extractedParams.category) {\n          filteredProtocols = protocols.filter(\n            (p: any) => p.category === extractedParams.category,\n          );\n        }\n\n        riskData = {\n          protocols: filteredProtocols.slice(0, 10).map((protocol) => ({\n            protocol: protocol.name,\n            protocolInfo: protocol,\n          })),\n        };\n      }\n\n      // Structure data for risk analysis using LLM extracted parameters\n      const structuredData = buildRiskAnalysisDataLLM(\n        riskData.protocols || [],\n        extractedParams,\n      );\n\n      logger.info(\n        \"[RISK_ANALYSIS] Risk data fetched and structured successfully\",\n      );\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with risk analysis based on data: ${JSON.stringify(structuredData)}\n\nQuestion: ${userQuestion}\n\nProvide insights on:\n- Key risk factors and security concerns\n- Protocol maturity and audit status\n- Liquidity and market risks\n- Smart contract risks and governance\n- Recommendations for risk mitigation\n\nKeep response focused, practical, and under 150 words.`,\n        temperature: 0.7,\n        stop: [\"<END>\"],\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to analyze risks at this time.\",\n          actions: ['RISK_ANALYSIS'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response || \"Risk analysis completed\",\n        success: true,\n        data: {\n          actionName: \"RISK_ANALYSIS\",\n          extractedParams,\n          structuredData,\n          riskAnalysisCompleted: true,\n          protocolsAnalyzed:\n            extractedParams.protocols.length || \"market overview\",\n          riskCategoriesUsed:\n            extractedParams.riskCategories.join(\", \") || \"general\",\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    } catch (error) {\n      const errorMessage = `Failed to analyze risks: ${error}`;\n      logger.error(`[RISK_ANALYSIS] ${errorMessage}`);\n\n      if (callback) {\n        await callback({\n          text: \"I encountered an error while analyzing risks. Please try again.\",\n          source: \"RISK_ANALYSIS\",\n        });\n      }\n\n      return {\n        text: \"Error analyzing risks. Please try again.\",\n        success: false,\n        data: {\n          actionName: \"RISK_ANALYSIS\",\n          error: errorMessage,\n          riskAnalysisCompleted: false,\n          timestamp: Date.now(),\n        },\n      } as ActionResult;\n    }\n  },\n  examples: [\n    [\n      {\n        name: \"user\",\n        content: { text: \"Is Aave safe to use? What are the main risks?\" },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's a comprehensive risk analysis of Aave: [analysis based on latest protocol data]\",\n          source: \"RISK_ANALYSIS\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: {\n          text: \"What are the smart contract risks in DeFi lending protocols?\",\n        },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here are the key smart contract risks in DeFi lending: [detailed risk breakdown]\",\n          source: \"RISK_ANALYSIS\",\n        },\n      },\n    ],\n    [\n      {\n        name: \"user\",\n        content: { text: \"Compare the risk levels of Uniswap vs SushiSwap\" },\n      },\n      {\n        name: \"assistant\",\n        content: {\n          text: \"Here's a comparative risk analysis of Uniswap vs SushiSwap: [risk comparison]\",\n          source: \"RISK_ANALYSIS\",\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for risk analysis data extraction and formatting\n\nfunction buildRiskAnalysisDataLLM(\n  data: RiskProtocolData[],\n  params: any,\n): StructuredRiskData {\n  const result: StructuredRiskData = {\n    targetProtocols:\n      params.protocols.length > 0 ? params.protocols : \"market overview\",\n    riskCategories: params.riskCategories,\n    protocolRisks: [],\n    marketRisks: null,\n    summary: {\n      totalProtocols: 0,\n      riskLevels: { Low: 0, Medium: 0, High: 0 },\n      analysisScope: params.analysisScope,\n    },\n  };\n\n  if (data.length > 0) {\n    if (params.protocols.length > 0) {\n      // Process specific protocol risk data\n      result.protocolRisks = data.map((item) => {\n        const protocolInfo = item.protocolInfo;\n        return {\n          name: item.protocol,\n          currentTvl: protocolInfo?.tvl || 0,\n          category: protocolInfo?.category || \"Unknown\",\n          chain: protocolInfo?.chains?.join(\", \") || \"Multi-chain\",\n          auditStatus:\n            protocolInfo?.audits || protocolInfo?.audit_links?.length\n              ? \"Audited\"\n              : \"Unknown\",\n          riskAssessment: assessProtocolRiskLLM(protocolInfo, params),\n          governance: protocolInfo?.governanceID || \"Not Available\",\n          timeActive: calculateTimeActiveLLM(protocolInfo?.listedAt || 0),\n        };\n      });\n    } else {\n      // Process market risk overview\n      result.marketRisks = {\n        protocols: data.slice(0, 10).map((protocol) => ({\n          name: protocol.protocol,\n          tvl: protocol.protocolInfo?.tvl || 0,\n          category: protocol.protocolInfo?.category || \"Unknown\",\n          riskLevel: assessGeneralRiskLLM(protocol.protocolInfo, params),\n        })),\n        marketTrends: {\n          totalTvl: data.reduce(\n            (sum: number, p) => sum + (p.protocolInfo?.tvl || 0),\n            0,\n          ),\n          protocolCount: data.length,\n          categories: [\n            ...new Set(\n              data\n                .map((p) => p.protocolInfo?.category)\n                .filter((cat): cat is string => Boolean(cat)),\n            ),\n          ],\n        },\n      };\n    }\n\n    result.summary.totalProtocols = data.length;\n    result.summary.riskLevels = calculateRiskDistributionLLM(data, params);\n  }\n\n  return result;\n}\n\nfunction assessProtocolRiskLLM(\n  protocolInfo: ProtocolInfo,\n  params: any,\n): RiskAssessmentFactors {\n  const riskFactors = {\n    smart_contract: \"Medium\", // Default\n    liquidity: \"Medium\",\n    market: \"Medium\",\n    governance: \"Medium\",\n  };\n\n  // Assess smart contract risk with enhanced criteria\n  if (protocolInfo?.audits || protocolInfo?.audit_links?.length) {\n    riskFactors.smart_contract = \"Low\";\n  } else if (\n    protocolInfo?.listedAt &&\n    Date.now() / 1000 - protocolInfo.listedAt > 365 * 24 * 3600\n  ) {\n    riskFactors.smart_contract = \"Medium\"; // Time-tested\n  } else {\n    riskFactors.smart_contract = \"High\";\n  }\n\n  // Enhanced liquidity risk assessment\n  const tvl = protocolInfo?.tvl || 0;\n  if (tvl > 5e9) {\n    riskFactors.liquidity = \"Low\";\n  } else if (tvl > 1e9) {\n    riskFactors.liquidity = \"Medium\";\n  } else if (tvl > 1e8) {\n    riskFactors.liquidity =\n      params.riskTolerance === \"conservative\" ? \"High\" : \"Medium\";\n  } else {\n    riskFactors.liquidity = \"High\";\n  }\n\n  // Enhanced market risk based on category and user tolerance\n  const category = protocolInfo?.category?.toLowerCase() || \"\";\n  if (category.includes(\"derivatives\") || category.includes(\"leverage\")) {\n    riskFactors.market = \"High\";\n  } else if (\n    category.includes(\"lending\") ||\n    category.includes(\"liquid staking\")\n  ) {\n    riskFactors.market =\n      params.riskTolerance === \"conservative\" ? \"Medium\" : \"Low\";\n  } else if (category.includes(\"dex\")) {\n    riskFactors.market = \"Medium\";\n  } else {\n    riskFactors.market = \"Medium\";\n  }\n\n  // Enhanced governance risk assessment using actual API data\n  if (protocolInfo?.governanceID) {\n    // Protocol has governance ID - suggests formal governance structure\n    riskFactors.governance = \"Low\";\n  } else if (protocolInfo?.oracles && protocolInfo.oracles.length > 0) {\n    // Multiple oracles suggest better decentralization\n    riskFactors.governance =\n      protocolInfo.oracles.length >= 2 ? \"Low\" : \"Medium\";\n  } else if (\n    protocolInfo?.listedAt &&\n    Date.now() / 1000 - protocolInfo.listedAt > 2 * 365 * 24 * 3600\n  ) {\n    // Long-standing protocols likely have better governance\n    riskFactors.governance = \"Medium\";\n  } else {\n    riskFactors.governance =\n      params.riskTolerance === \"conservative\" ? \"High\" : \"Medium\";\n  }\n\n  return {\n    overall: calculateOverallRiskLLM(riskFactors, params),\n    factors: riskFactors,\n    confidence:\n      (protocolInfo?.audits || protocolInfo?.audit_links?.length) && tvl > 1e9\n        ? \"High\"\n        : tvl > 1e8\n          ? \"Medium\"\n          : \"Low\",\n  };\n}\n\nfunction assessGeneralRiskLLM(protocolInfo: ProtocolInfo, params: any): string {\n  const tvl = protocolInfo?.tvl || 0;\n  const category = protocolInfo?.category?.toLowerCase() || \"\";\n\n  // Enhanced risk assessment based on user tolerance\n  if (params.riskTolerance === \"conservative\") {\n    if (tvl > 10e9 && !category.includes(\"derivatives\")) return \"Low\";\n    if (tvl > 2e9 && (category.includes(\"lending\") || category.includes(\"dex\")))\n      return \"Medium\";\n    return \"High\";\n  } else if (params.riskTolerance === \"aggressive\") {\n    if (tvl > 1e9) return \"Low\";\n    if (tvl > 1e8) return \"Medium\";\n    return \"High\";\n  } else {\n    // Moderate tolerance\n    if (tvl > 5e9) return \"Low\";\n    if (tvl > 1e9 && !category.includes(\"derivatives\")) return \"Medium\";\n    if (tvl > 1e8) return \"Medium\";\n    return \"High\";\n  }\n}\n\nfunction calculateTimeActiveLLM(listedAt: number): string {\n  if (!listedAt) return \"Unknown\";\n\n  const daysSince = (Date.now() / 1000 - listedAt) / 86400;\n\n  if (daysSince > 730) return `${Math.floor(daysSince / 365)} years`;\n  if (daysSince > 365) return `${Math.floor(daysSince / 365)} year`;\n  if (daysSince > 60) return `${Math.floor(daysSince / 30)} months`;\n  if (daysSince > 30) return `${Math.floor(daysSince / 30)} month`;\n  return `${Math.floor(daysSince)} days`;\n}\n\nfunction calculateOverallRiskLLM(riskFactors: any, params: any): string {\n  // Adjust weights based on user focus\n  let weights = {\n    smart_contract: 0.4,\n    liquidity: 0.3,\n    market: 0.2,\n    governance: 0.1,\n  };\n\n  if (params.focus === \"audits\") {\n    weights.smart_contract = 0.6;\n    weights.liquidity = 0.2;\n    weights.market = 0.1;\n    weights.governance = 0.1;\n  } else if (params.focus === \"tvl\") {\n    weights.liquidity = 0.5;\n    weights.smart_contract = 0.3;\n    weights.market = 0.1;\n    weights.governance = 0.1;\n  } else if (params.focus === \"governance\") {\n    weights.governance = 0.4;\n    weights.smart_contract = 0.3;\n    weights.liquidity = 0.2;\n    weights.market = 0.1;\n  }\n\n  const riskScores = {\n    Low: 1,\n    Medium: 2,\n    High: 3,\n  };\n\n  let weightedScore = 0;\n  for (const [factor, risk] of Object.entries(riskFactors)) {\n    const weight = weights[factor as keyof typeof weights] || 0.1;\n    const score = riskScores[risk as keyof typeof riskScores] || 2;\n    weightedScore += weight * score;\n  }\n\n  // Adjust thresholds based on user risk tolerance\n  if (params.riskTolerance === \"conservative\") {\n    if (weightedScore <= 1.3) return \"Low\";\n    if (weightedScore <= 2.0) return \"Medium\";\n    return \"High\";\n  } else if (params.riskTolerance === \"aggressive\") {\n    if (weightedScore <= 1.8) return \"Low\";\n    if (weightedScore <= 2.7) return \"Medium\";\n    return \"High\";\n  } else {\n    if (weightedScore <= 1.5) return \"Low\";\n    if (weightedScore <= 2.5) return \"Medium\";\n    return \"High\";\n  }\n}\n\nfunction calculateRiskDistributionLLM(\n  protocols: RiskProtocolData[],\n  params: any,\n): { Low: number; Medium: number; High: number } {\n  const distribution = { Low: 0, Medium: 0, High: 0 };\n\n  protocols.forEach((protocol) => {\n    const risk = assessGeneralRiskLLM(protocol.protocolInfo, params);\n    distribution[risk as keyof typeof distribution]++;\n  });\n\n  return distribution;\n}\n\nfunction extractProtocolsFromQueryLegacy(query: string): string[] {\n  const protocols: string[] = [];\n  const lowerQuery = query.toLowerCase();\n\n  const protocolKeywords = {\n    aave: \"Aave\",\n    uniswap: \"Uniswap\",\n    compound: \"Compound\",\n    sushiswap: \"SushiSwap\",\n    curve: \"Curve\",\n    pancakeswap: \"PancakeSwap\",\n    balancer: \"Balancer\",\n    maker: \"MakerDAO\",\n    \"1inch\": \"1inch\",\n    synthetix: \"Synthetix\",\n    yearn: \"Yearn Finance\",\n    convex: \"Convex Finance\",\n    lido: \"Lido\",\n    frax: \"Frax\",\n    gmx: \"GMX\",\n    dydx: \"dYdX\",\n  };\n\n  for (const [keyword, protocol] of Object.entries(protocolKeywords)) {\n    if (lowerQuery.includes(keyword)) {\n      protocols.push(protocol);\n    }\n  }\n\n  return protocols;\n}\n\nfunction extractRiskCategoriesFromQueryLegacy(query: string): string[] {\n  const categories: string[] = [];\n  const lowerQuery = query.toLowerCase();\n\n  const riskCategoryKeywords = {\n    smart_contract: [\n      \"smart contract\",\n      \"contract risk\",\n      \"code risk\",\n      \"bug\",\n      \"exploit\",\n    ],\n    liquidity: [\"liquidity\", \"liquidity risk\", \"slippage\", \"depth\"],\n    market: [\"market risk\", \"price risk\", \"volatility\", \"correlation\"],\n    governance: [\"governance\", \"governance risk\", \"centralization\", \"admin\"],\n    regulatory: [\"regulatory\", \"compliance\", \"legal\", \"regulation\"],\n    operational: [\"operational\", \"team risk\", \"founder\", \"development\"],\n    technical: [\"technical\", \"infrastructure\", \"oracle\", \"bridge\"],\n  };\n\n  for (const [category, keywords] of Object.entries(riskCategoryKeywords)) {\n    if (keywords.some((keyword) => lowerQuery.includes(keyword))) {\n      categories.push(category);\n    }\n  }\n\n  // If no specific categories found, default to common ones\n  if (categories.length === 0) {\n    categories.push(\"smart_contract\", \"liquidity\", \"market\");\n  }\n\n  return categories;\n}\n","/**\n * Stablecoin Data Action\n *\n * Direct stablecoin data fetcher that retrieves stablecoin information\n * from DeFiLlama's API. Returns structured data for LLM processing.\n *\n * Features:\n * - Stablecoin name/symbol resolution from natural language queries using LLM\n * - Current stablecoin metrics (market cap, circulation, peg stability)\n * - Multi-stablecoin batch data retrieval\n * - Smart stablecoin validation using LLM extraction and fallback patterns\n * - Clean data structuring for LLM response generation\n *\n * Process:\n * 1. Extract stablecoins from user query using LLM\n * 2. Fetch stablecoin data from DeFiLlama\n * 3. Return structured data for LLM to process\n */\nimport {\n  Action,\n  ActionResult,\n  HandlerCallback,\n  IAgentRuntime,\n  logger,\n  Memory,\n  ModelType,\n  State,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\n// Simple type for stablecoin data\ninterface StablecoinData {\n  id: string;\n  name: string;\n  symbol: string;\n  pegType: string;\n  pegMechanism: string;\n  circulating: number;\n  chains: string[];\n  price?: number;\n  formatted: string;\n}\n\nconst extractStablecoinTemplate = `Extract stablecoin analysis parameters from the user's request for stablecoin data and analysis.\n\nUser request: \"{{userMessage}}\"\n\nIMPORTANT: Follow DeFiLlama API specification exactly:\n- /stablecoins endpoint returns data with {peggedAssets: []} structure\n- Chain names in proper case: \"Ethereum\", \"Tron\", \"BSC\", \"Polygon\", \"Arbitrum\", \"Avalanche\"\n- Stablecoin names/symbols as returned by API: \"Tether\"/\"USDT\", \"USD Coin\"/\"USDC\", \"Dai\"/\"DAI\", etc.\n- pegMechanism values: \"fiat-backed\", \"crypto-backed\", \"algorithmic\"\n\nThe user might express stablecoin requests in various ways:\n- \"USDC market cap\" → stablecoins: [\"USDC\"], metrics: [\"circulation\", \"market_cap\"]\n- \"Compare USDT vs USDC stability\" → stablecoins: [\"USDT\", \"USDC\"], analysis: \"comparison\", metrics: [\"peg_stability\"]\n- \"Algorithmic stablecoins\" → pegMechanism: \"algorithmic\"\n- \"Stablecoins on Ethereum\" → chains: [\"Ethereum\"]\n- \"DAI depeg risk analysis\" → stablecoins: [\"DAI\"], metrics: [\"depeg_risk\", \"peg_stability\"]\n- \"Top 5 stablecoins by market cap\" → count: 5, sortBy: \"circulation\"\n- \"Fiat-backed stablecoins\" → pegMechanism: \"fiat-backed\"\n\nExtract and return ONLY a JSON object following DeFiLlama API format:\n{\n  \"stablecoins\": [\"Stablecoin symbols if mentioned: USDT/USDC/DAI/FRAX/BUSD/TUSD\"],\n  \"chains\": [\"Chain names as per /stablecoins endpoint: Ethereum/Tron/BSC/Polygon/Arbitrum\"],\n  \"pegMechanism\": [\"fiat-backed/crypto-backed/algorithmic if mentioned\"],\n  \"metrics\": [\"circulation/market_cap/peg_stability/depeg_risk/price if requested\"],\n  \"analysisType\": \"overview/comparison/ranking/stability_analysis/risk_assessment\",\n  \"sortBy\": \"circulation/price/name (how to sort results)\",\n  \"count\": number (how many results, default 10),\n  \"includePrices\": true/false (if user wants current prices),\n  \"timeframe\": \"current/historical if mentioned\"\n}\n\nReturn only the JSON object, no other text.`;\n\nexport const stablecoinAction: Action = {\n  name: \"STABLECOIN_ANALYSIS\",\n  similes: [\n    \"STABLECOIN_DATA\",\n    \"STABLE_ANALYSIS\",\n    \"USDC_ANALYSIS\",\n    \"TETHER_ANALYSIS\",\n    \"STABLECOIN_MARKET\",\n    \"PEG_ANALYSIS\",\n    \"DEPEG_RISK\",\n    \"STABLECOIN_YIELD\",\n    \"PEG_STABILITY\",\n    \"STABLECOIN_SAFETY\",\n    \"STABLE_COMPARISON\",\n    \"STABLECOIN_BACKING\",\n  ],\n  description: `Simple stablecoin data fetcher. This action:\n1. Extracts stablecoin names/symbols from user queries using LLM\n2. Fetches current stablecoin data from DeFiLlama API\n3. Returns clean, structured stablecoin data for analysis or display\n4. Supports multiple stablecoins and basic stablecoin information\n\nUSE WHEN: User asks about stablecoin stability, market cap, circulation, or peg analysis.\nRETURNS: Raw stablecoin data without extensive analysis - focused on data retrieval.`,\n\n  validate: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state: State | undefined,\n  ): Promise<boolean> => {\n    const text = message.content.text?.toLowerCase() || \"\";\n\n    const keywords = [\n      \"stablecoin\",\n      \"stable coin\",\n      \"usdc\",\n      \"usdt\",\n      \"tether\",\n      \"dai\",\n      \"frax\",\n      \"busd\",\n      \"peg\",\n      \"depeg\",\n      \"circulation\",\n      \"market cap\",\n      \"stablecoin dominance\",\n      \"stable market\",\n    ];\n\n    return keywords.some((keyword) => text.includes(keyword));\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<ActionResult> => {\n    try {\n      logger.info(\"[STABLECOIN_ANALYSIS] Starting stablecoin data fetch\");\n\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n      if (!defiLlamaService) {\n        throw new Error(\"DeFiLlama service not available\");\n      }\n\n      const userQuestion = message.content.text || \"\";\n\n      // Extract stablecoin criteria using LLM first, with fallback to regex\n      let extractedParams: any;\n\n      // Check if we have explicit params in options\n      if (options?.stablecoinParams) {\n        extractedParams = options.stablecoinParams;\n      } else {\n        // Use LLM to extract stablecoin criteria\n        const prompt = extractStablecoinTemplate.replace(\n          \"{{userMessage}}\",\n          userQuestion,\n        );\n\n        const response = await runtime.useModel(ModelType.TEXT_LARGE, {\n          prompt: prompt,\n        });\n\n        if (response) {\n          try {\n            // Strip markdown code blocks if present\n            const cleanedResponse = response\n              .replace(/^```(?:json)?\\n?/, \"\")\n              .replace(/\\n?```$/, \"\")\n              .trim();\n            const parsed = JSON.parse(cleanedResponse);\n\n            extractedParams = {\n              stablecoins: parsed.stablecoins || [],\n              chains: parsed.chains || [],\n              pegMechanism: parsed.pegMechanism || [],\n              metrics: parsed.metrics || [],\n              analysisType: parsed.analysisType || \"overview\",\n              sortBy: parsed.sortBy || \"circulation\",\n              count: parsed.count || 10,\n              includePrices: parsed.includePrices || false,\n              timeframe: parsed.timeframe || \"current\",\n            };\n\n            logger.info(\n              `[STABLECOIN_ANALYSIS] LLM extracted params: ${JSON.stringify(extractedParams)}`,\n            );\n          } catch (parseError) {\n            logger.warn(\n              \"Failed to parse LLM response, falling back to regex:\",\n              parseError,\n            );\n            // Fallback to regex-based extraction\n            extractedParams = {\n              stablecoins: extractStablecoinsFromQueryLegacy(userQuestion),\n              chains: [],\n              pegMechanism: [],\n              metrics: [],\n              analysisType: \"overview\",\n              sortBy: \"circulation\",\n              count: 10,\n              includePrices: false,\n              timeframe: \"current\",\n            };\n          }\n        } else {\n          logger.warn(\n            \"[STABLECOIN_ANALYSIS] No LLM response received, falling back to regex\",\n          );\n          // Fallback to regex-based extraction\n          extractedParams = {\n            stablecoins: extractStablecoinsFromQueryLegacy(userQuestion),\n            chains: [],\n            pegMechanism: [],\n            metrics: [],\n            analysisType: \"overview\",\n            sortBy: \"circulation\",\n            count: 10,\n            includePrices: false,\n            timeframe: \"current\",\n          };\n        }\n      }\n\n      logger.info(\n        `[STABLECOIN_ANALYSIS] Fetching data for stablecoins: ${extractedParams.stablecoins.join(\", \") || \"all\"}`,\n      );\n\n      // Fetch stablecoin data\n      const [stablecoins, stablecoinChains] = await Promise.all([\n        defiLlamaService.getStablecoins({\n          includePrices: extractedParams.includePrices || false,\n        }),\n        defiLlamaService.getStablecoinChains(),\n      ]);\n\n      // Validate API responses\n      const validatedStablecoins = Array.isArray(stablecoins)\n        ? stablecoins\n        : [];\n\n      if (validatedStablecoins.length === 0) {\n        throw new Error(\"No stablecoin data available from API\");\n      }\n\n      // Filter and structure stablecoin data\n      const stablecoinData = buildStablecoinDataLLM(\n        extractedParams,\n        validatedStablecoins,\n        stablecoinChains,\n      );\n\n      // Generate response using LLM\n      const response = await runtime.useModel(ModelType.LARGE, {\n        prompt: `Respond concisely with stablecoin analysis based on data: ${JSON.stringify(stablecoinData)}\n        and user query: ${JSON.stringify(message.content)}`,\n      });\n\n      if (callback) {\n        await callback({\n          text: response || \"Unable to analyze stablecoin data at this time.\",\n          actions: ['STABLECOIN_ANALYSIS'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: response,\n        success: true,\n        data: {\n          actionName: \"STABLECOIN_ANALYSIS\",\n          extractedParams,\n          stablecoinData,\n          stablecoinDataFetched: true,\n          stablecoinsFound: stablecoinData.stablecoins.length,\n          timestamp: Date.now(),\n        },\n      };\n    } catch (error) {\n      logger.error(\"[STABLECOIN_ANALYSIS] Error:\", error);\n\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n\n      if (callback) {\n        await callback({\n          text: `❌ Failed to fetch stablecoin data: ${errorMessage}`,\n          actions: [\"STABLECOIN_ANALYSIS\"],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        text: `Error fetching stablecoin data: ${errorMessage}`,\n        success: false,\n        error: error instanceof Error ? error : new Error(errorMessage),\n        data: {\n          actionName: \"STABLECOIN_ANALYSIS\",\n          error: errorMessage,\n          stablecoinDataFetched: false,\n          timestamp: Date.now(),\n        },\n      };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"What's USDC's current market cap and circulation?\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"USDC currently has $28.1B in circulation across 15 chains, maintaining its $1.00 peg with 99.8% stability. It's the 2nd largest stablecoin by market cap.\",\n          actions: [\"STABLECOIN_ANALYSIS\"],\n        },\n      },\n    ],\n    [\n      {\n        name: \"{{user}}\",\n        content: {\n          text: \"Compare USDT vs USDC vs DAI stability\",\n        },\n      },\n      {\n        name: \"{{agent}}\",\n        content: {\n          text: \"USDT: $118B circulation, fiat-backed, 99.9% peg stability. USDC: $28B circulation, fiat-backed, 99.8% stability. DAI: $4.8B circulation, crypto-backed, 99.7% stability. All maintain strong pegs.\",\n          actions: [\"STABLECOIN_ANALYSIS\"],\n        },\n      },\n    ],\n  ],\n};\n\n// Helper functions for stablecoin data extraction and formatting\n\nfunction buildStablecoinDataLLM(\n  params: any,\n  allStablecoins: any[],\n  chainData: any,\n): any {\n  const data: any = {\n    stablecoins: [],\n    totalCirculation: 0,\n    chainBreakdown: {},\n    timestamp: Date.now(),\n  };\n\n  let relevantStablecoins = allStablecoins;\n\n  // Filter by specific stablecoins if mentioned\n  if (params.stablecoins && params.stablecoins.length > 0) {\n    relevantStablecoins = allStablecoins.filter((s) =>\n      params.stablecoins.some((target: string) => {\n        const targetLower = target.toLowerCase();\n        const nameLower = s.name?.toLowerCase() || \"\";\n        const symbolLower = s.symbol?.toLowerCase() || \"\";\n        return (\n          nameLower.includes(targetLower) ||\n          symbolLower.includes(targetLower) ||\n          targetLower.includes(nameLower) ||\n          targetLower.includes(symbolLower)\n        );\n      }),\n    );\n  }\n\n  // Filter by chains if specified (case-insensitive)\n  if (params.chains && params.chains.length > 0) {\n    relevantStablecoins = relevantStablecoins.filter(\n      (s) =>\n        s.chains &&\n        params.chains.some((chain: string) =>\n          s.chains.some((sChain: string) =>\n            sChain.toLowerCase().includes(chain.toLowerCase()),\n          ),\n        ),\n    );\n  }\n\n  // Filter by peg mechanism if specified\n  if (params.pegMechanism && params.pegMechanism.length > 0) {\n    relevantStablecoins = relevantStablecoins.filter((s) =>\n      params.pegMechanism.some((mechanism: string) =>\n        s.pegMechanism?.toLowerCase().includes(mechanism.toLowerCase()),\n      ),\n    );\n  }\n\n  // Sort based on criteria\n  const sortBy = params.sortBy || \"circulation\";\n  if (sortBy === \"circulation\") {\n    relevantStablecoins = relevantStablecoins.sort((a, b) => {\n      const aCirc = a.circulating?.peggedUSD || 0;\n      const bCirc = b.circulating?.peggedUSD || 0;\n      return bCirc - aCirc;\n    });\n  } else if (sortBy === \"price\") {\n    relevantStablecoins = relevantStablecoins.sort((a, b) => {\n      const aPrice = Math.abs((a.price || 1) - 1);\n      const bPrice = Math.abs((b.price || 1) - 1);\n      return aPrice - bPrice; // Sort by closest to $1\n    });\n  } else if (sortBy === \"name\") {\n    relevantStablecoins = relevantStablecoins.sort((a, b) =>\n      (a.name || \"\").localeCompare(b.name || \"\"),\n    );\n  }\n\n  // Take top results based on count\n  relevantStablecoins = relevantStablecoins.slice(0, params.count || 10);\n\n  // Build stablecoin data\n  relevantStablecoins.forEach((stablecoin) => {\n    const circulation = stablecoin.circulating?.peggedUSD || 0;\n\n    data.stablecoins.push({\n      id: stablecoin.id,\n      name: stablecoin.name || \"Unknown\",\n      symbol: stablecoin.symbol || \"Unknown\",\n      pegType: stablecoin.pegType || \"Unknown\",\n      pegMechanism: stablecoin.pegMechanism || \"Unknown\",\n      circulating: circulation,\n      chains: stablecoin.chains || [],\n      price: stablecoin.price || 1.0,\n      formatted: formatStablecoinData(stablecoin),\n    });\n\n    data.totalCirculation += circulation;\n  });\n\n  // Build chain breakdown from chain data if available\n  if (chainData && Array.isArray(chainData)) {\n    data.chainBreakdown = chainData.reduce((acc: any, chain: any) => {\n      if (chain.name && chain.totalCirculating?.peggedUSD) {\n        acc[chain.name] = chain.totalCirculating.peggedUSD;\n      }\n      return acc;\n    }, {});\n  }\n\n  return data;\n}\n\nfunction extractStablecoinsFromQueryLegacy(query: string): string[] {\n  const stablecoinKeywords = {\n    usdt: \"tether\",\n    tether: \"tether\",\n    usdc: \"usd-coin\",\n    \"usd coin\": \"usd-coin\",\n    dai: \"dai\",\n    frax: \"frax\",\n    busd: \"binance-usd\",\n    \"binance usd\": \"binance-usd\",\n    tusd: \"trueusd\",\n    \"true usd\": \"trueusd\",\n    usdp: \"paxos-standard\",\n    \"pax dollar\": \"paxos-standard\",\n    gusd: \"gemini-dollar\",\n    \"gemini dollar\": \"gemini-dollar\",\n    usdd: \"usdd\",\n    lusd: \"liquity-usd\",\n    \"liquity usd\": \"liquity-usd\",\n    ustc: \"terrausd\",\n    \"terra usd\": \"terrausd\",\n    mimatic: \"mimatic\",\n    \"mai finance\": \"mimatic\",\n    fei: \"fei-usd\",\n    \"fei usd\": \"fei-usd\",\n    ust: \"terrausd-wormhole\",\n  };\n\n  const found: string[] = [];\n  const searchText = query.toLowerCase();\n\n  for (const [keyword, stablecoinId] of Object.entries(stablecoinKeywords)) {\n    if (searchText.includes(keyword)) {\n      found.push(stablecoinId);\n    }\n  }\n\n  return [...new Set(found)]; // Remove duplicates\n}\n\nfunction formatStablecoinData(stablecoin: any): string {\n  const circulation = formatLargeNumber(stablecoin.circulating?.peggedUSD || 0);\n  const price = stablecoin.price?.toFixed(4) || \"1.0000\";\n  return `${stablecoin.name}: $${circulation} circulation, $${price} price`;\n}\n\nfunction formatLargeNumber(num: number): string {\n  if (num >= 1e12) return (num / 1e12).toFixed(1) + \"T\";\n  if (num >= 1e9) return (num / 1e9).toFixed(1) + \"B\";\n  if (num >= 1e6) return (num / 1e6).toFixed(1) + \"M\";\n  if (num >= 1e3) return (num / 1e3).toFixed(1) + \"K\";\n  return num.toFixed(0);\n}\n","import {\n  Provider,\n  IAgentRuntime,\n  Memory,\n  State,\n  ProviderResult,\n  logger,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\nexport const marketDataProvider: Provider = {\n  name: \"MARKET_DATA_PROVIDER\",\n  description:\n    \"Provides overall DeFi market context including total TVL, trends, and sector performance\",\n  dynamic: true,\n  get: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state?: State,\n  ): Promise<ProviderResult> => {\n    try {\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n\n      if (!defiLlamaService) {\n        return {\n          text: \"\",\n          values: {},\n          data: {},\n        };\n      }\n\n      // Get comprehensive market data\n      const [protocols, chains, tvlData] = await Promise.all([\n        defiLlamaService.getProtocols(),\n        defiLlamaService.getChains(),\n        defiLlamaService.getTVL(),\n      ]);\n\n      // Process data for context\n      const topProtocols = (protocols as any[])\n        .sort((a, b) => (b.tvl || 0) - (a.tvl || 0))\n        .slice(0, 10);\n\n      const topChains = (chains as any[])\n        .sort((a, b) => (b.tvl || 0) - (a.tvl || 0))\n        .slice(0, 8);\n\n      // Calculate sector distribution\n      const sectors: Record<string, { tvl: number; count: number }> = {};\n      for (const protocol of protocols as any[]) {\n        const category = protocol.category || \"Other\";\n        if (!sectors[category]) {\n          sectors[category] = { tvl: 0, count: 0 };\n        }\n        sectors[category].tvl += protocol.tvl || 0;\n        sectors[category].count++;\n      }\n\n      const topSectors = Object.entries(sectors)\n        .sort(([, a], [, b]) => b.tvl - a.tvl)\n        .slice(0, 6);\n\n      const totalTvl = tvlData.totalLiquidityUSD || 0;\n\n      const contextText = `DeFi Market Context:\n\nTotal DeFi TVL: $${formatNumber(totalTvl)}\nActive Protocols: ${protocols.length}\nSupported Chains: ${chains.length}\n\nTop 5 Protocols by TVL:\n${topProtocols.map((p, i) => `${i + 1}. ${p.name}: $${formatNumber(p.tvl || 0)}`).join(\"\\n\")}\n\nTop 5 Chains by TVL:\n${topChains.map((c, i) => `${i + 1}. ${c.name}: $${formatNumber(c.tvl || 0)}`).join(\"\\n\")}\n\nTop Sectors by TVL:\n${topSectors.map(([sector, data], i) => `${i + 1}. ${sector}: $${formatNumber(data.tvl)} (${data.count} protocols)`).join(\"\\n\")}\n\nMarket Health: ${getMarketHealth(protocols)}\nRecent Activity: Active trading and liquidity flows across chains`;\n\n      return {\n        text: contextText,\n        values: {\n          totalTvl,\n          protocolCount: protocols.length,\n          chainCount: chains.length,\n          topProtocols: topProtocols.slice(0, 5),\n          topChains: topChains.slice(0, 5),\n          topSectors: topSectors.slice(0, 3),\n        },\n        data: {\n          protocols: topProtocols,\n          chains: topChains,\n          sectors: topSectors,\n          marketHealth: getMarketHealth(protocols),\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error in market data provider:\", error);\n      return {\n        text: \"\",\n        values: {},\n        data: {},\n      };\n    }\n  },\n};\n\nfunction formatNumber(num: number | undefined | null): string {\n  if (num === undefined || num === null || isNaN(num)) return \"N/A\";\n  if (num >= 1e9) return (num / 1e9).toFixed(1) + \"B\";\n  if (num >= 1e6) return (num / 1e6).toFixed(1) + \"M\";\n  if (num >= 1e3) return (num / 1e3).toFixed(1) + \"K\";\n  return num.toFixed(0);\n}\n\nfunction getMarketHealth(protocols: any[]): string {\n  if (protocols.length < 50) return \"Limited\";\n  if (protocols.length < 200) return \"Developing\";\n  if (protocols.length < 500) return \"Healthy\";\n  return \"Mature\";\n}\n","import {\n  Provider,\n  IAgentRuntime,\n  Memory,\n  State,\n  ProviderResult,\n  logger,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\nexport const stablecoinContextProvider: Provider = {\n  name: \"STABLECOIN_CONTEXT_PROVIDER\",\n  description:\n    \"Provides stablecoin market context including market cap, dominance, and risk assessment\",\n  dynamic: true,\n  get: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state?: State,\n  ): Promise<ProviderResult> => {\n    try {\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n\n      if (!defiLlamaService) {\n        return {\n          text: \"\",\n          values: {},\n          data: {},\n        };\n      }\n\n      // Get stablecoin market data\n      const stablecoins = await defiLlamaService.getStablecoins();\n\n      if (!stablecoins || stablecoins.length === 0) {\n        return {\n          text: \"\",\n          values: {},\n          data: {},\n        };\n      }\n\n      // Process stablecoin data\n      const processedStables = stablecoins.map((coin: any) => {\n        const current = Object.values(coin.circulating || {}).reduce(\n          (total: number, value: any) =>\n            total + (typeof value === \"number\" ? value : 0),\n          0,\n        );\n        const prevDay = Object.values(coin.circulatingPrevDay || {}).reduce(\n          (total: number, value: any) =>\n            total + (typeof value === \"number\" ? value : 0),\n          0,\n        );\n        const change24h =\n          prevDay > 0 ? ((current - prevDay) / prevDay) * 100 : 0;\n\n        return {\n          symbol: coin.symbol,\n          name: coin.name,\n          mcap: current,\n          change24h,\n          pegType: coin.pegType || \"USD\",\n          mechanism: coin.pegMechanism || \"Collateralized\",\n        };\n      });\n\n      const topStables = processedStables\n        .sort((a, b) => b.mcap - a.mcap)\n        .slice(0, 6);\n\n      const totalStableMarket = topStables.reduce((sum, s) => sum + s.mcap, 0);\n\n      // Calculate dominance and health metrics\n      const usdtDominance =\n        topStables.find((s) => s.symbol === \"USDT\")?.mcap || 0;\n      const usdcShare = topStables.find((s) => s.symbol === \"USDC\")?.mcap || 0;\n      const dominanceRatio =\n        ((usdtDominance + usdcShare) / totalStableMarket) * 100;\n\n      const contextText = `Stablecoin Market Context:\n\nTotal Market Cap: $${formatNumber(totalStableMarket)}\nMarket Concentration: ${dominanceRatio.toFixed(1)}% (USDT+USDC)\n\nTop Stablecoins:\n${topStables\n  .map((s, i) => {\n    const share = ((s.mcap / totalStableMarket) * 100).toFixed(1);\n    const change = s.change24h ? formatChange(s.change24h) : \"N/A\";\n    return `${i + 1}. ${s.symbol}: $${formatNumber(s.mcap)} (${share}%) ${change}`;\n  })\n  .join(\"\\n\")}\n\nMarket Health: ${getStableMarketHealth(dominanceRatio, topStables.length)}\nPeg Mechanisms: Diverse (Collateralized, Algorithmic, Hybrid)\nRisk Assessment: ${getRiskAssessment(dominanceRatio)}`;\n\n      return {\n        text: contextText,\n        values: {\n          totalMarketCap: totalStableMarket,\n          dominanceRatio,\n          topStablecoins: topStables,\n        },\n        data: {\n          stablecoins: processedStables,\n          marketHealth: getStableMarketHealth(\n            dominanceRatio,\n            topStables.length,\n          ),\n          riskAssessment: getRiskAssessment(dominanceRatio),\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error in stablecoin context provider:\", error);\n      return {\n        text: \"\",\n        values: {},\n        data: {},\n      };\n    }\n  },\n};\n\nfunction formatNumber(num: number): string {\n  if (num >= 1e9) return (num / 1e9).toFixed(1) + \"B\";\n  if (num >= 1e6) return (num / 1e6).toFixed(1) + \"M\";\n  if (num >= 1e3) return (num / 1e3).toFixed(1) + \"K\";\n  return num.toFixed(0);\n}\n\nfunction formatChange(change: number): string {\n  const sign = change >= 0 ? \"+\" : \"\";\n  return `(${sign}${change.toFixed(2)}%)`;\n}\n\nfunction getStableMarketHealth(\n  dominance: number,\n  totalStables: number,\n): string {\n  if (dominance > 95) return \"Highly Concentrated\";\n  if (dominance > 85) return \"Moderately Concentrated\";\n  if (dominance > 75) return \"Balanced\";\n  return \"Decentralized\";\n}\n\nfunction getRiskAssessment(dominance: number): string {\n  if (dominance > 90) return \"High concentration risk\";\n  if (dominance > 80) return \"Moderate concentration risk\";\n  return \"Well-distributed risk\";\n}\n","import {\n  Provider,\n  IAgentRuntime,\n  Memory,\n  State,\n  ProviderResult,\n  logger,\n} from \"@elizaos/core\";\nimport { DefiLlamaService } from \"../services/defiLlamaService\";\n\nexport const protocolSlugsProvider: Provider = {\n  name: \"PROTOCOL_SLUGS_PROVIDER\",\n  description:\n    \"Provides protocol slug mappings and name resolution to help agents find the correct protocol identifiers for DeFiLlama API calls\",\n  dynamic: true,\n  get: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    _state?: State,\n  ): Promise<ProviderResult> => {\n    try {\n      const defiLlamaService = runtime.getService(\n        \"defillama\",\n      ) as DefiLlamaService;\n\n      if (!defiLlamaService) {\n        return {\n          text: \"\",\n          values: {},\n          data: {},\n        };\n      }\n\n      // Get all protocols and create lookup mappings\n      const protocols = await defiLlamaService.getProtocols();\n\n      // Create name to slug mappings\n      const nameToSlug: Record<string, string> = {};\n      const slugToName: Record<string, string> = {};\n      const aliasToSlug: Record<string, string> = {};\n\n      for (const protocol of protocols as any[]) {\n        const slug = protocol.slug;\n        const name = protocol.name.toLowerCase();\n\n        nameToSlug[name] = slug;\n        slugToName[slug] = protocol.name;\n\n        // Add common aliases and variations\n        aliasToSlug[name.replace(/\\s+/g, \"\")] = slug; // Remove spaces\n        aliasToSlug[name.replace(/\\s+/g, \"-\")] = slug; // Replace spaces with dashes\n\n        // Handle specific known rebrands and aliases\n        if (name.includes(\"maker\") || name.includes(\"makerdao\")) {\n          aliasToSlug[\"makerdao\"] = slug;\n          aliasToSlug[\"maker\"] = slug;\n        }\n\n        if (name.includes(\"sky\") && name.includes(\"lending\")) {\n          aliasToSlug[\"makerdao\"] = slug;\n          aliasToSlug[\"maker\"] = slug;\n        }\n\n        // Handle other common variations\n        const words = name.split(\" \");\n        if (words.length > 1) {\n          aliasToSlug[words[0]] = slug; // First word only\n          aliasToSlug[words.join(\"\")] = slug; // All words concatenated\n        }\n      }\n\n      // Get top protocols for context\n      const topProtocols = (protocols as any[])\n        .sort((a, b) => (b.tvl || 0) - (a.tvl || 0))\n        .slice(0, 20)\n        .map((p) => `${p.name} (${p.slug})`);\n\n      // Parse message to find potential protocol references\n      const messageText = message.content.text?.toLowerCase() || \"\";\n      const foundProtocols: Array<{\n        name: string;\n        slug: string;\n        confidence: string;\n      }> = [];\n\n      // Check for exact matches first\n      for (const [alias, slug] of Object.entries(aliasToSlug)) {\n        if (messageText.includes(alias)) {\n          const protocolName = slugToName[slug];\n          foundProtocols.push({\n            name: protocolName,\n            slug: slug,\n            confidence: messageText === alias ? \"exact\" : \"high\",\n          });\n        }\n      }\n\n      // Remove duplicates and sort by confidence\n      const uniqueProtocols = foundProtocols\n        .filter((p, i, arr) => arr.findIndex((x) => x.slug === p.slug) === i)\n        .sort((a, b) => {\n          const order = { exact: 0, high: 1, medium: 2, low: 3 };\n          return (\n            (order[a.confidence as keyof typeof order] || 9) -\n            (order[b.confidence as keyof typeof order] || 9)\n          );\n        })\n        .slice(0, 5); // Limit to top 5 matches\n\n      const contextText =\n        uniqueProtocols.length > 0\n          ? `Protocol Matches Found:\n${uniqueProtocols.map((p) => `- ${p.name} → ${p.slug} (${p.confidence} match)`).join(\"\\n\")}\n\nUse these exact slugs for API calls.`\n          : `No specific protocols detected in message.\n\nTop 20 Available Protocols:\n${topProtocols.slice(0, 10).join(\", \")}\n${topProtocols.slice(10).join(\", \")}\n\nTotal available protocols: ${protocols.length}\n\nFor protocol lookups, use exact protocol slugs. Common rebrands:\n- MakerDAO → Sky Lending (slug varies - check current data)`;\n\n      return {\n        text: contextText,\n        values: {\n          availableProtocols: protocols.length,\n          foundProtocols: uniqueProtocols,\n          topProtocols: topProtocols.slice(0, 10),\n          nameToSlug: Object.keys(nameToSlug).slice(0, 50), // Limit for performance\n          hasMatches: uniqueProtocols.length > 0,\n        },\n        data: {\n          nameToSlug,\n          slugToName,\n          aliasToSlug,\n          foundProtocols: uniqueProtocols,\n          topProtocols,\n          allProtocols: protocols,\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error in protocol slugs provider:\", error);\n      return {\n        text: \"Unable to load protocol mappings at this time.\",\n        values: {},\n        data: {},\n      };\n    }\n  },\n};\n"],"mappings":"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","names":["logger","logger","response","logger","ModelType","response","logger","ModelType","response","item","timeframe","formatLargeNumber","logger","ModelType","logger","response","ModelType","logger","ModelType","logger","response","ModelType","logger","ModelType","logger","response","ModelType","chainFilter","extractProtocolsFromQueryLegacy","logger","ModelType","response","logger","ModelType","logger","response","ModelType","logger","ModelType","logger","response","ModelType","extractProtocolsFromQueryLegacy","assessProtocolRiskLLM","logger","ModelType","response","formatLargeNumber","logger","logger","formatNumber","formatChange","logger","logger"]}