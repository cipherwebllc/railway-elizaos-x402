import { Service, IAgentRuntime, Plugin } from '@elizaos/core';

/**
 * DeFiLlama Plugin Type Definitions
 *
 * These interfaces define the data structures used throughout the plugin
 * for interacting with DeFiLlama API and managing DeFi data.
 */
interface Protocol {
    id: string;
    name: string;
    address: string;
    symbol: string;
    url: string;
    description: string;
    chain: string;
    logo: string;
    audits: string;
    audit_note: string;
    gecko_id: string;
    cmcId: string;
    category: string;
    chains: string[];
    module: string;
    twitter: string;
    forkedFrom: string[];
    oracles: string[];
    listedAt: number;
    methodology: string;
    slug: string;
}
interface ProtocolDetails extends Protocol {
    tvl: number;
    chainTvls: Record<string, number>;
    change_1h: number;
    change_1d: number;
    change_7d: number;
    tokenBreakdowns: Record<string, number>;
    mcap: number;
    tvlPrevDay: number;
    tvlPrevWeek: number;
    tvlPrevMonth: number;
}
interface YieldPool {
    chain: string;
    project: string;
    symbol: string;
    tvlUsd: number;
    apy: number;
    apyBase: number;
    apyReward: number;
    rewardTokens: string[];
    pool: string;
    apyPct1D: number;
    apyPct7D: number;
    apyPct30D: number;
    stablecoin: boolean;
    ilRisk: string;
    exposure: string;
    predictions: {
        predictedClass: string;
        predictedProbability: number;
        binnedConfidence: number;
    };
    poolMeta?: string;
    url?: string;
    apyMean30d?: number;
    volumeUsd1d?: number;
    volumeUsd7d?: number;
    apyBaseInception?: number;
}
interface TVLData {
    date: string;
    totalLiquidityUSD: number;
}
interface Chain {
    gecko_id: string;
    tvl: number;
    tokenSymbol: string;
    cmcId: string;
    name: string;
    chainId: number;
}
interface ChainTvl {
    [chain: string]: number;
}
interface HistoricalData {
    date: number;
    totalLiquidityUSD: number;
}
interface Bridge {
    id: number;
    name: string;
    displayName: string;
    icon: string;
    volumePrevDay: number;
    volumePrev2Day: number;
    lastHourlyVolume: number;
    currentDayVolume: number;
    lastDailyVolume: number;
    dayBeforeLastVolume: number;
    weeklyVolume: number;
    monthlyVolume: number;
    chains: string[];
}
interface Stablecoin {
    id: string;
    name: string;
    symbol: string;
    gecko_id: string;
    pegType: string;
    pegMechanism: string;
    priceSource: string;
    circulating: Record<string, number>;
    circulatingPrevDay: Record<string, number>;
    circulatingPrevWeek: Record<string, number>;
    circulatingPrevMonth: Record<string, number>;
    chainCirculating: Record<string, Record<string, number>>;
    price: number;
}
interface RateLimitStatus {
    remaining: number;
    resetTime: number;
    limit: number;
}
interface APIRequest {
    endpoint: string;
    params?: Record<string, any>;
    priority: "high" | "medium" | "low";
}
interface DefiLlamaConfig {
    apiBaseUrl: string;
    rateLimitPerMinute: number;
    maxConcurrentRequests: number;
    retryAttempts: number;
    retryDelay: number;
}
interface DefiLlamaError {
    code: string;
    message: string;
    details?: any;
    suggestions?: string[];
    dataAge?: number;
    fallbackAvailable?: boolean;
}
interface YieldFilters {
    chains?: string[];
    minApy?: number;
    maxApy?: number;
    stablecoin?: boolean;
    ilRisk?: "yes" | "no" | "all";
    singleStaking?: boolean;
    minTvl?: number;
    project?: string;
    sortBy?: "apy" | "tvl" | "apyBase" | "apyReward";
    limit?: number;
}
interface ProtocolFilters {
    chains?: string[];
    category?: string;
    minTvl?: number;
    sortBy?: "tvl" | "change_1d" | "change_7d" | "mcap";
    limit?: number;
}
interface MarketTrendFilters {
    period?: "1d" | "7d" | "30d" | "90d" | "1y";
    sectors?: string[];
    chains?: string[];
    metric?: "tvl" | "volume" | "users" | "fees";
}
interface ProtocolResponse {
    protocols: ProtocolDetails[];
    totalTvl: number;
    chains: ChainTvl;
    categories: Record<string, number>;
}
interface YieldResponse {
    pools: YieldPool[];
    totalPools: number;
    avgApy: number;
    topApy: number;
}
interface TrendAnalysis {
    period: string;
    trends: {
        metric: string;
        startValue: number;
        endValue: number;
        change: number;
        changePercent: number;
        trend: "up" | "down" | "stable";
    }[];
    topGainers: ProtocolDetails[];
    topLosers: ProtocolDetails[];
    sectorPerformance: Record<string, number>;
}
interface CrossChainAnalysis {
    chains: {
        name: string;
        tvl: number;
        protocols: number;
        avgYield: number;
        topProtocol: string;
        dominance: number;
    }[];
    bridgeVolume: Record<string, number>;
    crossChainOpportunities: {
        fromChain: string;
        toChain: string;
        opportunity: string;
        potentialGain: number;
    }[];
}
interface DexVolume {
    id: string;
    name: string;
    displayName: string;
    total24h: number;
    total48hto24h?: number;
    total7d: number;
    total30d?: number;
    change_1d: number;
    change_7d: number;
    change_30d?: number;
    chains: string[];
    logo?: string;
    url?: string;
    methodology?: string;
}
interface ProtocolFees {
    id: string;
    name: string;
    displayName: string;
    logo: string;
    category: string;
    total24h: number;
    total48hto24h: number;
    total7d: number;
    totalAllTime: number;
    change_1d: number;
    revenue24h?: number;
    dailyUserFees?: number;
    dailySupplySideRevenue?: number;
    dailyProtocolRevenue?: number;
    dailyHoldersRevenue?: number;
    chains: string[];
}
interface CoinPrice {
    decimals: number;
    price: number;
    symbol: string;
    timestamp: number;
    confidence: number;
}
interface HistoricalPrice {
    timestamp: number;
    price: number;
}
interface YieldChartData {
    timestamp: number;
    tvlUsd: number;
    apy: number;
    apyBase: number;
    apyReward: number;
}
interface VolumeData {
    [timestamp: string]: number;
}
interface FeeData {
    [timestamp: string]: number;
}
interface TrendAnalysisRequirements {
    analysisScope: string;
    timeHorizon: string;
    focusAreas: string;
    trendIndicators: string;
    marketContext: string;
    riskAssessment: string;
    sentimentAnalysis: string;
    comparativeAnalysis: string;
    actionableInsights: string;
    detailLevel: string;
    analysisStrategy: string;
}
interface SectorData {
    name: string;
    tvl: number;
    change1d: number;
    change7d: number;
    protocolCount: number;
    volatility: number;
    riskScore: number;
    opportunityScore: number;
    protocols: ProtocolDetails[];
}
interface ChainPerformanceData {
    name: string;
    tvl: number;
    change7d: number;
    protocolCount: number;
    dominance: number;
    growthMomentum: number;
    ecosystemHealth: string;
    innovationScore: number;
}
interface ProtocolTrendData {
    name: string;
    tvl: number;
    change1d: number;
    change7d: number;
    marketShare: number;
    trendStrength: number;
    riskLevel: string;
    innovationScore: number;
    chains: string[];
}
interface MarketSentimentData {
    bullishness: number;
    trend: string;
    overall: string;
    score: number;
    distribution: {
        positive: number;
        negative: number;
        neutral: number;
    };
    momentumIndicators: {
        accelerating: number;
        decelerating: number;
    };
    volatilityLevel: string;
}
interface MarketCorrelationData {
    correlations: Array<{
        sector1: string;
        sector2: string;
        correlation: number;
    }>;
    highCorrelations: Array<[
        string,
        {
            sector1: string;
            sector2: string;
            correlation: number;
        }
    ]>;
    diversificationOpportunities: Array<[
        string,
        {
            sector1: string;
            sector2: string;
            correlation: number;
        }
    ]>;
}
interface ComprehensiveTrendData {
    sectors: SectorData[];
    chains: ChainPerformanceData[];
    protocols: ProtocolTrendData[];
    sentiment: MarketSentimentData;
    correlations: MarketCorrelationData;
    marketOverview: {
        totalTvl: number;
        activeProtocols: number;
        activeChains: number;
        marketCap: number;
    };
    timeframe: string;
    timestamp: number;
}
interface TrendAnalysisResults {
    trendData: ComprehensiveTrendData;
    marketInsights: string[];
    sectorRotation: string[];
    emergingOpportunities: string[];
    riskFactors: string[];
    strategicRecommendations: string[];
    marketOverview: {
        totalTvl: number;
        activeProtocols: number;
        activeChains: number;
        marketCap: number;
    };
    topTrendingSectors: SectorData[];
    chainPerformance: ChainPerformanceData[];
    protocolHighlights: ProtocolTrendData[];
    sentimentAnalysis: MarketSentimentData;
    correlationInsights: MarketCorrelationData;
    strategicInsights: string;
    actionableRecommendations: string[];
    timestamp: number;
}
interface RiskAnalysisRequirements {
    analysisScope: string;
    riskCategories: string;
    assetFocus: string;
    timeHorizon: string;
    riskTolerance: string;
    contextualFactors: string;
    assessmentDepth: string;
    comparisonBenchmarks: string;
    actionableInsights: string;
    reportFormat: string;
    urgencyLevel: string;
}
interface ProtocolRiskAssessment {
    name: string;
    riskLevel: string;
    riskScore: number;
    factors: string[];
    recommendation: string;
    tvl: number;
    category: string;
}
interface YieldRiskAnalysis {
    protocol: string;
    pool: string;
    apy: number;
    riskScore: number;
    riskFactors: string[];
    tvl: number;
    impermanentLoss: boolean;
}
interface RiskIntelligence {
    protocolAnalysis: ProtocolRiskData[];
    yieldAnalysis: YieldRiskData[];
    marketMetrics: Record<string, number>;
    riskFactors: string[];
}
interface ProtocolRiskData {
    name: string;
    tvl: number;
    category: string;
    riskAssessment: {
        level: string;
        score: number;
        factors: string[];
        recommendation: string;
    };
}
interface YieldRiskData {
    project: string;
    symbol: string;
    apy: number;
    tvlUsd: number;
    riskScore: number;
    riskFactors: string[];
    impermanentLoss: boolean;
}
interface RiskAnalysisResults {
    overallRiskScores: {
        average: number;
        level: string;
        protocolCount: number;
    };
    protocolAssessments: ProtocolRiskAssessment[];
    yieldRiskAnalysis: YieldRiskAnalysis[];
    redFlags: string[];
    mitigationStrategies: string[];
    recommendations: string[];
}
interface HistoricalAnalysisRequirements {
    analysisType: string;
    targetEntities: string;
    timescalePreference: string;
    metricsFocus: string;
    contextualFactors: string;
    comparisonBenchmarks: string;
    trendIdentification: string;
    reportingFormat: string;
    actionableInsights: string;
    detailLevel: string;
    urgencyLevel: string;
}
interface ProtocolTrends {
    trend: string;
    totalChange: number;
    avgValue: number;
    volatility: number;
    momentum: number;
    strength: string;
    timespan: number;
    supportLevel: number;
    resistanceLevel: number;
}
interface HistoricalPatterns {
    cyclical: boolean;
    seasonal: boolean;
    correlations: string[];
    anomalies: string[];
}
interface HistoricalAnalysisResults {
    protocolTrends: Record<string, ProtocolTrends>;
    marketPatterns: HistoricalPatterns;
    keyInsights: string[];
    performanceMetrics: Record<string, number>;
    marketOverview: {
        totalProtocols: number;
        totalTVL: number;
        topProtocols: ProtocolDetails[];
        chainDistribution: Chain[];
    };
}
interface PriceAnalysisRequirements {
    queryType: string;
    assets: string;
    timeFrame: string;
    granularity: string;
    comparisonContext: string;
    useCase: string;
    formatPreference: string;
    currencyBase: string;
    additionalMetrics: string;
    urgency: string;
}
interface TokenAnalysis {
    token: string;
    tokenName: string;
    symbol: string;
    decimals: number;
    confidence: number;
    currentPrice: CoinPrice;
    metrics: PriceMetrics;
    recommendations: string[];
}
interface PriceMetrics {
    volatility: number;
    trend: string;
    support: number;
    resistance: number;
    volume: number;
}
interface PriceDataResponse {
    current: Record<string, CoinPrice>;
    historical: Record<string, {
        prices: HistoricalPrice[];
    }>;
}
interface FeesVolumeRequirements {
    analysisType: string;
    assetFocus: string;
    chainFocus: string[];
    chains: string;
    timePeriod: string;
    timeFrame: string;
    optimizationGoal: string;
    efficiencyMetrics: string;
    protocolPreference: string;
    marketContext: string;
    comparisonScope: string;
    useCase: string;
    volumeThreshold: number;
    feeThreshold: number;
    comparisonMetric: string;
    usageContext: string;
    protocolInterest: string;
}
interface ProcessedProtocolFee {
    name: string;
    daily_fees: number;
    daily_revenue: number;
    change_1d: number;
    category: string;
    chains: string[];
    efficiency: FeeEfficiency;
    sustainability: FeeSustainability;
}
interface ProcessedDexVolume {
    name: string;
    volume_24h: number;
    change_1d: number;
    chains: string[];
    estimated_fees: number;
    market_share: number;
    liquidity_efficiency: LiquidityEfficiency;
}
interface FeeEfficiency {
    fee_to_tvl_ratio: number;
    revenue_capture_rate: number;
    efficiency_score: number;
}
interface FeeSustainability {
    level: string;
    factors: string[];
}
interface LiquidityEfficiency {
    level: string;
    score: number;
    volatility: string;
}
interface EfficiencyMetric {
    protocol: string;
    efficiency_score: number;
    fee_rate: number;
    volume_efficiency: number;
}
interface ChainAnalysisData {
    total_fees: number;
    total_volume: number;
    fee_rate?: number;
    protocol_count: number;
}
interface ProcessedFeesVolumeData {
    protocolFees: ProcessedProtocolFee[];
    dexVolumes: ProcessedDexVolume[];
    efficiencyMetrics: EfficiencyMetric[];
    chainAnalysis: Record<string, ChainAnalysisData>;
    totalDataPoints: number;
    metadata: {
        analysisType: string;
        timeFrame: string;
        focusedChains: string;
    };
}
interface StablecoinAnalysisRequirements {
    analysisType: string;
    stablecoinFocus: string;
    pegStabilityFocus: string;
    chainAnalysis: string;
    timeHorizon: string;
    riskTolerance: string;
    liquidityRequirements: string;
    comparisonBenchmarks: string;
    useCase: string;
    reportingFormat: string;
    urgentInsights: string;
}
interface StablecoinAssessment {
    name: string;
    symbol: string;
    marketCap: number;
    dominance: number;
    stabilityScore: number;
    riskLevel: string;
    pegStatus: PegStatusData;
    recommendation: string;
    yieldOpportunities: YieldOpportunityData[];
    chainDistribution: ChainDistributionData;
}
interface PegStatusData {
    currentPrice: number;
    deviation: number;
    status: string;
    deviationSeverity: string;
}
interface YieldOpportunityData {
    protocol: string;
    apy: number;
    risk: string;
    mechanism: string;
}
interface ChainDistributionData {
    chains: Array<{
        chain: string;
        amount: number;
    }>;
    totalChains: number;
    concentrationRisk: string;
}
interface StablecoinIntelligence {
    stablecoinAssessments: StablecoinRawAssessment[];
    marketMetrics: {
        totalMarketCap: number;
        stablecoinCount: number;
        majorStablecoins: number;
        dominanceConcentration: {
            level: string;
            top3: number;
            top5: number;
        };
        marketHealthScore: number;
    };
}
interface StablecoinRawAssessment {
    name: string;
    symbol: string;
    marketCap: number;
    dominance: number;
    change24h: number;
    pegMechanism: string;
    stabilityAssessment: {
        stabilityScore: number;
        riskLevel: string;
        stabilityFactors: string[];
        riskFactors: string[];
        pegStatus: PegStatusData;
        recommendation: string;
    };
    yieldOpportunities: YieldOpportunityData[];
    chainDistribution: ChainDistributionData;
}
interface StablecoinAnalysisResults {
    overallStabilityScores: {
        average: number;
        level: string;
        stablecoinCount: number;
        marketHealthScore: number;
    };
    stablecoinAssessments: StablecoinAssessment[];
    riskFactors: string[];
    recommendations: string[];
}

declare class DefiLlamaService extends Service {
    static serviceType: string;
    capabilityDescription: string;
    private defiConfig;
    private requestQueue;
    private requestCount;
    private resetTime;
    private isProcessingQueue;
    private rateLimitStatus;
    private queueProcessInterval?;
    private rateLimitResetInterval?;
    constructor(runtime: IAgentRuntime);
    static start(runtime: IAgentRuntime): Promise<DefiLlamaService>;
    static stop(runtime: IAgentRuntime): Promise<void>;
    stop(): Promise<void>;
    getProtocols(): Promise<ProtocolDetails[]>;
    getProtocol(slug: string): Promise<ProtocolDetails>;
    getTVL(protocol?: string): Promise<TVLData>;
    getYields(): Promise<YieldPool[]>;
    getChains(): Promise<Chain[]>;
    getHistoricalTVL(protocol: string, period: string): Promise<HistoricalData[]>;
    getBridges(params?: {
        includeChains?: boolean;
    }): Promise<Bridge[]>;
    getStablecoins(params?: {
        includePrices?: boolean;
    }): Promise<Stablecoin[]>;
    getStablecoinChains(): Promise<Record<string, any>>;
    getYieldChart(poolId: string): Promise<YieldChartData[]>;
    getDexVolumes(params?: {
        excludeTotalDataChart?: boolean;
        excludeTotalDataChartBreakdown?: boolean;
    }): Promise<DexVolume[]>;
    getDexVolumesByChain(chain: string, params?: {
        excludeTotalDataChart?: boolean;
        excludeTotalDataChartBreakdown?: boolean;
    }): Promise<DexVolume[]>;
    getProtocolFees(params?: {
        excludeTotalDataChart?: boolean;
        excludeTotalDataChartBreakdown?: boolean;
        dataType?: string;
    }): Promise<ProtocolFees[]>;
    getProtocolFeesByChain(chain: string, params?: {
        excludeTotalDataChart?: boolean;
        excludeTotalDataChartBreakdown?: boolean;
        dataType?: string;
    }): Promise<ProtocolFees[]>;
    getProtocolFeesById(protocolId: string): Promise<ProtocolFees>;
    getCoinPrices(coins: string[], searchWidth?: string): Promise<{
        coins: Record<string, CoinPrice>;
    }>;
    getHistoricalPrices(coins: string[], timestamp: number): Promise<{
        coins: Record<string, HistoricalPrice>;
    }>;
    getBatchHistoricalPrices(coins: string[], searchWidth?: string): Promise<Record<string, {
        price: number;
        timestamp: number;
    }>>;
    getFirstPrices(coins: string[]): Promise<{
        coins: Record<string, {
            price: number;
            timestamp: number;
        }>;
    }>;
    getRateLimitStatus(): Promise<RateLimitStatus>;
    batchRequests<T>(requests: APIRequest[]): Promise<T[]>;
    private makeRequest;
    private processQueue;
    private executeRequest;
    private shouldRetryError;
    private parsePeriod;
}

/**
 * @module plugin-defillama
 * @description DeFiLlama plugin for ElizaOS - provides DeFi market data, analytics, and yield information
 */

/**
 * DeFiLlama plugin for ElizaOS
 *
 * Provides comprehensive DeFi market data, protocol analytics, yield information,
 * and monitoring capabilities through the DeFiLlama API.
 */
declare const defiLlamaPlugin: Plugin;

export { type APIRequest, type Bridge, type Chain, type ChainAnalysisData, type ChainDistributionData, type ChainPerformanceData, type ChainTvl, type CoinPrice, type ComprehensiveTrendData, type CrossChainAnalysis, type DefiLlamaConfig, type DefiLlamaError, DefiLlamaService, type DexVolume, type EfficiencyMetric, type FeeData, type FeeEfficiency, type FeeSustainability, type FeesVolumeRequirements, type HistoricalAnalysisRequirements, type HistoricalAnalysisResults, type HistoricalData, type HistoricalPatterns, type HistoricalPrice, type LiquidityEfficiency, type MarketCorrelationData, type MarketSentimentData, type MarketTrendFilters, type PegStatusData, type PriceAnalysisRequirements, type PriceDataResponse, type PriceMetrics, type ProcessedDexVolume, type ProcessedFeesVolumeData, type ProcessedProtocolFee, type Protocol, type ProtocolDetails, type ProtocolFees, type ProtocolFilters, type ProtocolResponse, type ProtocolRiskAssessment, type ProtocolRiskData, type ProtocolTrendData, type ProtocolTrends, type RateLimitStatus, type RiskAnalysisRequirements, type RiskAnalysisResults, type RiskIntelligence, type SectorData, type Stablecoin, type StablecoinAnalysisRequirements, type StablecoinAnalysisResults, type StablecoinAssessment, type StablecoinIntelligence, type StablecoinRawAssessment, type TVLData, type TokenAnalysis, type TrendAnalysis, type TrendAnalysisRequirements, type TrendAnalysisResults, type VolumeData, type YieldChartData, type YieldFilters, type YieldOpportunityData, type YieldPool, type YieldResponse, type YieldRiskAnalysis, type YieldRiskData, defiLlamaPlugin as default, defiLlamaPlugin };
