{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/init.ts", "../../src/utils/config.ts", "../../src/models/text.ts", "../../src/providers/anthropic.ts", "../../src/utils/events.ts", "../../src/models/object.ts", "../../src/utils/json.ts"],
  "sourcesContent": [
    "import type {\n  GenerateTextParams,\n  IAgentRuntime,\n  ObjectGenerationParams,\n  Plugin,\n} from '@elizaos/core';\nimport { ModelType } from '@elizaos/core';\nimport { initializeAnthropic } from './init';\nimport { handleTextSmall, handleTextLarge, handleObjectSmall, handleObjectLarge } from './models';\nimport { getApiKey, getBaseURL } from './utils/config';\nimport { logger } from '@elizaos/core';\n\nexport * from './types';\n\n/**\n * Plugin for Anthropic.\n *\n * @type {Plugin}\n * @property {string} name - The name of the plugin.\n * @property {string} description - The description of the plugin.\n * @property {Object} config - The configuration object with API keys and model variables.\n * @property {Function} init - Initializes the plugin with the given configuration.\n * @property {Function} models - Contains functions for generating text using small and large models.\n * @property {Function[]} tests - An array of test functions for the plugin.\n */\nexport const anthropicPlugin: Plugin = {\n  name: 'anthropic',\n  description: 'Anthropic plugin (supports text generation only)',\n  config: {\n    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n    ANTHROPIC_SMALL_MODEL: process.env.ANTHROPIC_SMALL_MODEL,\n    ANTHROPIC_LARGE_MODEL: process.env.ANTHROPIC_LARGE_MODEL,\n    ANTHROPIC_EXPERIMENTAL_TELEMETRY: process.env.ANTHROPIC_EXPERIMENTAL_TELEMETRY,\n    ANTHROPIC_BASE_URL: process.env.ANTHROPIC_BASE_URL,\n    ANTHROPIC_BROWSER_BASE_URL: process.env.ANTHROPIC_BROWSER_BASE_URL,\n  },\n  async init(_config, runtime) {\n    // Note: We intentionally don't await here because ElizaOS expects\n    // the init method to return quickly. The initializeAnthropic function\n    // performs background validation and logging.\n    initializeAnthropic(_config, runtime);\n  },\n\n  models: {\n    [ModelType.TEXT_SMALL]: async (runtime: IAgentRuntime, params: GenerateTextParams) => {\n      return handleTextSmall(runtime, params);\n    },\n    [ModelType.TEXT_LARGE]: async (runtime: IAgentRuntime, params: GenerateTextParams) => {\n      return handleTextLarge(runtime, params);\n    },\n    [ModelType.OBJECT_SMALL]: async (runtime: IAgentRuntime, params: ObjectGenerationParams) => {\n      return handleObjectSmall(runtime, params);\n    },\n    [ModelType.OBJECT_LARGE]: async (runtime: IAgentRuntime, params: ObjectGenerationParams) => {\n      return handleObjectLarge(runtime, params);\n    },\n  },\n  tests: [\n    {\n      name: 'anthropic_plugin_tests',\n      tests: [\n        {\n          name: 'anthropic_test_api_key_validation',\n          fn: async (runtime: IAgentRuntime) => {\n            const apiKey = getApiKey(runtime);\n            if (!apiKey) {\n              throw new Error('ANTHROPIC_API_KEY is not configured');\n            }\n            logger.log('Anthropic API key is configured');\n          },\n        },\n        {\n          name: 'anthropic_test_text_small',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const text = await runtime.useModel(ModelType.TEXT_SMALL, {\n                prompt: 'What is the nature of reality in 10 words?',\n              });\n              if (text.length === 0) {\n                throw new Error('Failed to generate text');\n              }\n              logger.log({ text }, 'generated with test_text_small');\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_text_small: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_text_large',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const text = await runtime.useModel(ModelType.TEXT_LARGE, {\n                prompt: 'What is the nature of reality in 10 words?',\n              });\n              if (text.length === 0) {\n                throw new Error('Failed to generate text');\n              }\n              logger.log({ text }, 'generated with test_text_large');\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_text_large: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_small',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_SMALL, {\n                prompt: 'Create a simple JSON object with a message field saying hello',\n                schema: { type: 'object' },\n              });\n              logger.log({ result }, 'Generated object with test_object_small');\n              if (!result || (typeof result === 'object' && 'error' in result)) {\n                throw new Error('Failed to generate object');\n              }\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_object_small: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_large',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_LARGE, {\n                prompt: 'Create a simple JSON object with a message field saying hello',\n                schema: { type: 'object' },\n              });\n              logger.log({ result }, 'Generated object with test_object_large');\n              if (!result || (typeof result === 'object' && 'error' in result)) {\n                throw new Error('Failed to generate object');\n              }\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_object_large: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_with_code_blocks',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_SMALL, {\n                prompt: 'Give me instructions to install Node.js',\n                schema: { type: 'object' },\n              });\n              logger.log({ result }, 'Generated object with code blocks');\n              if (!result || (typeof result === 'object' && 'error' in result)) {\n                throw new Error('Failed to generate object with code blocks');\n              }\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_object_with_code_blocks: ${message}`);\n              throw error;\n            }\n          },\n        },\n      ],\n    },\n  ],\n};\n\nexport default anthropicPlugin;\n",
    "import { logger, type IAgentRuntime } from '@elizaos/core';\nimport { getApiKey, isBrowser } from './utils/config';\n\n/**\n * Initialize and validate Anthropic configuration\n */\nexport function initializeAnthropic(_config: any, runtime: IAgentRuntime) {\n  // do check in the background\n  new Promise<void>(async (resolve) => {\n    resolve();\n    try {\n      const apiKey = getApiKey(runtime);\n      // If API key is not set, we'll show a warning but continue\n      if (!apiKey && !isBrowser()) {\n        logger.warn(\n          'ANTHROPIC_API_KEY is not set in environment - Anthropic functionality will be limited'\n        );\n        return;\n      }\n      // Note: Anthropic doesn't have a simple /models endpoint like OpenAI,\n      // so we just validate that the key is present\n      if (apiKey) {\n        logger.log('Anthropic API key configured successfully');\n      }\n    } catch (error: unknown) {\n      const message =\n        (error as { errors?: Array<{ message: string }> })?.errors\n          ?.map((e) => e.message)\n          .join(', ') || (error instanceof Error ? error.message : String(error));\n      logger.warn(\n        `Anthropic plugin configuration issue: ${message} - You need to configure the ANTHROPIC_API_KEY in your environment variables`\n      );\n    }\n  });\n}\n",
    "import type { IAgentRuntime } from '@elizaos/core';\nimport { logger } from '@elizaos/core';\n\n/**\n * Retrieves a configuration setting from the runtime, falling back to environment variables or a default value if not found.\n *\n * @param key - The name of the setting to retrieve.\n * @param defaultValue - The value to return if the setting is not found in the runtime or environment.\n * @returns The resolved setting value, or {@link defaultValue} if not found.\n */\nexport function getSetting(\n  runtime: IAgentRuntime,\n  key: string,\n  defaultValue?: string\n): string | undefined {\n  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;\n}\n\n/**\n * Check if we're running in a browser environment\n */\nexport function isBrowser(): boolean {\n  return typeof globalThis !== 'undefined' && typeof (globalThis as any).document !== 'undefined';\n}\n\n/**\n * Retrieves the Anthropic API base URL from runtime settings, environment variables, or defaults.\n *\n * @returns The resolved base URL for Anthropic API requests.\n */\nexport function getBaseURL(runtime: IAgentRuntime): string {\n  const browserURL = getSetting(runtime, 'ANTHROPIC_BROWSER_BASE_URL');\n  const baseURL = (\n    isBrowser() && browserURL\n      ? browserURL\n      : getSetting(runtime, 'ANTHROPIC_BASE_URL', 'https://api.anthropic.com/v1')\n  ) as string;\n  logger.debug(`[Anthropic] Base URL: ${baseURL}`);\n  return baseURL;\n}\n\n/**\n * Helper function to get the API key for Anthropic\n *\n * @param runtime The runtime context\n * @returns The configured API key\n */\nexport function getApiKey(runtime: IAgentRuntime): string | undefined {\n  return getSetting(runtime, 'ANTHROPIC_API_KEY');\n}\n\n/**\n * Helper function to get the small model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured small model name\n */\nexport function getSmallModel(runtime: IAgentRuntime): string {\n  return getSetting(runtime, 'ANTHROPIC_SMALL_MODEL', 'claude-3-5-haiku-20241022') as string;\n}\n\n/**\n * Helper function to get the large model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured large model name\n */\nexport function getLargeModel(runtime: IAgentRuntime): string {\n  return getSetting(runtime, 'ANTHROPIC_LARGE_MODEL', 'claude-sonnet-4-20250514') as string;\n}\n\n/**\n * Helper function to get experimental telemetry setting\n *\n * @param runtime The runtime context\n * @returns Whether experimental telemetry is enabled\n */\nexport function getExperimentalTelemetry(runtime: IAgentRuntime): boolean {\n  const setting = getSetting(runtime, 'ANTHROPIC_EXPERIMENTAL_TELEMETRY', 'false');\n  const normalizedSetting = String(setting).toLowerCase();\n  const result = normalizedSetting === 'true';\n  logger.debug(\n    `[Anthropic] Experimental telemetry: \"${setting}\" (normalized: \"${normalizedSetting}\", result: ${result})`\n  );\n  return result;\n}\n",
    "import type { GenerateTextParams, IAgentRuntime } from '@elizaos/core';\nimport { logger, ModelType } from '@elizaos/core';\nimport { generateText } from 'ai';\nimport { createAnthropicClient } from '../providers';\nimport { getSmallModel, getLargeModel, getExperimentalTelemetry } from '../utils/config';\nimport { emitModelUsageEvent } from '../utils/events';\n\n/**\n * TEXT_SMALL model handler\n */\nexport async function handleTextSmall(\n  runtime: IAgentRuntime,\n  {\n    prompt,\n    stopSequences = [],\n    maxTokens,\n    temperature = 0.7,\n    frequencyPenalty = 0.7,\n    presencePenalty = 0.7,\n  }: GenerateTextParams\n): Promise<string> {\n  const anthropic = createAnthropicClient(runtime);\n  const modelName = getSmallModel(runtime);\n  const experimentalTelemetry = getExperimentalTelemetry(runtime);\n\n  // Use provided maxTokens or default based on model\n  if (maxTokens === undefined) {\n    maxTokens = modelName.includes('-3-') ? 4096 : 8192;\n  }\n\n  logger.log(`[Anthropic] Using TEXT_SMALL model: ${modelName}`);\n\n  const { text, usage } = await generateText({\n    model: anthropic(modelName),\n    prompt,\n    system: runtime.character.system ?? undefined,\n    temperature,\n    maxOutputTokens: maxTokens,\n    stopSequences,\n    frequencyPenalty,\n    presencePenalty,\n    experimental_telemetry: { isEnabled: experimentalTelemetry },\n  });\n\n  if (usage) {\n    emitModelUsageEvent(runtime, ModelType.TEXT_SMALL, prompt, usage);\n  }\n\n  return text;\n}\n\n/**\n * TEXT_LARGE model handler\n */\nexport async function handleTextLarge(\n  runtime: IAgentRuntime,\n  {\n    prompt,\n    maxTokens = 8192,\n    stopSequences = [],\n    temperature = 0.7,\n    frequencyPenalty = 0.7,\n    presencePenalty = 0.7,\n  }: GenerateTextParams\n): Promise<string> {\n  const anthropic = createAnthropicClient(runtime);\n  const modelName = getLargeModel(runtime);\n  const experimentalTelemetry = getExperimentalTelemetry(runtime);\n\n  logger.log(`[Anthropic] Using TEXT_LARGE model: ${modelName}`);\n\n  const { text, usage } = await generateText({\n    model: anthropic(modelName),\n    prompt,\n    system: runtime.character.system ?? undefined,\n    temperature,\n    maxOutputTokens: maxTokens,\n    stopSequences,\n    frequencyPenalty,\n    presencePenalty,\n    experimental_telemetry: { isEnabled: experimentalTelemetry },\n  });\n\n  if (usage) {\n    emitModelUsageEvent(runtime, ModelType.TEXT_LARGE, prompt, usage);\n  }\n\n  return text;\n}\n",
    "import { createAnthropic } from '@ai-sdk/anthropic';\nimport type { IAgentRuntime } from '@elizaos/core';\nimport { getApiKey, getBaseURL, isBrowser } from '../utils/config';\n\n/**\n * Create an Anthropic client with proper configuration\n *\n * @param runtime The runtime context\n * @returns Configured Anthropic client\n */\nexport function createAnthropicClient(runtime: IAgentRuntime) {\n  return createAnthropic({\n    apiKey: isBrowser() ? undefined : getApiKey(runtime),\n    baseURL: getBaseURL(runtime),\n  });\n}\n",
    "import type { IAgentRuntime, ModelTypeName } from '@elizaos/core';\nimport { EventType } from '@elizaos/core';\nimport type { LanguageModelUsage } from 'ai';\n\n/**\n * Emits a model usage event\n * @param runtime The runtime context\n * @param type The model type\n * @param prompt The prompt used\n * @param usage The LLM usage data\n */\nexport function emitModelUsageEvent(\n  runtime: IAgentRuntime,\n  type: ModelTypeName,\n  prompt: string,\n  usage: LanguageModelUsage\n) {\n  runtime.emitEvent(EventType.MODEL_USED, {\n    provider: 'anthropic',\n    type,\n    prompt,\n    tokens: {\n      prompt: usage.inputTokens,\n      completion: usage.outputTokens,\n      total: usage.totalTokens,\n    },\n  });\n}\n",
    "import type { IAgentRuntime, ObjectGenerationParams, ModelTypeName } from '@elizaos/core';\nimport { logger, ModelType } from '@elizaos/core';\nimport { generateText, type JSONValue } from 'ai';\nimport { createAnthropicClient } from '../providers';\nimport { getSmallModel, getLargeModel } from '../utils/config';\nimport { emitModelUsageEvent } from '../utils/events';\nimport { extractAndParseJSON, ensureReflectionProperties } from '../utils/json';\n\n/**\n * Helper function to generate objects using specified model type\n */\nasync function generateObjectByModelType(\n  runtime: IAgentRuntime,\n  params: ObjectGenerationParams,\n  modelType: string,\n  getModelFn: (runtime: IAgentRuntime) => string\n): Promise<JSONValue> {\n  const anthropic = createAnthropicClient(runtime);\n  const modelName = getModelFn(runtime);\n  logger.log(`[Anthropic] Using ${modelType} model: ${modelName}`);\n\n  try {\n    // Check if this is a reflection schema request (has specific format)\n    const isReflection = !!(params.schema?.facts && params.schema.relationships);\n\n    // Build a prompt that asks for JSON output\n    let jsonPrompt = params.prompt;\n\n    // Don't modify the prompt if it already contains explicit JSON formatting instructions\n    if (!jsonPrompt.includes('```json') && !jsonPrompt.includes('respond with valid JSON')) {\n      jsonPrompt +=\n        '\\nPlease respond with valid JSON only, without any explanations, markdown formatting, or additional text.';\n    }\n\n    let systemPrompt = runtime.character.system\n      ? `${runtime.character.system}\\nYou must respond with valid JSON only.`\n      : 'You must respond with valid JSON only.';\n\n    // For reflection schemas, we need a more specific instruction\n    if (isReflection) {\n      systemPrompt +=\n        \" Ensure your response includes 'thought', 'facts', and 'relationships' properties exactly as specified in the prompt.\";\n    } else {\n      systemPrompt += ' No markdown, no code blocks, no explanation text.';\n    }\n\n    // Generate text response that should contain JSON\n    const { text, usage } = await generateText({\n      model: anthropic(modelName),\n      prompt: jsonPrompt,\n      system: systemPrompt,\n      temperature: params.temperature || 0.2, // Lower temperature for more predictable structured output\n    });\n\n    if (usage) {\n      emitModelUsageEvent(runtime, modelType as ModelTypeName, params.prompt, usage);\n    }\n\n    // Extract and parse JSON from the response\n    try {\n      logger.debug('Attempting to parse response from Anthropic model');\n      const jsonObject = extractAndParseJSON(text);\n\n      // Ensure reflection schema has all required properties\n      const processedObject = ensureReflectionProperties(jsonObject, isReflection);\n\n      return processedObject as JSONValue;\n    } catch (parseError) {\n      logger.error(`Failed to parse JSON from Anthropic response: ${parseError}`);\n      logger.error(`Raw response: ${text}`);\n      throw new Error('Invalid JSON returned from Anthropic model');\n    }\n  } catch (error) {\n    logger.error(`Error generating object: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * OBJECT_SMALL model handler\n */\nexport async function handleObjectSmall(\n  runtime: IAgentRuntime,\n  params: ObjectGenerationParams\n): Promise<JSONValue> {\n  return generateObjectByModelType(runtime, params, ModelType.OBJECT_SMALL, getSmallModel);\n}\n\n/**\n * OBJECT_LARGE model handler\n */\nexport async function handleObjectLarge(\n  runtime: IAgentRuntime,\n  params: ObjectGenerationParams\n): Promise<JSONValue> {\n  return generateObjectByModelType(runtime, params, ModelType.OBJECT_LARGE, getLargeModel);\n}\n",
    "import { logger } from '@elizaos/core';\nimport { jsonrepair } from 'jsonrepair';\n\n/**\n * Type definition for a code block placeholder\n */\ninterface CodeBlockPlaceholder {\n  placeholder: string;\n  content: string;\n}\n\n/**\n * Type for reconstructed response\n */\nexport interface ReconstructedResponse {\n  type: 'reconstructed_response';\n  thought?: string;\n  message?: string;\n  codeBlocks?: Array<{\n    language: string;\n    code: string;\n  }>;\n}\n\n/**\n * Type for reflection schema response\n */\nexport interface ReflectionResponse {\n  thought: string;\n  facts: unknown[];\n  relationships: unknown[];\n  rawContent: string;\n}\n\n/**\n * Type for unstructured response\n */\nexport interface UnstructuredResponse {\n  type: 'unstructured_response';\n  content: string;\n}\n\n/**\n * Type for JSON extraction result\n */\nexport type ExtractedJSON =\n  | Record<string, unknown>\n  | ReconstructedResponse\n  | ReflectionResponse\n  | UnstructuredResponse;\n\n/**\n * Helper function to ensure reflection response has all required properties\n */\nexport const ensureReflectionProperties = (\n  obj: ExtractedJSON,\n  isReflection: boolean\n): ExtractedJSON => {\n  // Only process if it's a reflection schema request\n  if (!isReflection) return obj;\n\n  // Check if it's an object with potentially missing reflection properties\n  if (obj !== null && typeof obj === 'object') {\n    // Create a new object with required properties\n    return {\n      ...obj,\n      thought: 'thought' in obj ? obj.thought || '' : '',\n      facts: 'facts' in obj ? obj.facts || [] : [],\n      relationships: 'relationships' in obj ? obj.relationships || [] : [],\n    };\n  }\n\n  return obj;\n};\n\n/**\n * Enhanced function to extract and parse JSON from LLM responses\n * Handles various response formats including mixed markdown and JSON with code blocks\n */\nexport const extractAndParseJSON = (text: string): ExtractedJSON => {\n  try {\n    // First attempt: Try direct JSON parsing\n    return JSON.parse(text);\n  } catch (initialError) {\n    logger.debug('Initial JSON parse failed, attempting alternative extraction methods');\n\n    // Try JSONRepair first\n    try {\n      const repaired = jsonrepair(text);\n      return JSON.parse(repaired);\n    } catch (repairError) {\n      logger.debug('JSONRepair failed, proceeding with manual extraction methods');\n    }\n\n    // Check if we have a valid JSON structure with embedded code blocks\n    const isJsonWithCodeBlocks =\n      text.trim().startsWith('{') && text.trim().endsWith('}') && text.includes('```');\n\n    if (isJsonWithCodeBlocks) {\n      // Replace code blocks with escaped versions to preserve them in the JSON\n      try {\n        // First, try to preserve the code blocks by temporarily replacing them\n        const codeBlockPlaceholders: CodeBlockPlaceholder[] = [];\n        let placeholderCounter = 0;\n        const textWithPlaceholders = text.replace(\n          /```(\\w*)\\n([\\s\\S]*?)```/g,\n          (match, language, code) => {\n            const placeholder = `__CODE_BLOCK_${placeholderCounter++}__`;\n            codeBlockPlaceholders.push({\n              placeholder,\n              content: `\\`\\`\\`${language}\\n${code}\\`\\`\\``,\n            });\n            return placeholder;\n          }\n        );\n\n        // Try parsing with placeholders\n        let parsed: Record<string, unknown>;\n        try {\n          // Try JSONRepair first\n          const repaired = jsonrepair(textWithPlaceholders);\n          parsed = JSON.parse(repaired);\n        } catch (e) {\n          // If JSONRepair fails, try direct parsing\n          parsed = JSON.parse(textWithPlaceholders);\n        }\n\n        // Restore code blocks in the parsed object\n        const restoreCodeBlocks = (obj: unknown): unknown => {\n          if (typeof obj === 'string') {\n            let result = obj;\n            for (const { placeholder, content } of codeBlockPlaceholders) {\n              result = result.replace(placeholder, content);\n            }\n            return result;\n          } else if (Array.isArray(obj)) {\n            return obj.map((item) => restoreCodeBlocks(item));\n          } else if (obj !== null && typeof obj === 'object') {\n            const result: Record<string, unknown> = {};\n            for (const [key, value] of Object.entries(obj as Record<string, unknown>)) {\n              result[key] = restoreCodeBlocks(value);\n            }\n            return result;\n          }\n          return obj;\n        };\n\n        return restoreCodeBlocks(parsed) as ExtractedJSON;\n      } catch (codeBlockError) {\n        logger.debug('Code block preservation failed, continuing with other methods');\n      }\n    }\n\n    // Try to extract JSON from code blocks\n    const extractFromCodeBlocks = (text: string): string | null => {\n      // First priority: explicit JSON code blocks\n      const jsonBlockRegex = /```json\\s*([\\s\\S]*?)\\s*```/;\n      const jsonMatch = text.match(jsonBlockRegex);\n      if (jsonMatch && jsonMatch[1]) {\n        return jsonMatch[1].trim();\n      }\n\n      // Second priority: any code block that contains JSON-like content\n      const anyBlockRegex = /```(?:\\w*)\\s*([\\s\\S]*?)\\s*```/g;\n      let match;\n      while ((match = anyBlockRegex.exec(text)) !== null) {\n        const blockContent = match[1].trim();\n        if (blockContent.startsWith('{') && blockContent.endsWith('}')) {\n          return blockContent;\n        }\n      }\n\n      return null;\n    };\n\n    const extractedFromCodeBlock = extractFromCodeBlocks(text);\n    if (extractedFromCodeBlock) {\n      try {\n        // Try parsing the extracted content\n        return JSON.parse(extractedFromCodeBlock);\n      } catch (blockParseError) {\n        try {\n          // Try with JSONRepair\n          const repaired = jsonrepair(extractedFromCodeBlock);\n          return JSON.parse(repaired);\n        } catch (blockRepairError) {\n          logger.debug('Failed to parse JSON from code block after repair');\n        }\n      }\n    }\n\n    // Look for JSON structure outside of code blocks\n    const extractJSON = (text: string): string | null => {\n      // Try to find JSON-like content in the text\n      const jsonContentRegex = /(^|\\n)\\s*(\\{[\\s\\S]*\\})\\s*($|\\n)/;\n      const contentMatch = text.match(jsonContentRegex);\n\n      if (contentMatch && contentMatch[2]) {\n        return contentMatch[2].trim();\n      }\n\n      // If no direct match, try to find the largest JSON-like structure\n      const jsonPattern = /\\{[\\s\\S]*?\\}/g;\n      const jsonMatches = text.match(jsonPattern);\n\n      if (jsonMatches && jsonMatches.length > 0) {\n        // Sort matches by length (descending) to try the largest JSON-like structure first\n        return [...jsonMatches].sort((a, b) => b.length - a.length)[0];\n      }\n\n      return null;\n    };\n\n    const extractedJSON = extractJSON(text);\n    if (extractedJSON) {\n      try {\n        // Try parsing the extracted JSON\n        return JSON.parse(extractedJSON);\n      } catch (extractParseError) {\n        try {\n          // Try with JSONRepair\n          const repaired = jsonrepair(extractedJSON);\n          return JSON.parse(repaired);\n        } catch (extractRepairError) {\n          logger.debug('Failed to parse JSON after extraction and repair');\n        }\n      }\n    }\n\n    // Try to manually extract a \"thought\"/\"message\" structure which is common\n    const manuallyExtractStructure = (\n      text: string\n    ): ReconstructedResponse | ReflectionResponse | null => {\n      // Extract thought/message pattern if present\n      const thoughtPattern = /\"thought\"\\s*:\\s*\"([^\"]*?)(?:\"|$)/;\n      const messagePattern = /\"message\"\\s*:\\s*\"([^\"]*?)(?:\"|$)/;\n\n      const thoughtMatch = text.match(thoughtPattern);\n      const messageMatch = text.match(messagePattern);\n\n      if (thoughtMatch || messageMatch) {\n        const extractedContent: ReconstructedResponse = {\n          type: 'reconstructed_response',\n        };\n\n        if (thoughtMatch) {\n          extractedContent.thought = thoughtMatch[1].replace(/\\\\n/g, '\\n');\n        }\n\n        if (messageMatch) {\n          extractedContent.message = messageMatch[1].replace(/\\\\n/g, '\\n');\n        } else {\n          // If no message was found but we have a thought, try to use the rest of the content as message\n          let remainingContent = text;\n          if (thoughtMatch) {\n            // Remove the thought part from the content\n            remainingContent = remainingContent.replace(thoughtPattern, '');\n          }\n\n          // Look for code blocks in the remaining content\n          const codeBlocks: Array<{ language: string; code: string }> = [];\n          const codeBlockRegex = /```([\\w]*)\\n([\\s\\S]*?)```/g;\n          let match;\n\n          while ((match = codeBlockRegex.exec(remainingContent)) !== null) {\n            codeBlocks.push({\n              language: match[1] || 'text',\n              code: match[2].trim(),\n            });\n          }\n\n          if (codeBlocks.length > 0) {\n            extractedContent.codeBlocks = codeBlocks;\n            // Remove code blocks from the remaining content\n            remainingContent = remainingContent.replace(codeBlockRegex, '');\n          }\n\n          // Use the cleaned remaining content as message\n          extractedContent.message = remainingContent.trim();\n        }\n\n        return extractedContent;\n      }\n\n      // For reflection schema-like structure\n      if (text.includes('thought') || text.includes('facts') || text.includes('relationships')) {\n        logger.debug('Attempting to extract reflection schema components');\n\n        const result: ReflectionResponse = {\n          thought: '',\n          facts: [],\n          relationships: [],\n          rawContent: text,\n        };\n\n        // Try to extract thought\n        const thoughtMatch = text.match(/thought[\"\\s:]+([^\"{}[\\],]+)/i);\n        if (thoughtMatch) {\n          result.thought = thoughtMatch[1].trim();\n        }\n\n        return result;\n      }\n\n      return null;\n    };\n\n    const manuallyExtracted = manuallyExtractStructure(text);\n    if (manuallyExtracted) {\n      return manuallyExtracted;\n    }\n\n    // Last resort: Return a structured object with the raw text\n    logger.debug(\n      'All JSON extraction methods failed, returning structured object with raw content'\n    );\n    return {\n      type: 'unstructured_response',\n      content: text,\n    };\n  }\n};\n"
  ],
  "mappings": "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",
  "debugId": "0F9EBD3A31E0E6E164756E2164756E21",
  "names": []
}