{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/init.ts", "../../src/utils/config.ts", "../../src/models/text.ts", "../../src/providers/anthropic.ts", "../../src/utils/events.ts", "../../src/models/object.ts", "../../src/utils/json.ts", "../../node_modules/jsonrepair/lib/esm/utils/JSONRepairError.js", "../../node_modules/jsonrepair/lib/esm/utils/stringUtils.js", "../../node_modules/jsonrepair/lib/esm/regular/jsonrepair.js"],
  "sourcesContent": [
    "import type {\n  GenerateTextParams,\n  IAgentRuntime,\n  ObjectGenerationParams,\n  Plugin,\n} from '@elizaos/core';\nimport { ModelType } from '@elizaos/core';\nimport { initializeAnthropic } from './init';\nimport { handleTextSmall, handleTextLarge, handleObjectSmall, handleObjectLarge } from './models';\nimport { getApiKey, getBaseURL } from './utils/config';\nimport { logger } from '@elizaos/core';\n\nexport * from './types';\n\n/**\n * Plugin for Anthropic.\n *\n * @type {Plugin}\n * @property {string} name - The name of the plugin.\n * @property {string} description - The description of the plugin.\n * @property {Object} config - The configuration object with API keys and model variables.\n * @property {Function} init - Initializes the plugin with the given configuration.\n * @property {Function} models - Contains functions for generating text using small and large models.\n * @property {Function[]} tests - An array of test functions for the plugin.\n */\nexport const anthropicPlugin: Plugin = {\n  name: 'anthropic',\n  description: 'Anthropic plugin (supports text generation only)',\n  config: {\n    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n    ANTHROPIC_SMALL_MODEL: process.env.ANTHROPIC_SMALL_MODEL,\n    ANTHROPIC_LARGE_MODEL: process.env.ANTHROPIC_LARGE_MODEL,\n    ANTHROPIC_EXPERIMENTAL_TELEMETRY: process.env.ANTHROPIC_EXPERIMENTAL_TELEMETRY,\n    ANTHROPIC_BASE_URL: process.env.ANTHROPIC_BASE_URL,\n    ANTHROPIC_BROWSER_BASE_URL: process.env.ANTHROPIC_BROWSER_BASE_URL,\n  },\n  async init(_config, runtime) {\n    // Note: We intentionally don't await here because ElizaOS expects\n    // the init method to return quickly. The initializeAnthropic function\n    // performs background validation and logging.\n    initializeAnthropic(_config, runtime);\n  },\n\n  models: {\n    [ModelType.TEXT_SMALL]: async (runtime: IAgentRuntime, params: GenerateTextParams) => {\n      return handleTextSmall(runtime, params);\n    },\n    [ModelType.TEXT_LARGE]: async (runtime: IAgentRuntime, params: GenerateTextParams) => {\n      return handleTextLarge(runtime, params);\n    },\n    [ModelType.OBJECT_SMALL]: async (runtime: IAgentRuntime, params: ObjectGenerationParams) => {\n      return handleObjectSmall(runtime, params);\n    },\n    [ModelType.OBJECT_LARGE]: async (runtime: IAgentRuntime, params: ObjectGenerationParams) => {\n      return handleObjectLarge(runtime, params);\n    },\n  },\n  tests: [\n    {\n      name: 'anthropic_plugin_tests',\n      tests: [\n        {\n          name: 'anthropic_test_api_key_validation',\n          fn: async (runtime: IAgentRuntime) => {\n            const apiKey = getApiKey(runtime);\n            if (!apiKey) {\n              throw new Error('ANTHROPIC_API_KEY is not configured');\n            }\n            logger.log('Anthropic API key is configured');\n          },\n        },\n        {\n          name: 'anthropic_test_text_small',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const text = await runtime.useModel(ModelType.TEXT_SMALL, {\n                prompt: 'What is the nature of reality in 10 words?',\n              });\n              if (text.length === 0) {\n                throw new Error('Failed to generate text');\n              }\n              logger.log({ text }, 'generated with test_text_small');\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_text_small: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_text_large',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const text = await runtime.useModel(ModelType.TEXT_LARGE, {\n                prompt: 'What is the nature of reality in 10 words?',\n              });\n              if (text.length === 0) {\n                throw new Error('Failed to generate text');\n              }\n              logger.log({ text }, 'generated with test_text_large');\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_text_large: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_small',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_SMALL, {\n                prompt: 'Create a simple JSON object with a message field saying hello',\n                schema: { type: 'object' },\n              });\n              logger.log({ result }, 'Generated object with test_object_small');\n              if (!result || (typeof result === 'object' && 'error' in result)) {\n                throw new Error('Failed to generate object');\n              }\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_object_small: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_large',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_LARGE, {\n                prompt: 'Create a simple JSON object with a message field saying hello',\n                schema: { type: 'object' },\n              });\n              logger.log({ result }, 'Generated object with test_object_large');\n              if (!result || (typeof result === 'object' && 'error' in result)) {\n                throw new Error('Failed to generate object');\n              }\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_object_large: ${message}`);\n              throw error;\n            }\n          },\n        },\n        {\n          name: 'anthropic_test_object_with_code_blocks',\n          fn: async (runtime: IAgentRuntime) => {\n            try {\n              const result = await runtime.useModel(ModelType.OBJECT_SMALL, {\n                prompt: 'Give me instructions to install Node.js',\n                schema: { type: 'object' },\n              });\n              logger.log({ result }, 'Generated object with code blocks');\n              if (!result || (typeof result === 'object' && 'error' in result)) {\n                throw new Error('Failed to generate object with code blocks');\n              }\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              logger.error(`Error in test_object_with_code_blocks: ${message}`);\n              throw error;\n            }\n          },\n        },\n      ],\n    },\n  ],\n};\n\nexport default anthropicPlugin;\n",
    "import { logger, type IAgentRuntime } from '@elizaos/core';\nimport { getApiKey, isBrowser } from './utils/config';\n\n/**\n * Initialize and validate Anthropic configuration\n */\nexport function initializeAnthropic(_config: any, runtime: IAgentRuntime) {\n  // do check in the background\n  new Promise<void>(async (resolve) => {\n    resolve();\n    try {\n      const apiKey = getApiKey(runtime);\n      // If API key is not set, we'll show a warning but continue\n      if (!apiKey && !isBrowser()) {\n        logger.warn(\n          'ANTHROPIC_API_KEY is not set in environment - Anthropic functionality will be limited'\n        );\n        return;\n      }\n      // Note: Anthropic doesn't have a simple /models endpoint like OpenAI,\n      // so we just validate that the key is present\n      if (apiKey) {\n        logger.log('Anthropic API key configured successfully');\n      }\n    } catch (error: unknown) {\n      const message =\n        (error as { errors?: Array<{ message: string }> })?.errors\n          ?.map((e) => e.message)\n          .join(', ') || (error instanceof Error ? error.message : String(error));\n      logger.warn(\n        `Anthropic plugin configuration issue: ${message} - You need to configure the ANTHROPIC_API_KEY in your environment variables`\n      );\n    }\n  });\n}\n",
    "import type { IAgentRuntime } from '@elizaos/core';\nimport { logger } from '@elizaos/core';\n\n/**\n * Retrieves a configuration setting from the runtime, falling back to environment variables or a default value if not found.\n *\n * @param key - The name of the setting to retrieve.\n * @param defaultValue - The value to return if the setting is not found in the runtime or environment.\n * @returns The resolved setting value, or {@link defaultValue} if not found.\n */\nexport function getSetting(\n  runtime: IAgentRuntime,\n  key: string,\n  defaultValue?: string\n): string | undefined {\n  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;\n}\n\n/**\n * Check if we're running in a browser environment\n */\nexport function isBrowser(): boolean {\n  return typeof globalThis !== 'undefined' && typeof (globalThis as any).document !== 'undefined';\n}\n\n/**\n * Retrieves the Anthropic API base URL from runtime settings, environment variables, or defaults.\n *\n * @returns The resolved base URL for Anthropic API requests.\n */\nexport function getBaseURL(runtime: IAgentRuntime): string {\n  const browserURL = getSetting(runtime, 'ANTHROPIC_BROWSER_BASE_URL');\n  const baseURL = (\n    isBrowser() && browserURL\n      ? browserURL\n      : getSetting(runtime, 'ANTHROPIC_BASE_URL', 'https://api.anthropic.com/v1')\n  ) as string;\n  logger.debug(`[Anthropic] Base URL: ${baseURL}`);\n  return baseURL;\n}\n\n/**\n * Helper function to get the API key for Anthropic\n *\n * @param runtime The runtime context\n * @returns The configured API key\n */\nexport function getApiKey(runtime: IAgentRuntime): string | undefined {\n  return getSetting(runtime, 'ANTHROPIC_API_KEY');\n}\n\n/**\n * Helper function to get the small model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured small model name\n */\nexport function getSmallModel(runtime: IAgentRuntime): string {\n  return getSetting(runtime, 'ANTHROPIC_SMALL_MODEL', 'claude-3-5-haiku-20241022') as string;\n}\n\n/**\n * Helper function to get the large model name with fallbacks\n *\n * @param runtime The runtime context\n * @returns The configured large model name\n */\nexport function getLargeModel(runtime: IAgentRuntime): string {\n  return getSetting(runtime, 'ANTHROPIC_LARGE_MODEL', 'claude-sonnet-4-20250514') as string;\n}\n\n/**\n * Helper function to get experimental telemetry setting\n *\n * @param runtime The runtime context\n * @returns Whether experimental telemetry is enabled\n */\nexport function getExperimentalTelemetry(runtime: IAgentRuntime): boolean {\n  const setting = getSetting(runtime, 'ANTHROPIC_EXPERIMENTAL_TELEMETRY', 'false');\n  const normalizedSetting = String(setting).toLowerCase();\n  const result = normalizedSetting === 'true';\n  logger.debug(\n    `[Anthropic] Experimental telemetry: \"${setting}\" (normalized: \"${normalizedSetting}\", result: ${result})`\n  );\n  return result;\n}\n",
    "import type { GenerateTextParams, IAgentRuntime } from '@elizaos/core';\nimport { logger, ModelType } from '@elizaos/core';\nimport { generateText } from 'ai';\nimport { createAnthropicClient } from '../providers';\nimport { getSmallModel, getLargeModel, getExperimentalTelemetry } from '../utils/config';\nimport { emitModelUsageEvent } from '../utils/events';\n\n/**\n * TEXT_SMALL model handler\n */\nexport async function handleTextSmall(\n  runtime: IAgentRuntime,\n  {\n    prompt,\n    stopSequences = [],\n    maxTokens,\n    temperature = 0.7,\n    frequencyPenalty = 0.7,\n    presencePenalty = 0.7,\n  }: GenerateTextParams\n): Promise<string> {\n  const anthropic = createAnthropicClient(runtime);\n  const modelName = getSmallModel(runtime);\n  const experimentalTelemetry = getExperimentalTelemetry(runtime);\n\n  // Use provided maxTokens or default based on model\n  if (maxTokens === undefined) {\n    maxTokens = modelName.includes('-3-') ? 4096 : 8192;\n  }\n\n  logger.log(`[Anthropic] Using TEXT_SMALL model: ${modelName}`);\n\n  const { text, usage } = await generateText({\n    model: anthropic(modelName),\n    prompt,\n    system: runtime.character.system ?? undefined,\n    temperature,\n    maxOutputTokens: maxTokens,\n    stopSequences,\n    frequencyPenalty,\n    presencePenalty,\n    experimental_telemetry: { isEnabled: experimentalTelemetry },\n  });\n\n  if (usage) {\n    emitModelUsageEvent(runtime, ModelType.TEXT_SMALL, prompt, usage);\n  }\n\n  return text;\n}\n\n/**\n * TEXT_LARGE model handler\n */\nexport async function handleTextLarge(\n  runtime: IAgentRuntime,\n  {\n    prompt,\n    maxTokens = 8192,\n    stopSequences = [],\n    temperature = 0.7,\n    frequencyPenalty = 0.7,\n    presencePenalty = 0.7,\n  }: GenerateTextParams\n): Promise<string> {\n  const anthropic = createAnthropicClient(runtime);\n  const modelName = getLargeModel(runtime);\n  const experimentalTelemetry = getExperimentalTelemetry(runtime);\n\n  logger.log(`[Anthropic] Using TEXT_LARGE model: ${modelName}`);\n\n  const { text, usage } = await generateText({\n    model: anthropic(modelName),\n    prompt,\n    system: runtime.character.system ?? undefined,\n    temperature,\n    maxOutputTokens: maxTokens,\n    stopSequences,\n    frequencyPenalty,\n    presencePenalty,\n    experimental_telemetry: { isEnabled: experimentalTelemetry },\n  });\n\n  if (usage) {\n    emitModelUsageEvent(runtime, ModelType.TEXT_LARGE, prompt, usage);\n  }\n\n  return text;\n}\n",
    "import { createAnthropic } from '@ai-sdk/anthropic';\nimport type { IAgentRuntime } from '@elizaos/core';\nimport { getApiKey, getBaseURL, isBrowser } from '../utils/config';\n\n/**\n * Create an Anthropic client with proper configuration\n *\n * @param runtime The runtime context\n * @returns Configured Anthropic client\n */\nexport function createAnthropicClient(runtime: IAgentRuntime) {\n  return createAnthropic({\n    apiKey: isBrowser() ? undefined : getApiKey(runtime),\n    baseURL: getBaseURL(runtime),\n  });\n}\n",
    "import type { IAgentRuntime, ModelTypeName } from '@elizaos/core';\nimport { EventType } from '@elizaos/core';\nimport type { LanguageModelUsage } from 'ai';\n\n/**\n * Emits a model usage event\n * @param runtime The runtime context\n * @param type The model type\n * @param prompt The prompt used\n * @param usage The LLM usage data\n */\nexport function emitModelUsageEvent(\n  runtime: IAgentRuntime,\n  type: ModelTypeName,\n  prompt: string,\n  usage: LanguageModelUsage\n) {\n  runtime.emitEvent(EventType.MODEL_USED, {\n    provider: 'anthropic',\n    type,\n    prompt,\n    tokens: {\n      prompt: usage.inputTokens,\n      completion: usage.outputTokens,\n      total: usage.totalTokens,\n    },\n  });\n}\n",
    "import type { IAgentRuntime, ObjectGenerationParams, ModelTypeName } from '@elizaos/core';\nimport { logger, ModelType } from '@elizaos/core';\nimport { generateText, type JSONValue } from 'ai';\nimport { createAnthropicClient } from '../providers';\nimport { getSmallModel, getLargeModel } from '../utils/config';\nimport { emitModelUsageEvent } from '../utils/events';\nimport { extractAndParseJSON, ensureReflectionProperties } from '../utils/json';\n\n/**\n * Helper function to generate objects using specified model type\n */\nasync function generateObjectByModelType(\n  runtime: IAgentRuntime,\n  params: ObjectGenerationParams,\n  modelType: string,\n  getModelFn: (runtime: IAgentRuntime) => string\n): Promise<JSONValue> {\n  const anthropic = createAnthropicClient(runtime);\n  const modelName = getModelFn(runtime);\n  logger.log(`[Anthropic] Using ${modelType} model: ${modelName}`);\n\n  try {\n    // Check if this is a reflection schema request (has specific format)\n    const isReflection = !!(params.schema?.facts && params.schema.relationships);\n\n    // Build a prompt that asks for JSON output\n    let jsonPrompt = params.prompt;\n\n    // Don't modify the prompt if it already contains explicit JSON formatting instructions\n    if (!jsonPrompt.includes('```json') && !jsonPrompt.includes('respond with valid JSON')) {\n      jsonPrompt +=\n        '\\nPlease respond with valid JSON only, without any explanations, markdown formatting, or additional text.';\n    }\n\n    let systemPrompt = runtime.character.system\n      ? `${runtime.character.system}\\nYou must respond with valid JSON only.`\n      : 'You must respond with valid JSON only.';\n\n    // For reflection schemas, we need a more specific instruction\n    if (isReflection) {\n      systemPrompt +=\n        \" Ensure your response includes 'thought', 'facts', and 'relationships' properties exactly as specified in the prompt.\";\n    } else {\n      systemPrompt += ' No markdown, no code blocks, no explanation text.';\n    }\n\n    // Generate text response that should contain JSON\n    const { text, usage } = await generateText({\n      model: anthropic(modelName),\n      prompt: jsonPrompt,\n      system: systemPrompt,\n      temperature: params.temperature || 0.2, // Lower temperature for more predictable structured output\n    });\n\n    if (usage) {\n      emitModelUsageEvent(runtime, modelType as ModelTypeName, params.prompt, usage);\n    }\n\n    // Extract and parse JSON from the response\n    try {\n      logger.debug('Attempting to parse response from Anthropic model');\n      const jsonObject = extractAndParseJSON(text);\n\n      // Ensure reflection schema has all required properties\n      const processedObject = ensureReflectionProperties(jsonObject, isReflection);\n\n      return processedObject as JSONValue;\n    } catch (parseError) {\n      logger.error(`Failed to parse JSON from Anthropic response: ${parseError}`);\n      logger.error(`Raw response: ${text}`);\n      throw new Error('Invalid JSON returned from Anthropic model');\n    }\n  } catch (error) {\n    logger.error(`Error generating object: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * OBJECT_SMALL model handler\n */\nexport async function handleObjectSmall(\n  runtime: IAgentRuntime,\n  params: ObjectGenerationParams\n): Promise<JSONValue> {\n  return generateObjectByModelType(runtime, params, ModelType.OBJECT_SMALL, getSmallModel);\n}\n\n/**\n * OBJECT_LARGE model handler\n */\nexport async function handleObjectLarge(\n  runtime: IAgentRuntime,\n  params: ObjectGenerationParams\n): Promise<JSONValue> {\n  return generateObjectByModelType(runtime, params, ModelType.OBJECT_LARGE, getLargeModel);\n}\n",
    "import { logger } from '@elizaos/core';\nimport { jsonrepair } from 'jsonrepair';\n\n/**\n * Type definition for a code block placeholder\n */\ninterface CodeBlockPlaceholder {\n  placeholder: string;\n  content: string;\n}\n\n/**\n * Type for reconstructed response\n */\nexport interface ReconstructedResponse {\n  type: 'reconstructed_response';\n  thought?: string;\n  message?: string;\n  codeBlocks?: Array<{\n    language: string;\n    code: string;\n  }>;\n}\n\n/**\n * Type for reflection schema response\n */\nexport interface ReflectionResponse {\n  thought: string;\n  facts: unknown[];\n  relationships: unknown[];\n  rawContent: string;\n}\n\n/**\n * Type for unstructured response\n */\nexport interface UnstructuredResponse {\n  type: 'unstructured_response';\n  content: string;\n}\n\n/**\n * Type for JSON extraction result\n */\nexport type ExtractedJSON =\n  | Record<string, unknown>\n  | ReconstructedResponse\n  | ReflectionResponse\n  | UnstructuredResponse;\n\n/**\n * Helper function to ensure reflection response has all required properties\n */\nexport const ensureReflectionProperties = (\n  obj: ExtractedJSON,\n  isReflection: boolean\n): ExtractedJSON => {\n  // Only process if it's a reflection schema request\n  if (!isReflection) return obj;\n\n  // Check if it's an object with potentially missing reflection properties\n  if (obj !== null && typeof obj === 'object') {\n    // Create a new object with required properties\n    return {\n      ...obj,\n      thought: 'thought' in obj ? obj.thought || '' : '',\n      facts: 'facts' in obj ? obj.facts || [] : [],\n      relationships: 'relationships' in obj ? obj.relationships || [] : [],\n    };\n  }\n\n  return obj;\n};\n\n/**\n * Enhanced function to extract and parse JSON from LLM responses\n * Handles various response formats including mixed markdown and JSON with code blocks\n */\nexport const extractAndParseJSON = (text: string): ExtractedJSON => {\n  try {\n    // First attempt: Try direct JSON parsing\n    return JSON.parse(text);\n  } catch (initialError) {\n    logger.debug('Initial JSON parse failed, attempting alternative extraction methods');\n\n    // Try JSONRepair first\n    try {\n      const repaired = jsonrepair(text);\n      return JSON.parse(repaired);\n    } catch (repairError) {\n      logger.debug('JSONRepair failed, proceeding with manual extraction methods');\n    }\n\n    // Check if we have a valid JSON structure with embedded code blocks\n    const isJsonWithCodeBlocks =\n      text.trim().startsWith('{') && text.trim().endsWith('}') && text.includes('```');\n\n    if (isJsonWithCodeBlocks) {\n      // Replace code blocks with escaped versions to preserve them in the JSON\n      try {\n        // First, try to preserve the code blocks by temporarily replacing them\n        const codeBlockPlaceholders: CodeBlockPlaceholder[] = [];\n        let placeholderCounter = 0;\n        const textWithPlaceholders = text.replace(\n          /```(\\w*)\\n([\\s\\S]*?)```/g,\n          (match, language, code) => {\n            const placeholder = `__CODE_BLOCK_${placeholderCounter++}__`;\n            codeBlockPlaceholders.push({\n              placeholder,\n              content: `\\`\\`\\`${language}\\n${code}\\`\\`\\``,\n            });\n            return placeholder;\n          }\n        );\n\n        // Try parsing with placeholders\n        let parsed: Record<string, unknown>;\n        try {\n          // Try JSONRepair first\n          const repaired = jsonrepair(textWithPlaceholders);\n          parsed = JSON.parse(repaired);\n        } catch (e) {\n          // If JSONRepair fails, try direct parsing\n          parsed = JSON.parse(textWithPlaceholders);\n        }\n\n        // Restore code blocks in the parsed object\n        const restoreCodeBlocks = (obj: unknown): unknown => {\n          if (typeof obj === 'string') {\n            let result = obj;\n            for (const { placeholder, content } of codeBlockPlaceholders) {\n              result = result.replace(placeholder, content);\n            }\n            return result;\n          } else if (Array.isArray(obj)) {\n            return obj.map((item) => restoreCodeBlocks(item));\n          } else if (obj !== null && typeof obj === 'object') {\n            const result: Record<string, unknown> = {};\n            for (const [key, value] of Object.entries(obj as Record<string, unknown>)) {\n              result[key] = restoreCodeBlocks(value);\n            }\n            return result;\n          }\n          return obj;\n        };\n\n        return restoreCodeBlocks(parsed) as ExtractedJSON;\n      } catch (codeBlockError) {\n        logger.debug('Code block preservation failed, continuing with other methods');\n      }\n    }\n\n    // Try to extract JSON from code blocks\n    const extractFromCodeBlocks = (text: string): string | null => {\n      // First priority: explicit JSON code blocks\n      const jsonBlockRegex = /```json\\s*([\\s\\S]*?)\\s*```/;\n      const jsonMatch = text.match(jsonBlockRegex);\n      if (jsonMatch && jsonMatch[1]) {\n        return jsonMatch[1].trim();\n      }\n\n      // Second priority: any code block that contains JSON-like content\n      const anyBlockRegex = /```(?:\\w*)\\s*([\\s\\S]*?)\\s*```/g;\n      let match;\n      while ((match = anyBlockRegex.exec(text)) !== null) {\n        const blockContent = match[1].trim();\n        if (blockContent.startsWith('{') && blockContent.endsWith('}')) {\n          return blockContent;\n        }\n      }\n\n      return null;\n    };\n\n    const extractedFromCodeBlock = extractFromCodeBlocks(text);\n    if (extractedFromCodeBlock) {\n      try {\n        // Try parsing the extracted content\n        return JSON.parse(extractedFromCodeBlock);\n      } catch (blockParseError) {\n        try {\n          // Try with JSONRepair\n          const repaired = jsonrepair(extractedFromCodeBlock);\n          return JSON.parse(repaired);\n        } catch (blockRepairError) {\n          logger.debug('Failed to parse JSON from code block after repair');\n        }\n      }\n    }\n\n    // Look for JSON structure outside of code blocks\n    const extractJSON = (text: string): string | null => {\n      // Try to find JSON-like content in the text\n      const jsonContentRegex = /(^|\\n)\\s*(\\{[\\s\\S]*\\})\\s*($|\\n)/;\n      const contentMatch = text.match(jsonContentRegex);\n\n      if (contentMatch && contentMatch[2]) {\n        return contentMatch[2].trim();\n      }\n\n      // If no direct match, try to find the largest JSON-like structure\n      const jsonPattern = /\\{[\\s\\S]*?\\}/g;\n      const jsonMatches = text.match(jsonPattern);\n\n      if (jsonMatches && jsonMatches.length > 0) {\n        // Sort matches by length (descending) to try the largest JSON-like structure first\n        return [...jsonMatches].sort((a, b) => b.length - a.length)[0];\n      }\n\n      return null;\n    };\n\n    const extractedJSON = extractJSON(text);\n    if (extractedJSON) {\n      try {\n        // Try parsing the extracted JSON\n        return JSON.parse(extractedJSON);\n      } catch (extractParseError) {\n        try {\n          // Try with JSONRepair\n          const repaired = jsonrepair(extractedJSON);\n          return JSON.parse(repaired);\n        } catch (extractRepairError) {\n          logger.debug('Failed to parse JSON after extraction and repair');\n        }\n      }\n    }\n\n    // Try to manually extract a \"thought\"/\"message\" structure which is common\n    const manuallyExtractStructure = (\n      text: string\n    ): ReconstructedResponse | ReflectionResponse | null => {\n      // Extract thought/message pattern if present\n      const thoughtPattern = /\"thought\"\\s*:\\s*\"([^\"]*?)(?:\"|$)/;\n      const messagePattern = /\"message\"\\s*:\\s*\"([^\"]*?)(?:\"|$)/;\n\n      const thoughtMatch = text.match(thoughtPattern);\n      const messageMatch = text.match(messagePattern);\n\n      if (thoughtMatch || messageMatch) {\n        const extractedContent: ReconstructedResponse = {\n          type: 'reconstructed_response',\n        };\n\n        if (thoughtMatch) {\n          extractedContent.thought = thoughtMatch[1].replace(/\\\\n/g, '\\n');\n        }\n\n        if (messageMatch) {\n          extractedContent.message = messageMatch[1].replace(/\\\\n/g, '\\n');\n        } else {\n          // If no message was found but we have a thought, try to use the rest of the content as message\n          let remainingContent = text;\n          if (thoughtMatch) {\n            // Remove the thought part from the content\n            remainingContent = remainingContent.replace(thoughtPattern, '');\n          }\n\n          // Look for code blocks in the remaining content\n          const codeBlocks: Array<{ language: string; code: string }> = [];\n          const codeBlockRegex = /```([\\w]*)\\n([\\s\\S]*?)```/g;\n          let match;\n\n          while ((match = codeBlockRegex.exec(remainingContent)) !== null) {\n            codeBlocks.push({\n              language: match[1] || 'text',\n              code: match[2].trim(),\n            });\n          }\n\n          if (codeBlocks.length > 0) {\n            extractedContent.codeBlocks = codeBlocks;\n            // Remove code blocks from the remaining content\n            remainingContent = remainingContent.replace(codeBlockRegex, '');\n          }\n\n          // Use the cleaned remaining content as message\n          extractedContent.message = remainingContent.trim();\n        }\n\n        return extractedContent;\n      }\n\n      // For reflection schema-like structure\n      if (text.includes('thought') || text.includes('facts') || text.includes('relationships')) {\n        logger.debug('Attempting to extract reflection schema components');\n\n        const result: ReflectionResponse = {\n          thought: '',\n          facts: [],\n          relationships: [],\n          rawContent: text,\n        };\n\n        // Try to extract thought\n        const thoughtMatch = text.match(/thought[\"\\s:]+([^\"{}[\\],]+)/i);\n        if (thoughtMatch) {\n          result.thought = thoughtMatch[1].trim();\n        }\n\n        return result;\n      }\n\n      return null;\n    };\n\n    const manuallyExtracted = manuallyExtractStructure(text);\n    if (manuallyExtracted) {\n      return manuallyExtracted;\n    }\n\n    // Last resort: Return a structured object with the raw text\n    logger.debug(\n      'All JSON extraction methods failed, returning structured object with raw content'\n    );\n    return {\n      type: 'unstructured_response',\n      content: text,\n    };\n  }\n};\n",
    "export class JSONRepairError extends Error {\n  constructor(message, position) {\n    super(`${message} at position ${position}`);\n    this.position = position;\n  }\n}\n//# sourceMappingURL=JSONRepairError.js.map",
    "const codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeNonBreakingSpace = 0xa0;\nconst codeEnQuad = 0x2000;\nconst codeHairSpace = 0x200a;\nconst codeNarrowNoBreakSpace = 0x202f;\nconst codeMediumMathematicalSpace = 0x205f;\nconst codeIdeographicSpace = 0x3000;\nexport function isHex(char) {\n  return /^[0-9A-Fa-f]$/.test(char);\n}\nexport function isDigit(char) {\n  return char >= '0' && char <= '9';\n}\nexport function isValidStringCharacter(char) {\n  // note that the valid range is between \\u{0020} and \\u{10ffff},\n  // but in JavaScript it is not possible to create a code point larger than\n  // \\u{10ffff}, so there is no need to test for that here.\n  return char >= '\\u0020';\n}\nexport function isDelimiter(char) {\n  return ',:[]/{}()\\n+'.includes(char);\n}\nexport function isFunctionNameCharStart(char) {\n  return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$';\n}\nexport function isFunctionNameChar(char) {\n  return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$' || char >= '0' && char <= '9';\n}\n\n// matches \"https://\" and other schemas\nexport const regexUrlStart = /^(http|https|ftp|mailto|file|data|irc):\\/\\/$/;\n\n// matches all valid URL characters EXCEPT \"[\", \"]\", and \",\", since that are important JSON delimiters\nexport const regexUrlChar = /^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;\nexport function isUnquotedStringDelimiter(char) {\n  return ',[]/{}\\n+'.includes(char);\n}\nexport function isStartOfValue(char) {\n  return isQuote(char) || regexStartOfValue.test(char);\n}\n\n// alpha, number, minus, or opening bracket or brace\nconst regexStartOfValue = /^[[{\\w-]$/;\nexport function isControlCharacter(char) {\n  return char === '\\n' || char === '\\r' || char === '\\t' || char === '\\b' || char === '\\f';\n}\n/**\n * Check if the given character is a whitespace character like space, tab, or\n * newline\n */\nexport function isWhitespace(text, index) {\n  const code = text.charCodeAt(index);\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\n\n/**\n * Check if the given character is a whitespace character like space or tab,\n * but NOT a newline\n */\nexport function isWhitespaceExceptNewline(text, index) {\n  const code = text.charCodeAt(index);\n  return code === codeSpace || code === codeTab || code === codeReturn;\n}\n\n/**\n * Check if the given character is a special whitespace character, some\n * unicode variant\n */\nexport function isSpecialWhitespace(text, index) {\n  const code = text.charCodeAt(index);\n  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;\n}\n\n/**\n * Test whether the given character is a quote or double quote character.\n * Also tests for special variants of quotes.\n */\nexport function isQuote(char) {\n  // the first check double quotes, since that occurs most often\n  return isDoubleQuoteLike(char) || isSingleQuoteLike(char);\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Also tests for special variants of double quotes.\n */\nexport function isDoubleQuoteLike(char) {\n  return char === '\"' || char === '\\u201c' || char === '\\u201d';\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Does NOT test for special variants of double quotes.\n */\nexport function isDoubleQuote(char) {\n  return char === '\"';\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Also tests for special variants of single quotes.\n */\nexport function isSingleQuoteLike(char) {\n  return char === \"'\" || char === '\\u2018' || char === '\\u2019' || char === '\\u0060' || char === '\\u00b4';\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Does NOT test for special variants of single quotes.\n */\nexport function isSingleQuote(char) {\n  return char === \"'\";\n}\n\n/**\n * Strip last occurrence of textToStrip from text\n */\nexport function stripLastOccurrence(text, textToStrip) {\n  let stripRemainingText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const index = text.lastIndexOf(textToStrip);\n  return index !== -1 ? text.substring(0, index) + (stripRemainingText ? '' : text.substring(index + 1)) : text;\n}\nexport function insertBeforeLastWhitespace(text, textToInsert) {\n  let index = text.length;\n  if (!isWhitespace(text, index - 1)) {\n    // no trailing whitespaces\n    return text + textToInsert;\n  }\n  while (isWhitespace(text, index - 1)) {\n    index--;\n  }\n  return text.substring(0, index) + textToInsert + text.substring(index);\n}\nexport function removeAtIndex(text, start, count) {\n  return text.substring(0, start) + text.substring(start + count);\n}\n\n/**\n * Test whether a string ends with a newline or comma character and optional whitespace\n */\nexport function endsWithCommaOrNewline(text) {\n  return /[,\\n][ \\t\\r]*$/.test(text);\n}\n//# sourceMappingURL=stringUtils.js.map",
    "import { JSONRepairError } from '../utils/JSONRepairError.js';\nimport { endsWithCommaOrNewline, insertBeforeLastWhitespace, isControlCharacter, isDelimiter, isDigit, isDoubleQuote, isDoubleQuoteLike, isFunctionNameChar, isFunctionNameCharStart, isHex, isQuote, isSingleQuote, isSingleQuoteLike, isSpecialWhitespace, isStartOfValue, isUnquotedStringDelimiter, isValidStringCharacter, isWhitespace, isWhitespaceExceptNewline, regexUrlChar, regexUrlStart, removeAtIndex, stripLastOccurrence } from '../utils/stringUtils.js';\nconst controlCharacters = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n};\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     try {\n *       const json = \"{name: 'John'}\"\n *       const repaired = jsonrepair(json)\n *       console.log(repaired)\n *       // '{\"name\": \"John\"}'\n *     } catch (err) {\n *       console.error(err)\n *     }\n *\n */\nexport function jsonrepair(text) {\n  let i = 0; // current index in text\n  let output = ''; // generated output\n\n  parseMarkdownCodeBlock(['```', '[```', '{```']);\n  const processed = parseValue();\n  if (!processed) {\n    throwUnexpectedEnd();\n  }\n  parseMarkdownCodeBlock(['```', '```]', '```}']);\n  const processedComma = parseCharacter(',');\n  if (processedComma) {\n    parseWhitespaceAndSkipComments();\n  }\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n    if (!processedComma) {\n      // repair missing comma\n      output = insertBeforeLastWhitespace(output, ',');\n    }\n    parseNewlineDelimitedJSON();\n  } else if (processedComma) {\n    // repair: remove trailing comma\n    output = stripLastOccurrence(output, ',');\n  }\n\n  // repair redundant end quotes\n  while (text[i] === '}' || text[i] === ']') {\n    i++;\n    parseWhitespaceAndSkipComments();\n  }\n  if (i >= text.length) {\n    // reached the end of the document properly\n    return output;\n  }\n  throwUnexpectedCharacter();\n  function parseValue() {\n    parseWhitespaceAndSkipComments();\n    const processed = parseObject() || parseArray() || parseString() || parseNumber() || parseKeywords() || parseUnquotedString(false) || parseRegex();\n    parseWhitespaceAndSkipComments();\n    return processed;\n  }\n  function parseWhitespaceAndSkipComments() {\n    let skipNewline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const start = i;\n    let changed = parseWhitespace(skipNewline);\n    do {\n      changed = parseComment();\n      if (changed) {\n        changed = parseWhitespace(skipNewline);\n      }\n    } while (changed);\n    return i > start;\n  }\n  function parseWhitespace(skipNewline) {\n    const _isWhiteSpace = skipNewline ? isWhitespace : isWhitespaceExceptNewline;\n    let whitespace = '';\n    while (true) {\n      if (_isWhiteSpace(text, i)) {\n        whitespace += text[i];\n        i++;\n      } else if (isSpecialWhitespace(text, i)) {\n        // repair special whitespace\n        whitespace += ' ';\n        i++;\n      } else {\n        break;\n      }\n    }\n    if (whitespace.length > 0) {\n      output += whitespace;\n      return true;\n    }\n    return false;\n  }\n  function parseComment() {\n    // find a block comment '/* ... */'\n    if (text[i] === '/' && text[i + 1] === '*') {\n      // repair block comment by skipping it\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\n        i++;\n      }\n      i += 2;\n      return true;\n    }\n\n    // find a line comment '// ...'\n    if (text[i] === '/' && text[i + 1] === '/') {\n      // repair line comment by skipping it\n      while (i < text.length && text[i] !== '\\n') {\n        i++;\n      }\n      return true;\n    }\n    return false;\n  }\n  function parseMarkdownCodeBlock(blocks) {\n    // find and skip over a Markdown fenced code block:\n    //     ``` ... ```\n    // or\n    //     ```json ... ```\n    if (skipMarkdownCodeBlock(blocks)) {\n      if (isFunctionNameCharStart(text[i])) {\n        // strip the optional language specifier like \"json\"\n        while (i < text.length && isFunctionNameChar(text[i])) {\n          i++;\n        }\n      }\n      parseWhitespaceAndSkipComments();\n      return true;\n    }\n    return false;\n  }\n  function skipMarkdownCodeBlock(blocks) {\n    parseWhitespace(true);\n    for (const block of blocks) {\n      const end = i + block.length;\n      if (text.slice(i, end) === block) {\n        i = end;\n        return true;\n      }\n    }\n    return false;\n  }\n  function parseCharacter(char) {\n    if (text[i] === char) {\n      output += text[i];\n      i++;\n      return true;\n    }\n    return false;\n  }\n  function skipCharacter(char) {\n    if (text[i] === char) {\n      i++;\n      return true;\n    }\n    return false;\n  }\n  function skipEscapeCharacter() {\n    return skipCharacter('\\\\');\n  }\n\n  /**\n   * Skip ellipsis like \"[1,2,3,...]\" or \"[1,2,3,...,9]\" or \"[...,7,8,9]\"\n   * or a similar construct in objects.\n   */\n  function skipEllipsis() {\n    parseWhitespaceAndSkipComments();\n    if (text[i] === '.' && text[i + 1] === '.' && text[i + 2] === '.') {\n      // repair: remove the ellipsis (three dots) and optionally a comma\n      i += 3;\n      parseWhitespaceAndSkipComments();\n      skipCharacter(',');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse an object like '{\"key\": \"value\"}'\n   */\n  function parseObject() {\n    if (text[i] === '{') {\n      output += '{';\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: skip leading comma like in {, message: \"hi\"}\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments();\n      }\n      let initial = true;\n      while (i < text.length && text[i] !== '}') {\n        let processedComma;\n        if (!initial) {\n          processedComma = parseCharacter(',');\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',');\n          }\n          parseWhitespaceAndSkipComments();\n        } else {\n          processedComma = true;\n          initial = false;\n        }\n        skipEllipsis();\n        const processedKey = parseString() || parseUnquotedString(true);\n        if (!processedKey) {\n          if (text[i] === '}' || text[i] === '{' || text[i] === ']' || text[i] === '[' || text[i] === undefined) {\n            // repair trailing comma\n            output = stripLastOccurrence(output, ',');\n          } else {\n            throwObjectKeyExpected();\n          }\n          break;\n        }\n        parseWhitespaceAndSkipComments();\n        const processedColon = parseCharacter(':');\n        const truncatedText = i >= text.length;\n        if (!processedColon) {\n          if (isStartOfValue(text[i]) || truncatedText) {\n            // repair missing colon\n            output = insertBeforeLastWhitespace(output, ':');\n          } else {\n            throwColonExpected();\n          }\n        }\n        const processedValue = parseValue();\n        if (!processedValue) {\n          if (processedColon || truncatedText) {\n            // repair missing object value\n            output += 'null';\n          } else {\n            throwColonExpected();\n          }\n        }\n      }\n      if (text[i] === '}') {\n        output += '}';\n        i++;\n      } else {\n        // repair missing end bracket\n        output = insertBeforeLastWhitespace(output, '}');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse an array like '[\"item1\", \"item2\", ...]'\n   */\n  function parseArray() {\n    if (text[i] === '[') {\n      output += '[';\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: skip leading comma like in [,1,2,3]\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments();\n      }\n      let initial = true;\n      while (i < text.length && text[i] !== ']') {\n        if (!initial) {\n          const processedComma = parseCharacter(',');\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',');\n          }\n        } else {\n          initial = false;\n        }\n        skipEllipsis();\n        const processedValue = parseValue();\n        if (!processedValue) {\n          // repair trailing comma\n          output = stripLastOccurrence(output, ',');\n          break;\n        }\n      }\n      if (text[i] === ']') {\n        output += ']';\n        i++;\n      } else {\n        // repair missing closing array bracket\n        output = insertBeforeLastWhitespace(output, ']');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse and repair Newline Delimited JSON (NDJSON):\n   * multiple JSON objects separated by a newline character\n   */\n  function parseNewlineDelimitedJSON() {\n    // repair NDJSON\n    let initial = true;\n    let processedValue = true;\n    while (processedValue) {\n      if (!initial) {\n        // parse optional comma, insert when missing\n        const processedComma = parseCharacter(',');\n        if (!processedComma) {\n          // repair: add missing comma\n          output = insertBeforeLastWhitespace(output, ',');\n        }\n      } else {\n        initial = false;\n      }\n      processedValue = parseValue();\n    }\n    if (!processedValue) {\n      // repair: remove trailing comma\n      output = stripLastOccurrence(output, ',');\n    }\n\n    // repair: wrap the output inside array brackets\n    output = `[\\n${output}\\n]`;\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there, or stopping at a\n   *   stop index detected in the first iteration.\n   */\n  function parseString() {\n    let stopAtDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let stopAtIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let skipEscapeChars = text[i] === '\\\\';\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++;\n      skipEscapeChars = true;\n    }\n    if (isQuote(text[i])) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(text[i]) ? isDoubleQuote : isSingleQuote(text[i]) ? isSingleQuote : isSingleQuoteLike(text[i]) ? isSingleQuoteLike : isDoubleQuoteLike;\n      const iBefore = i;\n      const oBefore = output.length;\n      let str = '\"';\n      i++;\n      while (true) {\n        if (i >= text.length) {\n          // end of text, we are missing an end quote\n\n          const iPrev = prevNonWhitespaceIndex(i - 1);\n          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {\n            // if the text ends with a delimiter, like [\"hello],\n            // so the missing end quote should be inserted before this delimiter\n            // retry parsing the string, stopping at the first next delimiter\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(true);\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          return true;\n        }\n        if (i === stopAtIndex) {\n          // use the stop index detected in the first iteration, and repair end quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          return true;\n        }\n        if (isEndQuote(text[i])) {\n          // end quote\n          // let us check what is before and after the quote to verify whether this is a legit end quote\n          const iQuote = i;\n          const oQuote = str.length;\n          str += '\"';\n          i++;\n          output += str;\n          parseWhitespaceAndSkipComments(false);\n          if (stopAtDelimiter || i >= text.length || isDelimiter(text[i]) || isQuote(text[i]) || isDigit(text[i])) {\n            // The quote is followed by the end of the text, a delimiter,\n            // or a next value. So the quote is indeed the end of the string.\n            parseConcatenatedString();\n            return true;\n          }\n          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1);\n          const prevChar = text.charAt(iPrevChar);\n          if (prevChar === ',') {\n            // A comma followed by a quote, like '{\"a\":\"b,c,\"d\":\"e\"}'.\n            // We assume that the quote is a start quote, and that the end quote\n            // should have been located right before the comma but is missing.\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(false, iPrevChar);\n          }\n          if (isDelimiter(prevChar)) {\n            // This is not the right end quote: it is preceded by a delimiter,\n            // and NOT followed by a delimiter. So, there is an end quote missing\n            // parse the string again and then stop at the first next delimiter\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(true);\n          }\n\n          // revert to right after the quote but before any whitespace, and continue parsing the string\n          output = output.substring(0, oBefore);\n          i = iQuote + 1;\n\n          // repair unescaped quote\n          str = `${str.substring(0, oQuote)}\\\\${str.substring(oQuote)}`;\n        } else if (stopAtDelimiter && isUnquotedStringDelimiter(text[i])) {\n          // we're in the mode to stop the string at the first delimiter\n          // because there is an end quote missing\n\n          // test start of an url like \"https://...\" (this would be parsed as a comment)\n          if (text[i - 1] === ':' && regexUrlStart.test(text.substring(iBefore + 1, i + 2))) {\n            while (i < text.length && regexUrlChar.test(text[i])) {\n              str += text[i];\n              i++;\n            }\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          parseConcatenatedString();\n          return true;\n        } else if (text[i] === '\\\\') {\n          // handle escaped content like \\n or \\u2605\n          const char = text.charAt(i + 1);\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            str += text.slice(i, i + 2);\n            i += 2;\n          } else if (char === 'u') {\n            let j = 2;\n            while (j < 6 && isHex(text[i + j])) {\n              j++;\n            }\n            if (j === 6) {\n              str += text.slice(i, i + 6);\n              i += 6;\n            } else if (i + j >= text.length) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i = text.length;\n            } else {\n              throwInvalidUnicodeCharacter();\n            }\n          } else {\n            // repair invalid escape character: remove it\n            str += char;\n            i += 2;\n          }\n        } else {\n          // handle regular characters\n          const char = text.charAt(i);\n          if (char === '\"' && text[i - 1] !== '\\\\') {\n            // repair unescaped double quote\n            str += `\\\\${char}`;\n            i++;\n          } else if (isControlCharacter(char)) {\n            // unescaped control character\n            str += controlCharacters[char];\n            i++;\n          } else {\n            if (!isValidStringCharacter(char)) {\n              throwInvalidCharacter(char);\n            }\n            str += char;\n            i++;\n          }\n        }\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter();\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString() {\n    let processed = false;\n    parseWhitespaceAndSkipComments();\n    while (text[i] === '+') {\n      processed = true;\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: remove the end quote of the first string\n      output = stripLastOccurrence(output, '\"', true);\n      const start = output.length;\n      const parsedStr = parseString();\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output = removeAtIndex(output, start, 1);\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output = insertBeforeLastWhitespace(output, '\"');\n      }\n    }\n    return processed;\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber() {\n    const start = i;\n    if (text[i] === '-') {\n      i++;\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text[i])) {\n        i = start;\n        return false;\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(text[i])) {\n      i++;\n    }\n    if (text[i] === '.') {\n      i++;\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text[i])) {\n        i = start;\n        return false;\n      }\n      while (isDigit(text[i])) {\n        i++;\n      }\n    }\n    if (text[i] === 'e' || text[i] === 'E') {\n      i++;\n      if (text[i] === '-' || text[i] === '+') {\n        i++;\n      }\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text[i])) {\n        i = start;\n        return false;\n      }\n      while (isDigit(text[i])) {\n        i++;\n      }\n    }\n\n    // if we're not at the end of the number by this point, allow this to be parsed as another type\n    if (!atEndOfNumber()) {\n      i = start;\n      return false;\n    }\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = text.slice(start, i);\n      const hasInvalidLeadingZero = /^0\\d/.test(num);\n      output += hasInvalidLeadingZero ? `\"${num}\"` : num;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords() {\n    return parseKeyword('true', 'true') || parseKeyword('false', 'false') || parseKeyword('null', 'null') ||\n    // repair Python keywords True, False, None\n    parseKeyword('True', 'true') || parseKeyword('False', 'false') || parseKeyword('None', 'null');\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      output += value;\n      i += name.length;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Repair an unquoted string by adding quotes around it\n   * Repair a MongoDB function call like NumberLong(\"2\")\n   * Repair a JSONP function call like callback({...});\n   */\n  function parseUnquotedString(isKey) {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    // also, note that we allow strings to contain a slash / in order to support repairing regular expressions\n    const start = i;\n    if (isFunctionNameCharStart(text[i])) {\n      while (i < text.length && isFunctionNameChar(text[i])) {\n        i++;\n      }\n      let j = i;\n      while (isWhitespace(text, j)) {\n        j++;\n      }\n      if (text[j] === '(') {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        i = j + 1;\n        parseValue();\n        if (text[i] === ')') {\n          // repair: skip close bracket of function call\n          i++;\n          if (text[i] === ';') {\n            // repair: skip semicolon after JSONP call\n            i++;\n          }\n        }\n        return true;\n      }\n    }\n    while (i < text.length && !isUnquotedStringDelimiter(text[i]) && !isQuote(text[i]) && (!isKey || text[i] !== ':')) {\n      i++;\n    }\n\n    // test start of an url like \"https://...\" (this would be parsed as a comment)\n    if (text[i - 1] === ':' && regexUrlStart.test(text.substring(start, i + 2))) {\n      while (i < text.length && regexUrlChar.test(text[i])) {\n        i++;\n      }\n    }\n    if (i > start) {\n      // repair unquoted string\n      // also, repair undefined into null\n\n      // first, go back to prevent getting trailing whitespaces in the string\n      while (isWhitespace(text, i - 1) && i > 0) {\n        i--;\n      }\n      const symbol = text.slice(start, i);\n      output += symbol === 'undefined' ? 'null' : JSON.stringify(symbol);\n      if (text[i] === '\"') {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++;\n      }\n      return true;\n    }\n  }\n  function parseRegex() {\n    if (text[i] === '/') {\n      const start = i;\n      i++;\n      while (i < text.length && (text[i] !== '/' || text[i - 1] === '\\\\')) {\n        i++;\n      }\n      i++;\n      output += `\"${text.substring(start, i)}\"`;\n      return true;\n    }\n  }\n  function prevNonWhitespaceIndex(start) {\n    let prev = start;\n    while (prev > 0 && isWhitespace(text, prev)) {\n      prev--;\n    }\n    return prev;\n  }\n  function atEndOfNumber() {\n    return i >= text.length || isDelimiter(text[i]) || isWhitespace(text, i);\n  }\n  function repairNumberEndingWithNumericSymbol(start) {\n    // repair numbers cut off at the end\n    // this will only be called when we end after a '.', '-', or 'e' and does not\n    // change the number more than it needs to make it valid JSON\n    output += `${text.slice(start, i)}0`;\n  }\n  function throwInvalidCharacter(char) {\n    throw new JSONRepairError(`Invalid character ${JSON.stringify(char)}`, i);\n  }\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError(`Unexpected character ${JSON.stringify(text[i])}`, i);\n  }\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', text.length);\n  }\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i);\n  }\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i);\n  }\n  function throwInvalidUnicodeCharacter() {\n    const chars = text.slice(i, i + 6);\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i);\n  }\n}\nfunction atEndOfBlockComment(text, i) {\n  return text[i] === '*' && text[i + 1] === '/';\n}\n//# sourceMappingURL=jsonrepair.js.map"
  ],
  "mappings": "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",
  "debugId": "422A305E8D5804A164756E2164756E21",
  "names": []
}