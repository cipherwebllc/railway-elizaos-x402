{
  "version": 3,
  "sources": ["../src/providers/coinmarketcapProvider.ts", "../src/services/analyticsService.ts", "../src/utils/technicalAnalysis.ts", "../src/utils/messageUtils.ts", "../src/utils/dateFilter.ts", "../src/providers/analytics.ts", "../src/providers/marketData.ts", "../src/providers/technicalIndicators.ts", "../src/providers/historicalData.ts", "../src/services/marketDataService.ts", "../src/providers/birdeyeProvider.ts", "../src/services/technicalAnalysisService.ts", "../src/index.ts"],
  "sourcesContent": [
    "import type { IAgentRuntime } from '@elizaos/core';\nimport type {\n    TokenPriceData,\n    HistoricalPriceData,\n    MarketAnalytics,\n    AccountAnalytics\n} from '../interfaces/types';\n\n/**\n * CoinMarketCap Data Provider\n * Integrates with CoinMarketCap API for multi-chain token data\n */\nexport class CoinMarketCapProvider {\n    private runtime: IAgentRuntime;\n    private apiKey: string;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n        this.apiKey = runtime.getSetting('COINMARKETCAP_API_KEY') as string;\n\n        if (!this.apiKey) {\n            throw new Error('CoinMarketCap API key not configured');\n        }\n    }\n\n    /**\n     * Get token price data from CoinMarketCap\n     */\n    async getTokenPrice(tokenAddress: string, chain: string = 'ethereum'): Promise<TokenPriceData | null> {\n        try {\n            const cacheKey = `cmc_price_${tokenAddress}_${chain}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'X-CMC_PRO_API_KEY': this.apiKey,\n                },\n            };\n\n            // For CoinMarketCap, we need to use the token ID or symbol\n            // This is a simplified approach - in practice you'd need a mapping\n            const response = await fetch(\n                `https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/latest?symbol=${tokenAddress}`,\n                options\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const data = await response.json();\n            const tokenData = data?.data?.[tokenAddress.toUpperCase()]?.[0];\n\n            if (!tokenData) {\n                return null;\n            }\n\n            const quote = tokenData.quote?.USD;\n            if (!quote) {\n                return null;\n            }\n\n            const priceData: TokenPriceData = {\n                timestamp: Date.now(),\n                source: 'coinmarketcap',\n                chain: chain,\n                tokenAddress: tokenAddress,\n                symbol: tokenData.symbol,\n                price: quote.price || 0,\n                priceChange24h: quote.volume_change_24h || 0,\n                priceChangePercent24h: quote.percent_change_24h || 0,\n                volume24h: quote.volume_24h || 0,\n                marketCap: quote.market_cap || 0,\n                circulatingSupply: tokenData.circulating_supply,\n                totalSupply: tokenData.total_supply,\n            };\n\n            await this.setCachedData(cacheKey, priceData, 300); // 5 minutes cache\n            return priceData;\n        } catch (error) {\n            console.error('Error fetching token price from CoinMarketCap:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get historical price data from CoinMarketCap\n     */\n    async getHistoricalData(\n        tokenAddress: string,\n        chain: string = 'ethereum',\n        timeframe: string = '1d'\n    ): Promise<HistoricalPriceData[]> {\n        try {\n            const cacheKey = `cmc_historical_${tokenAddress}_${timeframe}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'X-CMC_PRO_API_KEY': this.apiKey,\n                },\n            };\n\n            // Get token ID first\n            const tokenResponse = await fetch(\n                `https://pro-api.coinmarketcap.com/v1/cryptocurrency/map?symbol=${tokenAddress}`,\n                options\n            );\n\n            if (!tokenResponse.ok) {\n                throw new Error(`HTTP error! status: ${tokenResponse.status}`);\n            }\n\n            const tokenData = await tokenResponse.json();\n            const tokenId = tokenData?.data?.[0]?.id;\n\n            if (!tokenId) {\n                return [];\n            }\n\n            // Get historical data\n            const count = this.getDataPointsForTimeframe(timeframe);\n            const interval = this.convertTimeframeToInterval(timeframe);\n\n            const historicalResponse = await fetch(\n                `https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/historical?id=${tokenId}&count=${count}&interval=${interval}`,\n                options\n            );\n\n            if (!historicalResponse.ok) {\n                throw new Error(`HTTP error! status: ${historicalResponse.status}`);\n            }\n\n            const historicalData = await historicalResponse.json();\n            const quotes = historicalData?.data?.quotes || [];\n\n            const historicalPriceData: HistoricalPriceData[] = quotes.map((quote: any) => ({\n                timestamp: new Date(quote.timestamp).getTime(),\n                open: quote.quote.USD.open || 0,\n                high: quote.quote.USD.high || 0,\n                low: quote.quote.USD.low || 0,\n                close: quote.quote.USD.close || 0,\n                volume: quote.quote.USD.volume || 0,\n            }));\n\n            await this.setCachedData(cacheKey, historicalPriceData, 600); // 10 minutes cache\n            return historicalPriceData;\n        } catch (error) {\n            console.error('Error fetching historical data from CoinMarketCap:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Get market data from CoinMarketCap\n     */\n    async getMarketData(chain: string = 'ethereum'): Promise<MarketAnalytics | null> {\n        try {\n            const cacheKey = `cmc_market_${chain}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'X-CMC_PRO_API_KEY': this.apiKey,\n                },\n            };\n\n            // Get global market data\n            const globalResponse = await fetch(\n                'https://pro-api.coinmarketcap.com/v1/global-metrics/quotes/latest',\n                options\n            );\n\n            if (!globalResponse.ok) {\n                throw new Error(`HTTP error! status: ${globalResponse.status}`);\n            }\n\n            const globalData = await globalResponse.json();\n            const globalMetrics = globalData?.data;\n\n            // Get top gainers and losers\n            const gainersResponse = await fetch(\n                'https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?sort=percent_change_24h&sort_dir=desc&limit=10',\n                options\n            );\n\n            const losersResponse = await fetch(\n                'https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?sort=percent_change_24h&sort_dir=asc&limit=10',\n                options\n            );\n\n            const gainersData = await gainersResponse.json();\n            const losersData = await losersResponse.json();\n\n            const topGainers = (gainersData?.data || []).map((token: any) => ({\n                timestamp: Date.now(),\n                source: 'coinmarketcap' as const,\n                chain: token.platform?.slug || 'L1',\n                tokenAddress: token.platform?.token_address || token.slug,\n                symbol: token.symbol,\n                price: token.quote?.USD?.price || 0,\n                priceChange24h: token.quote?.USD?.volume_change_24h || 0,\n                priceChangePercent24h: token.quote?.USD?.percent_change_24h || 0,\n                volume24h: token.quote?.USD?.volume_24h || 0,\n                marketCap: token.quote?.USD?.market_cap || 0,\n            }));\n\n            const topLosers = (losersData?.data || []).map((token: any) => ({\n                timestamp: Date.now(),\n                source: 'coinmarketcap' as const,\n                chain: token.platform?.slug || 'L1',\n                tokenAddress: token.platform?.token_address || token.slug,\n                symbol: token.symbol,\n                price: token.quote?.USD?.price || 0,\n                priceChange24h: token.quote?.USD?.volume_change_24h || 0,\n                priceChangePercent24h: token.quote?.USD?.percent_change_24h || 0,\n                volume24h: token.quote?.USD?.volume_24h || 0,\n                marketCap: token.quote?.USD?.market_cap || 0,\n            }));\n\n            // Get trending tokens (top by volume)\n            const trendingResponse = await fetch(\n                'https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?sort=volume_24h&sort_dir=desc&limit=20',\n                options\n            );\n\n            const trendingData = await trendingResponse.json();\n            const trendingTokens = (trendingData?.data || []).map((token: any) => ({\n                timestamp: Date.now(),\n                source: 'coinmarketcap' as const,\n                chain: token.platform?.slug || 'L1',\n                tokenAddress: token.platform?.token_address || token.slug,\n                symbol: token.symbol,\n                price: token.quote?.USD?.price || 0,\n                priceChange24h: token.quote?.USD?.volume_change_24h || 0,\n                priceChangePercent24h: token.quote?.USD?.percent_change_24h || 0,\n                volume24h: token.quote?.USD?.volume_24h || 0,\n                marketCap: token.quote?.USD?.market_cap || 0,\n            }));\n\n            const marketAnalytics: MarketAnalytics = {\n                marketCap: globalMetrics?.quote?.USD?.total_market_cap || 0,\n                volume24h: globalMetrics?.quote?.USD?.total_volume_24h || 0,\n                dominance: 0, // Would need to calculate for specific chain\n                topGainers,\n                topLosers,\n                trendingTokens,\n                marketSentiment: {\n                    bullish: 0.5, // Placeholder - would need sentiment analysis\n                    bearish: 0.3,\n                    neutral: 0.2,\n                },\n            };\n\n            await this.setCachedData(cacheKey, marketAnalytics, 600); // 10 minutes cache\n            return marketAnalytics;\n        } catch (error) {\n            console.error('Error fetching market data from CoinMarketCap:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get account data from CoinMarketCap\n     * Note: CoinMarketCap doesn't provide account/wallet data\n     * This is a placeholder for consistency\n     */\n    async getAccountData(walletAddress: string, chain: string = 'ethereum'): Promise<AccountAnalytics | null> {\n        // CoinMarketCap doesn't provide account/wallet data\n        // This would need to be implemented using other providers or blockchain APIs\n        console.warn('CoinMarketCap does not provide account data');\n        return null;\n    }\n\n    /**\n     * Convert timeframe to CoinMarketCap interval format\n     */\n    private convertTimeframeToInterval(timeframe: string): string {\n        switch (timeframe) {\n            case '1h': return '1h';\n            case '4h': return '4h';\n            case '1d': return '1d';\n            case '1w': return '1w';\n            case '1m': return '1M';\n            default: return '1d';\n        }\n    }\n\n    /**\n     * Get number of data points for timeframe\n     */\n    private getDataPointsForTimeframe(timeframe: string): number {\n        switch (timeframe) {\n            case '1h': return 168; // 1 week of hourly data\n            case '4h': return 168; // 4 weeks of 4h data\n            case '1d': return 365; // 1 year of daily data\n            case '1w': return 52; // 1 year of weekly data\n            case '1m': return 12; // 1 year of monthly data\n            default: return 30; // 30 days of daily data\n        }\n    }\n\n    /**\n     * Get cached data\n     */\n    private async getCachedData(key: string): Promise<any | null> {\n        try {\n            return await this.runtime.getCache(key);\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * Set cached data\n     */\n    private async setCachedData(key: string, data: any, ttlSeconds: number): Promise<void> {\n        try {\n            await this.runtime.setCache(key, data);\n        } catch (error) {\n            console.error('Failed to cache data:', error);\n        }\n    }\n} ",
    "import type { IAgentRuntime } from '@elizaos/core';\nimport { logger, Service } from '@elizaos/core';\nimport type {\n    ComprehensiveTokenAnalytics,\n    AccountAnalytics,\n    MarketAnalytics,\n    AnalyticsRequest,\n    AnalyticsResponse,\n    TechnicalIndicators\n} from '../interfaces/types';\nimport {\n    calculateMACD,\n    calculateRSI,\n    calculateBollingerBands,\n    calculateVolumeIndicators,\n    generateSignals\n} from '../utils/technicalAnalysis';\n\n/**\n * Main Analytics Service\n * Orchestrates data from multiple providers and provides comprehensive analytics\n */\nexport class AnalyticsService extends Service {\n    private isRunning = false;\n    static serviceType = 'ANALYTICS_SERVICE';\n\n    capabilityDescription = 'Comprehensive analytics service for token and market data analysis';\n\n    constructor(runtime: IAgentRuntime) {\n        super(runtime);\n    }\n\n    /**\n     * Get comprehensive token analytics\n     */\n    async getTokenAnalytics(request: AnalyticsRequest): Promise<AnalyticsResponse> {\n        try {\n            const { tokenAddress, chain = 'solana', timeframe = '1d', includeHistorical = true, includeHolders = true, includeSnipers = true } = request;\n\n            if (!tokenAddress) {\n                return {\n                    success: false,\n                    data: null as any,\n                    timestamp: Date.now(),\n                    source: 'analytics',\n                    error: 'Token address is required'\n                };\n            }\n\n            // Get price data from existing providers\n            const priceData = await this.getTokenPriceFromExistingProviders(tokenAddress, chain);\n            if (!priceData) {\n                return {\n                    success: false,\n                    data: null as any,\n                    timestamp: Date.now(),\n                    source: 'analytics',\n                    error: 'Unable to fetch price data'\n                };\n            }\n\n            // Get historical data for technical analysis\n            let historicalData: any[] = [];\n            console.log('includeHistorical', includeHistorical)\n            if (includeHistorical) {\n                historicalData = await this.getHistoricalDataFromExistingProviders(tokenAddress, chain, timeframe);\n            }\n\n            // Calculate technical indicators\n            const technicalIndicators = await this.calculateTechnicalIndicators(historicalData);\n\n            // Get holder analytics from Codex (if available)\n            let holderAnalytics = null;\n            if (includeHolders) {\n                holderAnalytics = await this.getHolderAnalyticsFromCodex(tokenAddress);\n            }\n\n            // Get sniper analytics from Codex (if available)\n            let sniperAnalytics = null;\n            if (includeSnipers) {\n                sniperAnalytics = await this.getSniperAnalyticsFromCodex(tokenAddress);\n            }\n\n            // Calculate risk assessment\n            const riskAssessment = this.calculateRiskAssessment(\n                technicalIndicators,\n                holderAnalytics,\n                priceData\n            );\n\n            // Generate recommendations\n            const recommendations = this.generateRecommendations(\n                technicalIndicators,\n                holderAnalytics,\n                priceData,\n                historicalData\n            );\n\n            const comprehensiveAnalytics: ComprehensiveTokenAnalytics = {\n                tokenAddress,\n                symbol: priceData.symbol,\n                name: priceData.symbol, // Would need to fetch from metadata\n                chain,\n                price: priceData as any, // Type assertion to handle different source types\n                technicalIndicators,\n                historicalData,\n                holderAnalytics: holderAnalytics || undefined,\n                sniperAnalytics: sniperAnalytics || undefined,\n                marketPosition: {\n                    rank: 0, // Would need to fetch from market data\n                    marketCap: priceData.marketCap,\n                    volume24h: priceData.volume24h,\n                    dominance: 0, // Would need to calculate\n                },\n                riskAssessment,\n                recommendations,\n            };\n\n            return {\n                success: true,\n                data: comprehensiveAnalytics,\n                timestamp: Date.now(),\n                source: 'analytics'\n            };\n\n        } catch (error) {\n            console.error('Error in getTokenAnalytics:', error);\n            return {\n                success: false,\n                data: null as any,\n                timestamp: Date.now(),\n                source: 'analytics',\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        }\n    }\n\n    /**\n     * Get account analytics\n     */\n    async getAccountAnalytics(request: AnalyticsRequest): Promise<AnalyticsResponse> {\n        try {\n            const { walletAddress, chain = 'solana' } = request;\n\n            if (!walletAddress) {\n                return {\n                    success: false,\n                    data: null as any,\n                    timestamp: Date.now(),\n                    source: 'analytics',\n                    error: 'Wallet address is required'\n                };\n            }\n\n            // Get account data from existing Birdeye provider\n            const accountData = await this.getAccountDataFromExistingProviders(walletAddress, chain);\n\n            if (!accountData) {\n                return {\n                    success: false,\n                    data: null as any,\n                    timestamp: Date.now(),\n                    source: 'analytics',\n                    error: 'Unable to fetch account data'\n                };\n            }\n\n            return {\n                success: true,\n                data: accountData,\n                timestamp: Date.now(),\n                source: 'analytics'\n            };\n\n        } catch (error) {\n            console.error('Error in getAccountAnalytics:', error);\n            return {\n                success: false,\n                data: null as any,\n                timestamp: Date.now(),\n                source: 'analytics',\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        }\n    }\n\n    /**\n     * Get market analytics\n     */\n    async getMarketAnalytics(request: AnalyticsRequest): Promise<AnalyticsResponse> {\n        try {\n            const { chain = 'solana' } = request;\n\n            // Get market data from existing providers\n            const marketData = await this.getMarketDataFromExistingProviders(chain);\n\n            if (!marketData) {\n                return {\n                    success: false,\n                    data: null as any,\n                    timestamp: Date.now(),\n                    source: 'analytics',\n                    error: 'Unable to fetch market data'\n                };\n            }\n\n            return {\n                success: true,\n                data: marketData,\n                timestamp: Date.now(),\n                source: 'analytics'\n            };\n\n        } catch (error) {\n            console.error('Error in getMarketAnalytics:', error);\n            return {\n                success: false,\n                data: null as any,\n                timestamp: Date.now(),\n                source: 'analytics',\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        }\n    }\n\n    /**\n     * Get token price from existing providers\n     */\n    private async getTokenPriceFromExistingProviders(tokenAddress: string, chain: string) {\n        try {\n            // Try to get from Birdeye trending data first\n            const birdeyeTokens = await this.runtime.getCache<any[]>('tokens_solana');\n            if (birdeyeTokens) {\n                const token = birdeyeTokens.find(t => t.address === tokenAddress);\n                if (token) {\n                    return {\n                        timestamp: Date.now(),\n                        source: 'birdeye',\n                        chain: chain,\n                        tokenAddress: tokenAddress,\n                        symbol: token.symbol,\n                        price: token.price || 0,\n                        priceChange24h: 0, // Would need to calculate\n                        priceChangePercent24h: token.price24hChangePercent || 0,\n                        volume24h: token.volume24hUSD || 0,\n                        marketCap: token.marketcap || 0,\n                    };\n                }\n            }\n\n            // Try to get from CoinMarketCap data\n            const cmcTokens = await this.runtime.getCache<any[]>('coinmarketcap_sync');\n            if (cmcTokens) {\n                const token = cmcTokens.find(t => t.address === tokenAddress);\n                if (token) {\n                    return {\n                        timestamp: Date.now(),\n                        source: 'coinmarketcap',\n                        chain: chain,\n                        tokenAddress: tokenAddress,\n                        symbol: token.symbol,\n                        price: token.price || 0,\n                        priceChange24h: 0, // Would need to calculate\n                        priceChangePercent24h: token.price24hChangePercent || 0,\n                        volume24h: token.volume24hUSD || 0,\n                        marketCap: token.marketcap || 0,\n                    };\n                }\n            }\n\n            // If not found in cache, try to fetch fresh data from providers\n            console.log(`Token ${tokenAddress} not found in cache, attempting to fetch fresh data...`);\n\n            // Try Birdeye plugin service first for Solana tokens\n            if (chain === 'solana') {\n                try {\n                    const birdeyeService = this.runtime.getService('birdeye') as any;\n                    if (birdeyeService && typeof birdeyeService.getTokenMarketData === 'function') {\n                        console.log(`Attempting to fetch from Birdeye plugin service for ${tokenAddress}...`);\n                        const priceData = await birdeyeService.getTokenMarketData(tokenAddress);\n                        if (priceData && priceData.price > 0) {\n                            console.log(`Successfully fetched price data from Birdeye plugin for ${tokenAddress}: $${priceData.price}`);\n                            return {\n                                timestamp: Date.now(),\n                                source: 'birdeye',\n                                chain: chain,\n                                tokenAddress: tokenAddress,\n                                symbol: 'UNKNOWN', // Birdeye service doesn't provide symbol in getTokenMarketData\n                                price: priceData.price,\n                                priceChange24h: 0, // Would need to calculate\n                                priceChangePercent24h: 0,\n                                volume24h: priceData.volume24h || 0,\n                                marketCap: priceData.marketCap || 0,\n                            };\n                        } else {\n                            console.warn(`Birdeye plugin service returned null or zero price for token ${tokenAddress}`);\n                        }\n                    } else {\n                        console.warn('Birdeye plugin service not available');\n                    }\n                } catch (error) {\n                    console.warn(`Failed to fetch from Birdeye plugin service for ${tokenAddress}:`, error);\n                }\n            }\n\n            // Try CoinMarketCapProvider as fallback\n            try {\n                const cmcApiKey = this.runtime.getSetting('COINMARKETCAP_API_KEY') as string;\n                if (cmcApiKey) {\n                    const { CoinMarketCapProvider } = await import('../providers/coinmarketcapProvider');\n                    const cmcProvider = new CoinMarketCapProvider(this.runtime);\n                    const priceData = await cmcProvider.getTokenPrice(tokenAddress, chain);\n                    if (priceData) {\n                        console.log(`Successfully fetched price data from CoinMarketCap for ${tokenAddress}`);\n                        return priceData;\n                    }\n                }\n            } catch (error) {\n                console.warn(`Failed to fetch from CoinMarketCap for ${tokenAddress}:`, error);\n            }\n\n            // Try JupiterService as final fallback for Solana tokens\n            if (chain === 'solana') {\n                try {\n                    const jupiterService = this.runtime.getService('JUPITER_SERVICE') as any;\n                    if (jupiterService && typeof jupiterService.getTokenPrice === 'function') {\n                        console.log(`Attempting to fetch price from Jupiter for ${tokenAddress}...`);\n\n                        // Try with different amounts if the first attempt fails\n                        let price = 0;\n                        const amounts = [1000000, 10000000, 100000000]; // Try different amounts\n\n                        for (const amount of amounts) {\n                            try {\n                                console.log(`Trying Jupiter with amount ${amount}...`);\n                                price = await jupiterService.getTokenPrice(tokenAddress, 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 6);\n                                if (price > 0) {\n                                    console.log(`Successfully fetched price data from Jupiter for ${tokenAddress}: $${price}`);\n                                    break;\n                                }\n                            } catch (amountError) {\n                                console.warn(`Jupiter failed with amount ${amount}:`, amountError);\n                                continue;\n                            }\n                        }\n\n                        if (price > 0) {\n                            return {\n                                timestamp: Date.now(),\n                                source: 'jupiter' as any,\n                                chain: chain,\n                                tokenAddress: tokenAddress,\n                                symbol: 'UNKNOWN', // Jupiter doesn't provide symbol\n                                price: price,\n                                priceChange24h: 0,\n                                priceChangePercent24h: 0,\n                                volume24h: 0,\n                                marketCap: 0,\n                            };\n                        } else {\n                            console.warn(`Jupiter returned price 0 for token ${tokenAddress} with all amounts`);\n                        }\n                    } else {\n                        console.warn('Jupiter service not available or getTokenPrice method not found');\n                    }\n                } catch (error) {\n                    console.warn(`Failed to fetch from Jupiter for ${tokenAddress}:`, error);\n                }\n            }\n\n            // Try CommunityInvestorService as final fallback\n            try {\n                const communityInvestorService = this.runtime.getService('COMMUNITY_INVESTOR_SERVICE') as any;\n                if (communityInvestorService && typeof communityInvestorService.getCurrentPrice === 'function') {\n                    console.log(`Attempting to fetch price from CommunityInvestorService for ${tokenAddress}...`);\n                    const price = await communityInvestorService.getCurrentPrice(chain, tokenAddress);\n                    if (price > 0) {\n                        console.log(`Successfully fetched price data from CommunityInvestorService for ${tokenAddress}: $${price}`);\n                        return {\n                            timestamp: Date.now(),\n                            source: 'community_investor' as any,\n                            chain: chain,\n                            tokenAddress: tokenAddress,\n                            symbol: 'UNKNOWN', // CommunityInvestor doesn't provide symbol in getCurrentPrice\n                            price: price,\n                            priceChange24h: 0,\n                            priceChangePercent24h: 0,\n                            volume24h: 0,\n                            marketCap: 0,\n                        };\n                    } else {\n                        console.warn(`CommunityInvestorService returned price 0 for token ${tokenAddress}`);\n                    }\n                } else {\n                    console.warn('CommunityInvestorService not available or getCurrentPrice method not found');\n                }\n            } catch (error) {\n                console.warn(`Failed to fetch from CommunityInvestorService for ${tokenAddress}:`, error);\n            }\n\n            console.warn(`Unable to fetch price data for token ${tokenAddress} from any provider`);\n            return null;\n        } catch (error) {\n            console.error('Error getting token price from existing providers:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get historical data from existing providers\n     */\n    private async getHistoricalDataFromExistingProviders(tokenAddress: string, chain: string, timeframe: string) {\n        try {\n            console.log(`Fetching historical data for ${tokenAddress} on ${chain} with timeframe ${timeframe}`);\n\n            // Get the Birdeye service from runtime\n            const birdeyeService = this.runtime.getService('birdeye') as any;\n            if (!birdeyeService || typeof birdeyeService.getTokenMarketData !== 'function') {\n                console.warn('Birdeye service not available');\n                return [];\n            }\n\n            // Check if we have the required API key\n            const birdeyeApiKey = this.runtime.getSetting('BIRDEYE_API_KEY') as string;\n            if (!birdeyeApiKey) {\n                console.warn('BIRDEYE_API_KEY not configured, cannot fetch historical data');\n                return [];\n            }\n\n            console.log('Birdeye API key found, using Birdeye service...');\n\n            // Use the getTokenMarketData function which already fetches historical data\n            const marketData = await (birdeyeService as any).getTokenMarketData(tokenAddress);\n\n            if (!marketData || !marketData.priceHistory || marketData.priceHistory.length === 0) {\n                console.warn(`No historical data found for token ${tokenAddress}`);\n                return [];\n            }\n\n            // Convert the price history array to the expected format\n            const historicalData = marketData.priceHistory.map((price: number, index: number) => ({\n                timestamp: Date.now() - (marketData.priceHistory.length - index) * 15 * 60 * 1000, // 15-minute intervals\n                open: price,\n                high: price,\n                low: price,\n                close: price,\n                volume: 0, // Volume not available in this format\n            }));\n\n            console.log(`Fetched ${historicalData.length} historical data points for ${tokenAddress}`);\n\n            if (historicalData.length > 0) {\n                console.log(`Sample data point:`, historicalData[0]);\n            }\n\n            return historicalData;\n        } catch (error) {\n            console.error('Error fetching historical data from Birdeye service:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Get holder analytics from Codex\n     */\n    private async getHolderAnalyticsFromCodex(tokenAddress: string) {\n        try {\n            const codexApiKey = this.runtime.getSetting('CODEX_API_KEY') as string;\n            if (!codexApiKey) {\n                return null;\n            }\n            return null;\n        } catch (error) {\n            console.error('Error getting holder analytics from Codex:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get sniper analytics from Codex\n     */\n    private async getSniperAnalyticsFromCodex(tokenAddress: string) {\n        try {\n            const codexApiKey = this.runtime.getSetting('CODEX_API_KEY') as string;\n            if (!codexApiKey) {\n                return null;\n            }\n\n            // This would need to be implemented with direct Codex API calls\n            // For now, return null as it's not available in existing providers\n            return null;\n        } catch (error) {\n            console.error('Error getting sniper analytics from Codex:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get account data from existing providers\n     */\n    private async getAccountDataFromExistingProviders(walletAddress: string, chain: string): Promise<AccountAnalytics | null> {\n        try {\n            // Get portfolio data from existing Birdeye provider\n            const portfolioData = await this.runtime.getCache<any>('portfolio');\n            if (!portfolioData || portfolioData.wallet !== walletAddress) {\n                return null;\n            }\n\n            const portfolio = portfolioData.data;\n            const trades = await this.runtime.getCache<any[]>('transaction_history') || [];\n\n            // Convert to AccountAnalytics format\n            const accountAnalytics: AccountAnalytics = {\n                walletAddress,\n                totalValue: portfolio.totalUsd || 0,\n                totalValueChange24h: 0, // Would need to calculate\n                totalValueChangePercent24h: 0, // Would need to calculate\n                portfolio: portfolio.items?.map((item: any) => ({\n                    tokenAddress: item.address,\n                    symbol: item.symbol,\n                    balance: item.balance || 0,\n                    value: item.value || 0,\n                    valueChange24h: 0, // Would need to calculate\n                    allocation: item.value > 0 ? (item.value / portfolio.totalUsd) * 100 : 0,\n                })) || [],\n                performance: {\n                    totalPnL: 0, // Would need to calculate\n                    totalPnLPercent: 0,\n                    bestPerformer: '',\n                    worstPerformer: '',\n                    riskMetrics: {\n                        sharpeRatio: 0,\n                        maxDrawdown: 0,\n                        volatility: 0,\n                    },\n                },\n                tradingHistory: {\n                    totalTrades: trades.length,\n                    winningTrades: 0, // Would need to analyze trades\n                    losingTrades: 0, // Would need to analyze trades\n                    winRate: 0,\n                    averageTradeSize: 0,\n                },\n            };\n\n            return accountAnalytics;\n        } catch (error) {\n            console.error('Error getting account data from existing providers:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get market data from existing providers\n     */\n    private async getMarketDataFromExistingProviders(chain: string): Promise<MarketAnalytics | null> {\n        try {\n            let topGainers: any[] = [];\n            let topLosers: any[] = [];\n            let trendingTokens: any[] = [];\n\n            // Get data from Birdeye trending\n            const birdeyeTokens = await this.runtime.getCache<any[]>('tokens_solana');\n            if (birdeyeTokens && birdeyeTokens.length > 0) {\n                trendingTokens = birdeyeTokens.slice(0, 20).map(token => ({\n                    timestamp: Date.now(),\n                    source: 'birdeye' as const,\n                    chain: chain,\n                    tokenAddress: token.address,\n                    symbol: token.symbol,\n                    price: token.price || 0,\n                    priceChange24h: 0,\n                    priceChangePercent24h: token.price24hChangePercent || 0,\n                    volume24h: token.volume24hUSD || 0,\n                    marketCap: token.marketcap || 0,\n                }));\n\n                // Sort by price change for gainers/losers\n                const sortedTokens = [...birdeyeTokens].sort((a, b) =>\n                    (b.price24hChangePercent || 0) - (a.price24hChangePercent || 0)\n                );\n\n                topGainers = sortedTokens.slice(0, 10).map(token => ({\n                    timestamp: Date.now(),\n                    source: 'birdeye' as const,\n                    chain: chain,\n                    tokenAddress: token.address,\n                    symbol: token.symbol,\n                    price: token.price || 0,\n                    priceChange24h: 0,\n                    priceChangePercent24h: token.price24hChangePercent || 0,\n                    volume24h: token.volume24hUSD || 0,\n                    marketCap: token.marketcap || 0,\n                }));\n\n                topLosers = sortedTokens.slice(-10).map(token => ({\n                    timestamp: Date.now(),\n                    source: 'birdeye' as const,\n                    chain: chain,\n                    tokenAddress: token.address,\n                    symbol: token.symbol,\n                    price: token.price || 0,\n                    priceChange24h: 0,\n                    priceChangePercent24h: token.price24hChangePercent || 0,\n                    volume24h: token.volume24hUSD || 0,\n                    marketCap: token.marketcap || 0,\n                }));\n            }\n\n            // Get data from CoinMarketCap\n            const cmcTokens = await this.runtime.getCache<any[]>('coinmarketcap_sync');\n            if (cmcTokens && cmcTokens.length > 0) {\n                // Add CMC data if Birdeye data is insufficient\n                if (trendingTokens.length < 20) {\n                    const cmcTrending = cmcTokens.slice(0, 20 - trendingTokens.length).map(token => ({\n                        timestamp: Date.now(),\n                        source: 'coinmarketcap' as const,\n                        chain: chain,\n                        tokenAddress: token.address,\n                        symbol: token.symbol,\n                        price: token.price || 0,\n                        priceChange24h: 0,\n                        priceChangePercent24h: token.price24hChangePercent || 0,\n                        volume24h: token.volume24hUSD || 0,\n                        marketCap: token.marketcap || 0,\n                    }));\n                    trendingTokens.push(...cmcTrending);\n                }\n            }\n\n            const marketAnalytics: MarketAnalytics = {\n                marketCap: 0, // Would need to calculate from all tokens\n                volume24h: 0, // Would need to calculate from all tokens\n                dominance: 0, // Would need to calculate\n                topGainers,\n                topLosers,\n                trendingTokens,\n                marketSentiment: {\n                    bullish: 0.5, // Placeholder\n                    bearish: 0.3,\n                    neutral: 0.2,\n                },\n            };\n\n            return marketAnalytics;\n        } catch (error) {\n            console.error('Error getting market data from existing providers:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Calculate technical indicators from historical data\n     */\n    private async calculateTechnicalIndicators(historicalData: any[]): Promise<TechnicalIndicators> {\n        console.log(`Calculating technical indicators with ${historicalData.length} data points`);\n\n        if (historicalData.length < 50) {\n            console.warn(`Insufficient historical data: ${historicalData.length} points (need at least 50)`);\n            return {\n                macd: { macd: 0, signal: 0, histogram: 0, bullish: false },\n                rsi: { value: 50, overbought: false, oversold: false },\n                bollingerBands: { upper: 0, middle: 0, lower: 0, bandwidth: 0, percentB: 0.5 },\n                movingAverages: { sma20: 0, sma50: 0, sma200: 0, ema12: 0, ema26: 0 },\n                volume: { volumeSMA: 0, volumeRatio: 1, onBalanceVolume: 0 }\n            };\n        }\n\n        const prices = historicalData.map(d => d.close);\n        const volumes = historicalData.map(d => d.volume);\n        const highs = historicalData.map(d => d.high);\n        const lows = historicalData.map(d => d.low);\n\n        console.log(`Sample prices: ${prices.slice(0, 5).join(', ')}...`);\n        console.log(`Sample volumes: ${volumes.slice(0, 5).join(', ')}...`);\n\n        // Calculate MACD\n        const macdResult = calculateMACD(prices);\n        const currentMACD = macdResult.macd[macdResult.macd.length - 1] || 0;\n        const currentSignal = macdResult.signal[macdResult.signal.length - 1] || 0;\n        const currentHistogram = macdResult.histogram[macdResult.histogram.length - 1] || 0;\n\n        console.log(`MACD calculation: MACD=${currentMACD}, Signal=${currentSignal}, Histogram=${currentHistogram}`);\n\n        // Calculate RSI\n        const rsiResult = calculateRSI(prices);\n        const currentRSI = rsiResult[rsiResult.length - 1] || 50;\n\n        console.log(`RSI calculation: ${currentRSI}`);\n\n        // Calculate Bollinger Bands\n        const bbResult = calculateBollingerBands(prices);\n        const currentBB = {\n            upper: bbResult.upper[bbResult.upper.length - 1] || 0,\n            middle: bbResult.middle[bbResult.middle.length - 1] || 0,\n            lower: bbResult.lower[bbResult.lower.length - 1] || 0,\n            bandwidth: bbResult.bandwidth[bbResult.bandwidth.length - 1] || 0,\n            percentB: bbResult.percentB[bbResult.percentB.length - 1] || 0.5\n        };\n\n        console.log(`Bollinger Bands: Upper=${currentBB.upper}, Middle=${currentBB.middle}, Lower=${currentBB.lower}, %B=${currentBB.percentB}`);\n\n        // Calculate Moving Averages\n        const sma20 = calculateSMA(prices, 20);\n        const sma50 = calculateSMA(prices, 50);\n        const sma200 = calculateSMA(prices, 200);\n        const ema12 = calculateEMA(prices, 12);\n        const ema26 = calculateEMA(prices, 26);\n\n        console.log(`Moving Averages: SMA20=${sma20[sma20.length - 1] || 0}, SMA50=${sma50[sma50.length - 1] || 0}, EMA12=${ema12[ema12.length - 1] || 0}`);\n\n        // Calculate Volume indicators\n        const volumeResult = calculateVolumeIndicators(prices, volumes);\n\n        console.log(`Volume indicators: VolumeSMA=${volumeResult.volumeSMA[volumeResult.volumeSMA.length - 1] || 0}, VolumeRatio=${volumeResult.volumeRatio[volumeResult.volumeRatio.length - 1] || 1}`);\n\n        return {\n            macd: {\n                macd: currentMACD,\n                signal: currentSignal,\n                histogram: currentHistogram,\n                bullish: currentMACD > currentSignal\n            },\n            rsi: {\n                value: currentRSI,\n                overbought: currentRSI > 70,\n                oversold: currentRSI < 30\n            },\n            bollingerBands: currentBB,\n            movingAverages: {\n                sma20: sma20[sma20.length - 1] || 0,\n                sma50: sma50[sma50.length - 1] || 0,\n                sma200: sma200[sma200.length - 1] || 0,\n                ema12: ema12[ema12.length - 1] || 0,\n                ema26: ema26[ema26.length - 1] || 0\n            },\n            volume: {\n                volumeSMA: volumeResult.volumeSMA[volumeResult.volumeSMA.length - 1] || 0,\n                volumeRatio: volumeResult.volumeRatio[volumeResult.volumeRatio.length - 1] || 1,\n                onBalanceVolume: volumeResult.onBalanceVolume[volumeResult.onBalanceVolume.length - 1] || 0\n            }\n        };\n    }\n\n    /**\n     * Calculate risk assessment\n     */\n    private calculateRiskAssessment(\n        technicalIndicators: TechnicalIndicators,\n        holderAnalytics: any,\n        priceData: any\n    ) {\n        let volatility = 0;\n        let liquidity = 0;\n        let concentrationRisk = 'low';\n        let technicalRisk = 'low';\n        let overallRisk: 'low' | 'moderate' | 'high' = 'low';\n\n        // Calculate volatility from price data\n        if (priceData.priceChangePercent24h) {\n            volatility = Math.abs(priceData.priceChangePercent24h);\n        }\n\n        // Calculate liquidity score\n        if (priceData.volume24h && priceData.marketCap) {\n            liquidity = (priceData.volume24h / priceData.marketCap) * 100;\n        }\n\n        // Assess concentration risk from holder analytics\n        if (holderAnalytics) {\n            concentrationRisk = holderAnalytics.concentrationRisk;\n        }\n\n        // Assess technical risk\n        if (technicalIndicators.rsi.overbought || technicalIndicators.rsi.oversold) {\n            technicalRisk = 'moderate';\n        }\n        if (technicalIndicators.bollingerBands.percentB > 0.8 || technicalIndicators.bollingerBands.percentB < 0.2) {\n            technicalRisk = 'high';\n        }\n\n        // Calculate overall risk\n        let riskScore = 0;\n        if (volatility > 50) riskScore += 2;\n        if (liquidity < 1) riskScore += 2;\n        if (concentrationRisk === 'high') riskScore += 2;\n        if (technicalRisk === 'high') riskScore += 1;\n\n        if (riskScore >= 4) overallRisk = 'high';\n        else if (riskScore >= 2) overallRisk = 'moderate';\n        else overallRisk = 'low';\n\n        return {\n            volatility,\n            liquidity,\n            concentrationRisk,\n            technicalRisk,\n            overallRisk\n        };\n    }\n\n    /**\n     * Generate trading recommendations\n     */\n    private generateRecommendations(\n        technicalIndicators: TechnicalIndicators,\n        holderAnalytics: any,\n        priceData: any,\n        historicalData: any[]\n    ) {\n        // Generate signals from technical indicators\n        const signals = generateSignals(\n            historicalData.map(d => d.close),\n            historicalData.map(d => d.volume),\n            historicalData.map(d => d.high),\n            historicalData.map(d => d.low)\n        );\n\n        let action: 'buy' | 'sell' | 'hold' | 'accumulate' = 'hold';\n        let confidence = 0;\n        const reasons: string[] = [];\n        const priceTargets = {\n            shortTerm: priceData.price,\n            mediumTerm: priceData.price,\n            longTerm: priceData.price\n        };\n\n        // Determine action based on signals\n        if (signals.overallSignal === 'buy' && signals.confidence > 60) {\n            action = 'buy';\n            confidence = signals.confidence;\n            reasons.push('Strong technical buy signals');\n        } else if (signals.overallSignal === 'sell' && signals.confidence > 60) {\n            action = 'sell';\n            confidence = signals.confidence;\n            reasons.push('Strong technical sell signals');\n        } else if (signals.overallSignal === 'buy' && signals.confidence > 40) {\n            action = 'accumulate';\n            confidence = signals.confidence;\n            reasons.push('Moderate technical buy signals');\n        }\n\n        // Add holder analytics insights\n        if (holderAnalytics) {\n            if (holderAnalytics.communityGrowth === 'explosive') {\n                reasons.push('Explosive community growth');\n                confidence += 10;\n            } else if (holderAnalytics.communityGrowth === 'growing') {\n                reasons.push('Growing community');\n                confidence += 5;\n            }\n\n            if (holderAnalytics.concentrationRisk === 'low') {\n                reasons.push('Low concentration risk');\n                confidence += 5;\n            } else if (holderAnalytics.concentrationRisk === 'high') {\n                reasons.push('High concentration risk');\n                confidence -= 10;\n            }\n        }\n\n        // Calculate price targets\n        if (historicalData.length > 0) {\n            const currentPrice = priceData.price;\n            const volatility = Math.abs(priceData.priceChangePercent24h) / 100;\n\n            priceTargets.shortTerm = currentPrice * (1 + (volatility * 0.5));\n            priceTargets.mediumTerm = currentPrice * (1 + (volatility * 1.5));\n            priceTargets.longTerm = currentPrice * (1 + (volatility * 3));\n        }\n\n        // Cap confidence at 100\n        confidence = Math.min(confidence, 100);\n\n        return {\n            action,\n            confidence,\n            reasons,\n            priceTargets\n        };\n    }\n\n    /**\n     * Start the scenario service with the given runtime.\n     * @param {IAgentRuntime} runtime - The agent runtime\n     * @returns {Promise<ScenarioService>} - The started scenario service\n     */\n    static async start(runtime: IAgentRuntime) {\n        const service = new AnalyticsService(runtime);\n        service.start();\n        return service;\n    }\n    /**\n     * Stops the Scenario service associated with the given runtime.\n     *\n     * @param {IAgentRuntime} runtime The runtime to stop the service for.\n     * @throws {Error} When the Scenario service is not found.\n     */\n    static async stop(runtime: IAgentRuntime) {\n        const service = runtime.getService(this.serviceType);\n        if (!service) {\n            throw new Error(this.serviceType + ' service not found');\n        }\n        service.stop();\n    }\n\n    async start(): Promise<void> {\n        if (this.isRunning) {\n            logger.warn('ANALYTICS_SERVICE service is already running');\n            return;\n        }\n\n        try {\n            logger.info('ANALYTICS_SERVICE trading service...');\n\n            this.isRunning = true;\n            logger.info('ANALYTICS_SERVICE service started successfully');\n        } catch (error) {\n            logger.error('Error starting ANALYTICS_SERVICE service:', error as string);\n            throw error;\n        }\n    }\n\n    async stop(): Promise<void> {\n        if (!this.isRunning) {\n            logger.warn('ANALYTICS_SERVICE service is not running');\n            return;\n        }\n\n        try {\n            logger.info('Stopping ANALYTICS_SERVICE service...');\n\n            this.isRunning = false;\n            logger.info('ANALYTICS_SERVICE stopped successfully');\n        } catch (error) {\n            logger.error('Error stopping ANALYTICS_SERVICE service:', error as string);\n            throw error;\n        }\n    }\n\n    isServiceRunning(): boolean {\n        return this.isRunning;\n    }\n\n}\n\n// Helper functions for moving averages\nfunction calculateSMA(prices: number[], period: number): number[] {\n    if (prices.length < period) return [];\n\n    const sma: number[] = [];\n    for (let i = period - 1; i < prices.length; i++) {\n        const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\n        sma.push(sum / period);\n    }\n    return sma;\n}\n\nfunction calculateEMA(prices: number[], period: number): number[] {\n    if (prices.length < period) return [];\n\n    const ema: number[] = [];\n    const multiplier = 2 / (period + 1);\n\n    // First EMA is SMA\n    let sum = 0;\n    for (let i = 0; i < period; i++) {\n        sum += prices[i];\n    }\n    ema.push(sum / period);\n\n    // Calculate subsequent EMAs\n    for (let i = period; i < prices.length; i++) {\n        const newEMA = (prices[i] * multiplier) + (ema[ema.length - 1] * (1 - multiplier));\n        ema.push(newEMA);\n    }\n\n    return ema;\n}",
    "/**\n * Technical Analysis Utilities\n * Comprehensive collection of technical indicators for cryptocurrency analysis\n */\n\n/**\n * Calculate Simple Moving Average (SMA)\n */\nexport function calculateSMA(prices: number[], period: number): number[] {\n    if (prices.length < period) return [];\n\n    const sma: number[] = [];\n    for (let i = period - 1; i < prices.length; i++) {\n        const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\n        sma.push(sum / period);\n    }\n    return sma;\n}\n\n/**\n * Calculate Exponential Moving Average (EMA)\n */\nexport function calculateEMA(prices: number[], period: number): number[] {\n    if (prices.length < period) return [];\n\n    const ema: number[] = [];\n    const multiplier = 2 / (period + 1);\n\n    // First EMA is SMA\n    let sum = 0;\n    for (let i = 0; i < period; i++) {\n        sum += prices[i];\n    }\n    ema.push(sum / period);\n\n    // Calculate subsequent EMAs\n    for (let i = period; i < prices.length; i++) {\n        const newEMA = (prices[i] * multiplier) + (ema[ema.length - 1] * (1 - multiplier));\n        ema.push(newEMA);\n    }\n\n    return ema;\n}\n\n/**\n * Calculate MACD (Moving Average Convergence Divergence)\n */\nexport function calculateMACD(\n    prices: number[],\n    fastPeriod: number = 12,\n    slowPeriod: number = 26,\n    signalPeriod: number = 9\n): {\n    macd: number[];\n    signal: number[];\n    histogram: number[];\n} {\n    if (prices.length < slowPeriod) {\n        return { macd: [], signal: [], histogram: [] };\n    }\n\n    const fastEMA = calculateEMA(prices, fastPeriod);\n    const slowEMA = calculateEMA(prices, slowPeriod);\n\n    // Calculate MACD line\n    const macd: number[] = [];\n    const startIndex = slowPeriod - fastPeriod;\n    for (let i = 0; i < fastEMA.length; i++) {\n        const slowIndex = i + startIndex;\n        if (slowIndex < slowEMA.length) {\n            macd.push(fastEMA[i] - slowEMA[slowIndex]);\n        }\n    }\n\n    // Calculate signal line\n    const signal = calculateEMA(macd, signalPeriod);\n\n    // Calculate histogram\n    const histogram: number[] = [];\n    for (let i = 0; i < signal.length; i++) {\n        const macdIndex = i + signalPeriod - 1;\n        if (macdIndex < macd.length) {\n            histogram.push(macd[macdIndex] - signal[i]);\n        }\n    }\n\n    return { macd, signal, histogram };\n}\n\n/**\n * Calculate RSI (Relative Strength Index)\n */\nexport function calculateRSI(prices: number[], period: number = 14): number[] {\n    if (prices.length < period + 1) return [];\n\n    const rsi: number[] = [];\n    const gains: number[] = [];\n    const losses: number[] = [];\n\n    // Calculate price changes\n    for (let i = 1; i < prices.length; i++) {\n        const change = prices[i] - prices[i - 1];\n        gains.push(change > 0 ? change : 0);\n        losses.push(change < 0 ? Math.abs(change) : 0);\n    }\n\n    // Calculate initial average gain and loss\n    let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;\n    let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;\n\n    // Calculate first RSI\n    const rs = avgGain / avgLoss;\n    rsi.push(100 - (100 / (1 + rs)));\n\n    // Calculate subsequent RSI values\n    for (let i = period; i < gains.length; i++) {\n        avgGain = ((avgGain * (period - 1)) + gains[i]) / period;\n        avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;\n\n        const rs = avgGain / avgLoss;\n        rsi.push(100 - (100 / (1 + rs)));\n    }\n\n    return rsi;\n}\n\n/**\n * Calculate Bollinger Bands\n */\nexport function calculateBollingerBands(\n    prices: number[],\n    period: number = 20,\n    standardDeviations: number = 2\n): {\n    upper: number[];\n    middle: number[];\n    lower: number[];\n    bandwidth: number[];\n    percentB: number[];\n} {\n    if (prices.length < period) {\n        return { upper: [], middle: [], lower: [], bandwidth: [], percentB: [] };\n    }\n\n    const middle = calculateSMA(prices, period);\n    const upper: number[] = [];\n    const lower: number[] = [];\n    const bandwidth: number[] = [];\n    const percentB: number[] = [];\n\n    for (let i = 0; i < middle.length; i++) {\n        const startIndex = i;\n        const endIndex = startIndex + period;\n        const slice = prices.slice(startIndex, endIndex);\n\n        // Calculate standard deviation\n        const mean = middle[i];\n        const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;\n        const stdDev = Math.sqrt(variance);\n\n        const upperBand = mean + (standardDeviations * stdDev);\n        const lowerBand = mean - (standardDeviations * stdDev);\n\n        upper.push(upperBand);\n        lower.push(lowerBand);\n        bandwidth.push((upperBand - lowerBand) / mean);\n\n        // Calculate %B\n        const currentPrice = prices[endIndex - 1];\n        const percentBValue = (currentPrice - lowerBand) / (upperBand - lowerBand);\n        percentB.push(percentBValue);\n    }\n\n    return { upper, middle, lower, bandwidth, percentB };\n}\n\n/**\n * Calculate Volume indicators\n */\nexport function calculateVolumeIndicators(\n    prices: number[],\n    volumes: number[],\n    period: number = 20\n): {\n    volumeSMA: number[];\n    volumeRatio: number[];\n    onBalanceVolume: number[];\n} {\n    if (prices.length !== volumes.length || prices.length < period) {\n        return { volumeSMA: [], volumeRatio: [], onBalanceVolume: [] };\n    }\n\n    const volumeSMA = calculateSMA(volumes, period);\n\n    // Calculate volume ratio\n    const volumeRatio: number[] = [];\n    for (let i = period - 1; i < volumes.length; i++) {\n        volumeRatio.push(volumes[i] / volumeSMA[i - period + 1]);\n    }\n\n    // Calculate On-Balance Volume (OBV)\n    const onBalanceVolume: number[] = [];\n    let obv = 0;\n\n    for (let i = 0; i < prices.length; i++) {\n        if (i === 0) {\n            obv = volumes[i];\n        } else {\n            if (prices[i] > prices[i - 1]) {\n                obv += volumes[i];\n            } else if (prices[i] < prices[i - 1]) {\n                obv -= volumes[i];\n            }\n            // If price is same, OBV remains unchanged\n        }\n        onBalanceVolume.push(obv);\n    }\n\n    return { volumeSMA, volumeRatio, onBalanceVolume };\n}\n\n/**\n * Calculate Stochastic Oscillator\n */\nexport function calculateStochastic(\n    highs: number[],\n    lows: number[],\n    closes: number[],\n    kPeriod: number = 14,\n    dPeriod: number = 3\n): {\n    k: number[];\n    d: number[];\n} {\n    if (highs.length < kPeriod || lows.length < kPeriod || closes.length < kPeriod) {\n        return { k: [], d: [] };\n    }\n\n    const k: number[] = [];\n\n    for (let i = kPeriod - 1; i < closes.length; i++) {\n        const highestHigh = Math.max(...highs.slice(i - kPeriod + 1, i + 1));\n        const lowestLow = Math.min(...lows.slice(i - kPeriod + 1, i + 1));\n        const currentClose = closes[i];\n\n        const kValue = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;\n        k.push(kValue);\n    }\n\n    // Calculate %D (SMA of %K)\n    const d = calculateSMA(k, dPeriod);\n\n    return { k, d };\n}\n\n/**\n * Calculate Average True Range (ATR)\n */\nexport function calculateATR(\n    highs: number[],\n    lows: number[],\n    closes: number[],\n    period: number = 14\n): number[] {\n    if (highs.length < period + 1 || lows.length < period + 1 || closes.length < period + 1) {\n        return [];\n    }\n\n    const trueRanges: number[] = [];\n\n    for (let i = 1; i < closes.length; i++) {\n        const highLow = highs[i] - lows[i];\n        const highClose = Math.abs(highs[i] - closes[i - 1]);\n        const lowClose = Math.abs(lows[i] - closes[i - 1]);\n\n        const trueRange = Math.max(highLow, highClose, lowClose);\n        trueRanges.push(trueRange);\n    }\n\n    // Calculate ATR using EMA\n    return calculateEMA(trueRanges, period);\n}\n\n/**\n * Calculate Williams %R\n */\nexport function calculateWilliamsR(\n    highs: number[],\n    lows: number[],\n    closes: number[],\n    period: number = 14\n): number[] {\n    if (highs.length < period || lows.length < period || closes.length < period) {\n        return [];\n    }\n\n    const williamsR: number[] = [];\n\n    for (let i = period - 1; i < closes.length; i++) {\n        const highestHigh = Math.max(...highs.slice(i - period + 1, i + 1));\n        const lowestLow = Math.min(...lows.slice(i - period + 1, i + 1));\n        const currentClose = closes[i];\n\n        const wr = ((highestHigh - currentClose) / (highestHigh - lowestLow)) * -100;\n        williamsR.push(wr);\n    }\n\n    return williamsR;\n}\n\n/**\n * Calculate Commodity Channel Index (CCI)\n */\nexport function calculateCCI(\n    highs: number[],\n    lows: number[],\n    closes: number[],\n    period: number = 20\n): number[] {\n    if (highs.length < period || lows.length < period || closes.length < period) {\n        return [];\n    }\n\n    const cci: number[] = [];\n\n    for (let i = period - 1; i < closes.length; i++) {\n        const slice = closes.slice(i - period + 1, i + 1);\n        const typicalPrices = slice.map((close, index) => {\n            const highIndex = i - period + 1 + index;\n            const lowIndex = i - period + 1 + index;\n            return (highs[highIndex] + lows[lowIndex] + close) / 3;\n        });\n\n        const sma = typicalPrices.reduce((a, b) => a + b, 0) / period;\n        const meanDeviation = typicalPrices.reduce((sum, price) => sum + Math.abs(price - sma), 0) / period;\n\n        const currentTypicalPrice = (highs[i] + lows[i] + closes[i]) / 3;\n        const cciValue = (currentTypicalPrice - sma) / (0.015 * meanDeviation);\n        cci.push(cciValue);\n    }\n\n    return cci;\n}\n\n/**\n * Calculate Money Flow Index (MFI)\n */\nexport function calculateMFI(\n    highs: number[],\n    lows: number[],\n    closes: number[],\n    volumes: number[],\n    period: number = 14\n): number[] {\n    if (highs.length < period + 1 || lows.length < period + 1 ||\n        closes.length < period + 1 || volumes.length < period + 1) {\n        return [];\n    }\n\n    const mfi: number[] = [];\n    const moneyFlows: number[] = [];\n\n    for (let i = 1; i < closes.length; i++) {\n        const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;\n        const prevTypicalPrice = (highs[i - 1] + lows[i - 1] + closes[i - 1]) / 3;\n\n        let moneyFlow = 0;\n        if (typicalPrice > prevTypicalPrice) {\n            moneyFlow = typicalPrice * volumes[i];\n        } else if (typicalPrice < prevTypicalPrice) {\n            moneyFlow = -typicalPrice * volumes[i];\n        }\n\n        moneyFlows.push(moneyFlow);\n    }\n\n    for (let i = period - 1; i < moneyFlows.length; i++) {\n        const slice = moneyFlows.slice(i - period + 1, i + 1);\n        const positiveFlow = slice.filter(flow => flow > 0).reduce((a, b) => a + b, 0);\n        const negativeFlow = Math.abs(slice.filter(flow => flow < 0).reduce((a, b) => a + b, 0));\n\n        const mfiValue = 100 - (100 / (1 + (positiveFlow / negativeFlow)));\n        mfi.push(mfiValue);\n    }\n\n    return mfi;\n}\n\n/**\n * Calculate Parabolic SAR\n */\nexport function calculateParabolicSAR(\n    highs: number[],\n    lows: number[],\n    accelerationFactor: number = 0.02,\n    maximumAcceleration: number = 0.2\n): number[] {\n    if (highs.length < 2 || lows.length < 2) {\n        return [];\n    }\n\n    const sar: number[] = [];\n    let isLong = true;\n    let af = accelerationFactor;\n    let ep = lows[0]; // Extreme point\n    let prevSar = highs[0];\n\n    sar.push(prevSar);\n\n    for (let i = 1; i < highs.length; i++) {\n        let currentSar: number;\n\n        if (isLong) {\n            currentSar = prevSar + af * (ep - prevSar);\n\n            // Check if we need to switch to short\n            if (lows[i] < currentSar) {\n                isLong = false;\n                currentSar = ep;\n                ep = highs[i];\n                af = accelerationFactor;\n            } else {\n                if (highs[i] > ep) {\n                    ep = highs[i];\n                    af = Math.min(af + accelerationFactor, maximumAcceleration);\n                }\n            }\n        } else {\n            currentSar = prevSar + af * (ep - prevSar);\n\n            // Check if we need to switch to long\n            if (highs[i] > currentSar) {\n                isLong = true;\n                currentSar = ep;\n                ep = lows[i];\n                af = accelerationFactor;\n            } else {\n                if (lows[i] < ep) {\n                    ep = lows[i];\n                    af = Math.min(af + accelerationFactor, maximumAcceleration);\n                }\n            }\n        }\n\n        sar.push(currentSar);\n        prevSar = currentSar;\n    }\n\n    return sar;\n}\n\n/**\n * Calculate Average Directional Index (ADX)\n */\nexport function calculateADX(\n    highs: number[],\n    lows: number[],\n    closes: number[],\n    period: number = 14\n): {\n    adx: number[];\n    plusDI: number[];\n    minusDI: number[];\n} {\n    if (highs.length < period + 1 || lows.length < period + 1 || closes.length < period + 1) {\n        return { adx: [], plusDI: [], minusDI: [] };\n    }\n\n    const trueRanges: number[] = [];\n    const plusDM: number[] = [];\n    const minusDM: number[] = [];\n\n    for (let i = 1; i < closes.length; i++) {\n        const highDiff = highs[i] - highs[i - 1];\n        const lowDiff = lows[i - 1] - lows[i];\n\n        const trueRange = Math.max(\n            highs[i] - lows[i],\n            Math.abs(highs[i] - closes[i - 1]),\n            Math.abs(lows[i] - closes[i - 1])\n        );\n        trueRanges.push(trueRange);\n\n        if (highDiff > lowDiff && highDiff > 0) {\n            plusDM.push(highDiff);\n        } else {\n            plusDM.push(0);\n        }\n\n        if (lowDiff > highDiff && lowDiff > 0) {\n            minusDM.push(lowDiff);\n        } else {\n            minusDM.push(0);\n        }\n    }\n\n    const smoothedTR = calculateEMA(trueRanges, period);\n    const smoothedPlusDM = calculateEMA(plusDM, period);\n    const smoothedMinusDM = calculateEMA(minusDM, period);\n\n    const plusDI: number[] = [];\n    const minusDI: number[] = [];\n    const dx: number[] = [];\n\n    for (let i = 0; i < smoothedTR.length; i++) {\n        const plusDIValue = (smoothedPlusDM[i] / smoothedTR[i]) * 100;\n        const minusDIValue = (smoothedMinusDM[i] / smoothedTR[i]) * 100;\n\n        plusDI.push(plusDIValue);\n        minusDI.push(minusDIValue);\n\n        const dxValue = (Math.abs(plusDIValue - minusDIValue) / (plusDIValue + minusDIValue)) * 100;\n        dx.push(dxValue);\n    }\n\n    const adx = calculateEMA(dx, period);\n\n    return { adx, plusDI, minusDI };\n}\n\n/**\n * Generate trading signals based on technical indicators\n */\nexport function generateSignals(\n    prices: number[],\n    volumes: number[],\n    highs: number[],\n    lows: number[]\n): {\n    macdSignal: 'buy' | 'sell' | 'hold';\n    rsiSignal: 'buy' | 'sell' | 'hold';\n    bbSignal: 'buy' | 'sell' | 'hold';\n    volumeSignal: 'buy' | 'sell' | 'hold';\n    overallSignal: 'buy' | 'sell' | 'hold';\n    confidence: number;\n} {\n    if (prices.length < 50) {\n        return {\n            macdSignal: 'hold',\n            rsiSignal: 'hold',\n            bbSignal: 'hold',\n            volumeSignal: 'hold',\n            overallSignal: 'hold',\n            confidence: 0\n        };\n    }\n\n    // Calculate indicators\n    const { macd, signal, histogram } = calculateMACD(prices);\n    const rsi = calculateRSI(prices);\n    const { upper, middle, lower, percentB } = calculateBollingerBands(prices);\n    const { volumeRatio } = calculateVolumeIndicators(prices, volumes);\n\n    // Get latest values\n    const currentPrice = prices[prices.length - 1];\n    const currentMACD = macd[macd.length - 1];\n    const currentSignal = signal[signal.length - 1];\n    const currentHistogram = histogram[histogram.length - 1];\n    const currentRSI = rsi[rsi.length - 1];\n    const currentPercentB = percentB[percentB.length - 1];\n    const currentVolumeRatio = volumeRatio[volumeRatio.length - 1];\n\n    // MACD signals\n    let macdSignal: 'buy' | 'sell' | 'hold' = 'hold';\n    if (currentMACD > currentSignal && currentHistogram > 0) {\n        macdSignal = 'buy';\n    } else if (currentMACD < currentSignal && currentHistogram < 0) {\n        macdSignal = 'sell';\n    }\n\n    // RSI signals\n    let rsiSignal: 'buy' | 'sell' | 'hold' = 'hold';\n    if (currentRSI < 30) {\n        rsiSignal = 'buy';\n    } else if (currentRSI > 70) {\n        rsiSignal = 'sell';\n    }\n\n    // Bollinger Bands signals\n    let bbSignal: 'buy' | 'sell' | 'hold' = 'hold';\n    if (currentPercentB < 0.2) {\n        bbSignal = 'buy';\n    } else if (currentPercentB > 0.8) {\n        bbSignal = 'sell';\n    }\n\n    // Volume signals\n    let volumeSignal: 'buy' | 'sell' | 'hold' = 'hold';\n    if (currentVolumeRatio > 1.5) {\n        volumeSignal = 'buy';\n    } else if (currentVolumeRatio < 0.5) {\n        volumeSignal = 'sell';\n    }\n\n    // Overall signal calculation\n    let buySignals = 0;\n    let sellSignals = 0;\n\n    if (macdSignal === 'buy') buySignals++;\n    if (macdSignal === 'sell') sellSignals++;\n    if (rsiSignal === 'buy') buySignals++;\n    if (rsiSignal === 'sell') sellSignals++;\n    if (bbSignal === 'buy') buySignals++;\n    if (bbSignal === 'sell') sellSignals++;\n    if (volumeSignal === 'buy') buySignals++;\n    if (volumeSignal === 'sell') sellSignals++;\n\n    let overallSignal: 'buy' | 'sell' | 'hold' = 'hold';\n    if (buySignals > sellSignals && buySignals >= 2) {\n        overallSignal = 'buy';\n    } else if (sellSignals > buySignals && sellSignals >= 2) {\n        overallSignal = 'sell';\n    }\n\n    // Calculate confidence (0-100)\n    const totalSignals = buySignals + sellSignals;\n    const confidence = totalSignals > 0 ? (Math.max(buySignals, sellSignals) / totalSignals) * 100 : 0;\n\n    return {\n        macdSignal,\n        rsiSignal,\n        bbSignal,\n        volumeSignal,\n        overallSignal,\n        confidence\n    };\n} ",
    "import type { IAgentRuntime, Memory } from '@elizaos/core';\n\n/**\n * Extract wallet addresses from text\n * Supports Solana (base58) and EVM (hex) addresses\n */\nexport async function getWalletsFromText(runtime: IAgentRuntime, message: Memory): Promise<string[]> {\n    const text = message.content?.text || '';\n    const addresses: string[] = [];\n\n    // Solana address pattern (base58, 32-44 characters)\n    const solanaPattern = /\\b[1-9A-HJ-NP-Za-km-z]{32,44}\\b/g;\n    const solanaMatches = text.match(solanaPattern) || [];\n    addresses.push(...solanaMatches);\n\n    // Ethereum/EVM address pattern (0x followed by 40 hex chars)\n    const evmPattern = /\\b0x[a-fA-F0-9]{40}\\b/g;\n    const evmMatches = text.match(evmPattern) || [];\n    addresses.push(...evmMatches);\n\n    // Remove duplicates\n    return [...new Set(addresses)];\n}\n\n/**\n * Get account information from message context\n * Simplified version that extracts basic user info\n */\nexport async function getAccountFromMessage(runtime: IAgentRuntime, message: Memory): Promise<{\n    userId?: string;\n    walletAddress?: string;\n    visualOutput?: boolean;\n} | null> {\n    try {\n        // Try to get wallet address from message\n        const wallets = await getWalletsFromText(runtime, message);\n\n        return {\n            userId: message.entityId || (message as any).userId,\n            walletAddress: wallets.length > 0 ? wallets[0] : undefined,\n            visualOutput: true, // Default to visual output enabled\n        };\n    } catch (error) {\n        console.warn('Error getting account from message:', error);\n        return null;\n    }\n}\n\n/**\n * Check if visual output is enabled for the user\n */\nexport async function isVisualOutputEnabled(runtime: IAgentRuntime, message: Memory): Promise<boolean> {\n    try {\n        const account = await getAccountFromMessage(runtime, message);\n        return account?.visualOutput !== false; // Default to true\n    } catch (error) {\n        console.warn('Error checking visual output setting:', error);\n        return true; // Default to visual output enabled\n    }\n}\n\n",
    "/**\n * Date filter types and utilities\n */\n\nexport interface DateFilter {\n    startDate?: Date;\n    endDate?: Date;\n    period?: string;\n    type: 'range' | 'period' | 'since' | 'until';\n}\n\n/**\n * Parse date filter from natural language message\n */\nexport function parseDateFilterFromMessage(messageText: string): DateFilter | null {\n    if (!messageText) return null;\n\n    const text = messageText.toLowerCase();\n    const now = new Date();\n\n    // Check for \"last X days/hours/weeks/months\"\n    const lastPeriodMatch = text.match(/last\\s+(\\d+)\\s+(day|days|hour|hours|week|weeks|month|months)/i);\n    if (lastPeriodMatch) {\n        const amount = parseInt(lastPeriodMatch[1]);\n        const unit = lastPeriodMatch[2].replace(/s$/, ''); // Remove plural 's'\n\n        const startDate = new Date(now);\n        switch (unit) {\n            case 'hour':\n                startDate.setHours(startDate.getHours() - amount);\n                break;\n            case 'day':\n                startDate.setDate(startDate.getDate() - amount);\n                break;\n            case 'week':\n                startDate.setDate(startDate.getDate() - (amount * 7));\n                break;\n            case 'month':\n                startDate.setMonth(startDate.getMonth() - amount);\n                break;\n        }\n\n        return {\n            startDate,\n            endDate: now,\n            period: `${amount} ${unit}${amount > 1 ? 's' : ''}`,\n            type: 'period',\n        };\n    }\n\n    // Check for \"today\"\n    if (text.includes('today')) {\n        const startOfDay = new Date(now);\n        startOfDay.setHours(0, 0, 0, 0);\n\n        return {\n            startDate: startOfDay,\n            endDate: now,\n            period: 'today',\n            type: 'period',\n        };\n    }\n\n    // Check for \"this week\"\n    if (text.includes('this week')) {\n        const startOfWeek = new Date(now);\n        startOfWeek.setDate(now.getDate() - now.getDay());\n        startOfWeek.setHours(0, 0, 0, 0);\n\n        return {\n            startDate: startOfWeek,\n            endDate: now,\n            period: 'this week',\n            type: 'period',\n        };\n    }\n\n    // Check for \"this month\"\n    if (text.includes('this month')) {\n        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n\n        return {\n            startDate: startOfMonth,\n            endDate: now,\n            period: 'this month',\n            type: 'period',\n        };\n    }\n\n    // Check for \"since [date]\"\n    const sinceMatch = text.match(/since\\s+(\\d{4}-\\d{2}-\\d{2})/i);\n    if (sinceMatch) {\n        return {\n            startDate: new Date(sinceMatch[1]),\n            endDate: now,\n            type: 'since',\n        };\n    }\n\n    // Check for \"until [date]\"\n    const untilMatch = text.match(/until\\s+(\\d{4}-\\d{2}-\\d{2})/i);\n    if (untilMatch) {\n        return {\n            endDate: new Date(untilMatch[1]),\n            type: 'until',\n        };\n    }\n\n    // Check for date range \"from [date] to [date]\"\n    const rangeMatch = text.match(/from\\s+(\\d{4}-\\d{2}-\\d{2})\\s+to\\s+(\\d{4}-\\d{2}-\\d{2})/i);\n    if (rangeMatch) {\n        return {\n            startDate: new Date(rangeMatch[1]),\n            endDate: new Date(rangeMatch[2]),\n            type: 'range',\n        };\n    }\n\n    return null;\n}\n\n/**\n * Format date filter as human-readable text\n */\nexport function formatDateFilterText(filter: DateFilter): string {\n    if (!filter) return '';\n\n    if (filter.period) {\n        return `Last ${filter.period}`;\n    }\n\n    if (filter.type === 'range' && filter.startDate && filter.endDate) {\n        return `${formatDate(filter.startDate)} to ${formatDate(filter.endDate)}`;\n    }\n\n    if (filter.type === 'since' && filter.startDate) {\n        return `Since ${formatDate(filter.startDate)}`;\n    }\n\n    if (filter.type === 'until' && filter.endDate) {\n        return `Until ${formatDate(filter.endDate)}`;\n    }\n\n    return '';\n}\n\n/**\n * Format date as YYYY-MM-DD\n */\nfunction formatDate(date: Date): string {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n}\n\n/**\n * Check if a date is within the filter range\n */\nexport function isDateInFilter(date: Date, filter: DateFilter): boolean {\n    if (!filter) return true;\n\n    const timestamp = date.getTime();\n\n    if (filter.startDate && timestamp < filter.startDate.getTime()) {\n        return false;\n    }\n\n    if (filter.endDate && timestamp > filter.endDate.getTime()) {\n        return false;\n    }\n\n    return true;\n}\n\n",
    "import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { AnalyticsService } from '../services/analyticsService';\nimport { getAccountFromMessage } from '../utils/messageUtils';\nimport { parseDateFilterFromMessage, formatDateFilterText } from '../utils/dateFilter';\nimport type { AccountAnalytics, MarketAnalytics, ComprehensiveTokenAnalytics } from '../interfaces/types';\n\n/**\n * Main Analytics Provider\n * Provides comprehensive analytics data from multiple sources\n */\nexport const analyticsProvider: Provider = {\n    name: 'ANALYTICS',\n    description: 'Comprehensive analytics platform providing token analysis, technical indicators, holder analytics, market data, and account insights from multiple data providers (Birdeye, CoinMarketCap, Codex)',\n    dynamic: true,\n    get: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        console.log('ANALYTICS')\n\n        let analyticsStr = ''\n\n        // DM or public?\n        const isDM = message.content.channelType?.toUpperCase() === 'DM'\n        if (isDM) {\n            const account = await getAccountFromMessage(runtime, message)\n            if (!account) {\n                return {\n                    data: {},\n                    values: {},\n                    text: 'No account found for this user.',\n                }\n            }\n\n            // Initialize analytics service\n            const analyticsService = new AnalyticsService(runtime);\n\n            // Parse message for analytics requests\n            const messageText = message.content?.text?.toLowerCase() || '';\n            const dateFilter = parseDateFilterFromMessage(messageText);\n\n            analyticsStr += `=== COMPREHENSIVE ANALYTICS REPORT ===\\n`\n\n            // Add date filter info if applied\n            if (dateFilter) {\n                analyticsStr += ` Date Filter: ${formatDateFilterText(dateFilter)}\\n\\n`\n            }\n\n            // Extract token addresses from user's positions\n            const uniqueTokens = new Set<string>()\n            if (account.walletAddress) {\n                uniqueTokens.add(account.walletAddress)\n            }\n\n            if (uniqueTokens.size === 0) {\n                analyticsStr += 'No token positions found for analysis.\\n'\n            } else {\n                analyticsStr += `Analyzing ${uniqueTokens.size} unique tokens from your positions...\\n\\n`\n\n                // Analyze each token with comprehensive analytics\n                for (const tokenAddress of uniqueTokens) {\n                    analyticsStr += await analyzeTokenComprehensive(analyticsService, tokenAddress, dateFilter)\n                    analyticsStr += '\\n' + '='.repeat(50) + '\\n\\n'\n                }\n\n                // Add portfolio analysis\n                analyticsStr += await analyzePortfolio(analyticsService, account, dateFilter)\n            }\n\n            // Add market overview\n            analyticsStr += await getMarketOverview(analyticsService)\n\n        } else {\n            analyticsStr = 'Comprehensive analytics are only available in private messages.'\n        }\n\n        console.log('analyticsStr', analyticsStr)\n\n        const data = {\n            comprehensiveAnalytics: analyticsStr\n        };\n\n        const values = {};\n\n        const text = analyticsStr + '\\n';\n\n        return {\n            data,\n            values,\n            text,\n        };\n    },\n};\n\n/**\n * Analyze a token with comprehensive analytics\n */\nasync function analyzeTokenComprehensive(analyticsService: AnalyticsService, tokenAddress: string, dateFilter?: any): Promise<string> {\n    let analysis = ` COMPREHENSIVE TOKEN ANALYSIS: ${tokenAddress}\\n`\n\n    try {\n        const request = {\n            tokenAddress,\n            chain: 'solana', // Default to Solana for now\n            timeframe: '1d' as const,\n            includeHistorical: true,\n            includeHolders: true,\n            includeSnipers: true\n        };\n\n        const response = await analyticsService.getTokenAnalytics(request);\n\n        if (!response.success || !response.data) {\n            analysis += ` Error analyzing token: ${response.error || 'Unknown error'}\\n`\n            return analysis;\n        }\n\n        const tokenData = response.data as ComprehensiveTokenAnalytics;\n\n        // Price Analysis\n        analysis += ` PRICE ANALYSIS:\\n`\n        analysis += `   Current Price: $${tokenData.price.price.toFixed(6)}\\n`\n        analysis += `   24h Change: ${tokenData.price.priceChangePercent24h >= 0 ? '+' : ''}${tokenData.price.priceChangePercent24h.toFixed(2)}%\\n`\n        analysis += `   24h Volume: $${tokenData.price.volume24h.toLocaleString()}\\n`\n        analysis += `   Market Cap: $${tokenData.price.marketCap.toLocaleString()}\\n\\n`\n\n        // Technical Analysis\n        analysis += ` TECHNICAL INDICATORS:\\n`\n        const tech = tokenData.technicalIndicators;\n        analysis += `   MACD: ${tech.macd.bullish ? ' Bullish' : ' Bearish'} (${tech.macd.macd.toFixed(6)})\\n`\n        analysis += `   RSI: ${tech.rsi.value.toFixed(2)} ${tech.rsi.overbought ? '(Overbought)' : tech.rsi.oversold ? '(Oversold)' : '(Neutral)'}\\n`\n        analysis += `   Bollinger Bands: ${tech.bollingerBands.percentB.toFixed(2)} (${tech.bollingerBands.percentB > 0.8 ? 'Upper' : tech.bollingerBands.percentB < 0.2 ? 'Lower' : 'Middle'})\\n`\n        analysis += `   Volume Ratio: ${tech.volume.volumeRatio.toFixed(2)}x average\\n\\n`\n\n        // Moving Averages\n        analysis += ` MOVING AVERAGES:\\n`\n        analysis += `   SMA 20: $${tech.movingAverages.sma20.toFixed(6)}\\n`\n        analysis += `   SMA 50: $${tech.movingAverages.sma50.toFixed(6)}\\n`\n        analysis += `   SMA 200: $${tech.movingAverages.sma200.toFixed(6)}\\n`\n        analysis += `   EMA 12: $${tech.movingAverages.ema12.toFixed(6)}\\n`\n        analysis += `   EMA 26: $${tech.movingAverages.ema26.toFixed(6)}\\n\\n`\n\n        // Holder Analytics (if available)\n        if (tokenData.holderAnalytics) {\n            analysis += ` HOLDER ANALYTICS:\\n`\n            const holders = tokenData.holderAnalytics;\n            analysis += `   Total Holders: ${holders.totalHolders.toLocaleString()}\\n`\n            analysis += `   Concentration Risk: ${holders.concentrationRisk.toUpperCase()}\\n`\n            analysis += `   Community Growth: ${holders.communityGrowth.toUpperCase()}\\n`\n            analysis += `   Acquisition Methods:\\n`\n            analysis += `    - Swaps: ${((holders.holdersByAcquisition.swap / holders.totalHolders) * 100).toFixed(1)}%\\n`\n            analysis += `    - Transfers: ${((holders.holdersByAcquisition.transfer / holders.totalHolders) * 100).toFixed(1)}%\\n`\n            analysis += `    - Airdrops: ${((holders.holdersByAcquisition.airdrop / holders.totalHolders) * 100).toFixed(1)}%\\n\\n`\n        }\n\n        // Sniper Analytics (if available)\n        if (tokenData.sniperAnalytics) {\n            analysis += ` SNIPER ACTIVITY:\\n`\n            const snipers = tokenData.sniperAnalytics;\n            analysis += `   Active Snipers: ${snipers.activeSnipers}\\n`\n            analysis += `   Total Sniped: $${snipers.totalSnipedUsd.toLocaleString()}\\n`\n            analysis += `   Total Sold: $${snipers.totalSoldUsd.toLocaleString()}\\n`\n            analysis += `   Total Profit: $${snipers.totalProfitUsd.toLocaleString()}\\n`\n            analysis += `   Average Profit: ${snipers.averageProfitPercent >= 0 ? '+' : ''}${snipers.averageProfitPercent.toFixed(2)}%\\n\\n`\n        }\n\n        // Risk Assessment\n        analysis += ` RISK ASSESSMENT:\\n`\n        const risk = tokenData.riskAssessment;\n        analysis += `   Overall Risk: ${risk.overallRisk.toUpperCase()}\\n`\n        analysis += `   Volatility: ${risk.volatility.toFixed(2)}%\\n`\n        analysis += `   Liquidity: ${risk.liquidity.toFixed(2)}%\\n`\n        analysis += `   Concentration Risk: ${risk.concentrationRisk.toUpperCase()}\\n`\n        analysis += `   Technical Risk: ${risk.technicalRisk.toUpperCase()}\\n\\n`\n\n        // Recommendations\n        analysis += ` RECOMMENDATIONS:\\n`\n        const rec = tokenData.recommendations;\n        analysis += `   Action: ${rec.action.toUpperCase()}\\n`\n        analysis += `   Confidence: ${rec.confidence.toFixed(0)}%\\n`\n        analysis += `   Reasons: ${rec.reasons.join(', ')}\\n`\n        analysis += `   Price Targets:\\n`\n        analysis += `    - Short Term: $${rec.priceTargets.shortTerm.toFixed(6)}\\n`\n        analysis += `    - Medium Term: $${rec.priceTargets.mediumTerm.toFixed(6)}\\n`\n        analysis += `    - Long Term: $${rec.priceTargets.longTerm.toFixed(6)}\\n\\n`\n\n    } catch (error) {\n        analysis += ` Error in comprehensive analysis: ${error}\\n`\n    }\n\n    return analysis;\n}\n\n/**\n * Analyze portfolio performance\n */\nasync function analyzePortfolio(analyticsService: AnalyticsService, account: any, dateFilter?: any): Promise<string> {\n    let analysis = ` PORTFOLIO ANALYSIS\\n`\n\n    try {\n        // Get account analytics\n        const request = {\n            walletAddress: account.walletAddress || 'unknown',\n            chain: 'solana'\n        };\n\n        const response = await analyticsService.getAccountAnalytics(request);\n\n        if (!response.success || !response.data) {\n            analysis += ` Error analyzing portfolio: ${response.error || 'Unknown error'}\\n\\n`\n            return analysis;\n        }\n\n        const portfolioData = response.data as AccountAnalytics;\n\n        analysis += ` PORTFOLIO OVERVIEW:\\n`\n        analysis += `   Total Value: $${portfolioData.totalValue.toLocaleString()}\\n`\n        analysis += `   24h Change: ${portfolioData.totalValueChangePercent24h >= 0 ? '+' : ''}${portfolioData.totalValueChangePercent24h.toFixed(2)}%\\n`\n        analysis += `   Total PnL: ${portfolioData.performance.totalPnLPercent >= 0 ? '+' : ''}${portfolioData.performance.totalPnLPercent.toFixed(2)}%\\n\\n`\n\n        analysis += ` PERFORMANCE METRICS:\\n`\n        analysis += `   Best Performer: ${portfolioData.performance.bestPerformer}\\n`\n        analysis += `   Worst Performer: ${portfolioData.performance.worstPerformer}\\n`\n        analysis += `   Sharpe Ratio: ${portfolioData.performance.riskMetrics.sharpeRatio.toFixed(2)}\\n`\n        analysis += `   Max Drawdown: ${portfolioData.performance.riskMetrics.maxDrawdown.toFixed(2)}%\\n`\n        analysis += `   Volatility: ${portfolioData.performance.riskMetrics.volatility.toFixed(2)}%\\n\\n`\n\n        analysis += ` TRADING HISTORY:\\n`\n        analysis += `   Total Trades: ${portfolioData.tradingHistory.totalTrades}\\n`\n        analysis += `   Win Rate: ${portfolioData.tradingHistory.winRate.toFixed(1)}%\\n`\n        analysis += `   Average Trade Size: $${portfolioData.tradingHistory.averageTradeSize.toLocaleString()}\\n\\n`\n\n        analysis += ` TOP HOLDINGS:\\n`\n        const sortedPortfolio = portfolioData.portfolio\n            .sort((a, b) => b.value - a.value)\n            .slice(0, 5);\n\n        for (let i = 0; i < sortedPortfolio.length; i++) {\n            const holding = sortedPortfolio[i];\n            analysis += `  ${i + 1}. ${holding.symbol}: $${holding.value.toLocaleString()} (${holding.allocation.toFixed(1)}%)\\n`\n        }\n        analysis += '\\n'\n\n    } catch (error) {\n        analysis += ` Error in portfolio analysis: ${error}\\n\\n`\n    }\n\n    return analysis;\n}\n\n/**\n * Get market overview\n */\nasync function getMarketOverview(analyticsService: AnalyticsService): Promise<string> {\n    let analysis = ` MARKET OVERVIEW\\n`\n\n    try {\n        const request = {\n            chain: 'solana'\n        };\n\n        const response = await analyticsService.getMarketAnalytics(request);\n\n        if (!response.success || !response.data) {\n            analysis += ` Error getting market data: ${response.error || 'Unknown error'}\\n\\n`\n            return analysis;\n        }\n\n        const marketData = response.data as MarketAnalytics;\n\n        analysis += ` MARKET METRICS:\\n`\n        analysis += `   Total Market Cap: $${marketData.marketCap.toLocaleString()}\\n`\n        analysis += `   24h Volume: $${marketData.volume24h.toLocaleString()}\\n`\n        analysis += `   Market Sentiment: ${getSentimentText(marketData.marketSentiment)}\\n\\n`\n\n        analysis += ` TOP GAINERS (24h):\\n`\n        for (let i = 0; i < Math.min(5, marketData.topGainers.length); i++) {\n            const token = marketData.topGainers[i];\n            analysis += `  ${i + 1}. ${token.symbol}: +${token.priceChangePercent24h.toFixed(2)}% ($${token.price.toFixed(6)})\\n`\n        }\n        analysis += '\\n'\n\n        analysis += ` TOP LOSERS (24h):\\n`\n        for (let i = 0; i < Math.min(5, marketData.topLosers.length); i++) {\n            const token = marketData.topLosers[i];\n            analysis += `  ${i + 1}. ${token.symbol}: ${token.priceChangePercent24h.toFixed(2)}% ($${token.price.toFixed(6)})\\n`\n        }\n        analysis += '\\n'\n\n        analysis += ` TRENDING TOKENS:\\n`\n        for (let i = 0; i < Math.min(5, marketData.trendingTokens.length); i++) {\n            const token = marketData.trendingTokens[i];\n            analysis += `  ${i + 1}. ${token.symbol}: $${token.volume24h.toLocaleString()} volume ($${token.price.toFixed(6)})\\n`\n        }\n        analysis += '\\n'\n\n    } catch (error) {\n        analysis += ` Error in market overview: ${error}\\n\\n`\n    }\n\n    return analysis;\n}\n\n/**\n * Get sentiment text from sentiment data\n */\nfunction getSentimentText(sentiment: any): string {\n    if (sentiment.bullish > 0.6) return ' Bullish';\n    if (sentiment.bearish > 0.6) return ' Bearish';\n    return ' Neutral';\n} ",
    "import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { AnalyticsService } from '../services/analyticsService';\nimport type { MarketAnalytics } from '../interfaces/types';\n\nexport const marketDataProvider: Provider = {\n    name: 'MARKET_DATA',\n    description: 'Real-time market data including top gainers, losers, trending tokens, and market sentiment across multiple chains',\n    dynamic: true,\n    get: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        console.log('MARKET_DATA')\n\n        let marketStr = ''\n\n        try {\n            const analyticsService = new AnalyticsService(runtime);\n            const response = await analyticsService.getMarketAnalytics({ chain: 'solana' });\n\n            if (response.success && response.data) {\n                const marketData = response.data as MarketAnalytics;\n\n                marketStr += ` MARKET OVERVIEW\\n`\n                marketStr += `Total Market Cap: $${marketData.marketCap.toLocaleString()}\\n`\n                marketStr += `24h Volume: $${marketData.volume24h.toLocaleString()}\\n\\n`\n\n                marketStr += ` TOP GAINERS (24h):\\n`\n                for (let i = 0; i < Math.min(3, marketData.topGainers.length); i++) {\n                    const token = marketData.topGainers[i];\n                    marketStr += `${i + 1}. ${token.symbol}: +${token.priceChangePercent24h.toFixed(2)}%\\n`\n                }\n                marketStr += '\\n'\n\n                marketStr += ` TOP LOSERS (24h):\\n`\n                for (let i = 0; i < Math.min(3, marketData.topLosers.length); i++) {\n                    const token = marketData.topLosers[i];\n                    marketStr += `${i + 1}. ${token.symbol}: ${token.priceChangePercent24h.toFixed(2)}%\\n`\n                }\n                marketStr += '\\n'\n\n                marketStr += ` TRENDING:\\n`\n                for (let i = 0; i < Math.min(3, marketData.trendingTokens.length); i++) {\n                    const token = marketData.trendingTokens[i];\n                    marketStr += `${i + 1}. ${token.symbol}: $${token.volume24h.toLocaleString()} volume\\n`\n                }\n            } else {\n                marketStr = 'Unable to fetch market data at this time.'\n            }\n        } catch (error) {\n            marketStr = 'Error fetching market data.'\n        }\n\n        const data = {\n            marketData: marketStr\n        };\n\n        const values = {};\n\n        const text = marketStr + '\\n';\n\n        return {\n            data,\n            values,\n            text,\n        };\n    },\n}; ",
    "import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\n\nexport const technicalIndicatorsProvider: Provider = {\n    name: 'TECHNICAL_INDICATORS',\n    description: 'Real-time technical indicators including MACD, RSI, Bollinger Bands, moving averages, and trading signals',\n    dynamic: true,\n    get: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        console.log('TECHNICAL_INDICATORS')\n\n        let technicalStr = ''\n\n        // Extract token address from message if available\n        const messageText = message.content?.text || '';\n        const tokenMatch = messageText.match(/0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44}/);\n\n        if (tokenMatch) {\n            try {\n                // Get the Birdeye service directly\n                const birdeyeService = runtime.getService('birdeye') as any;\n                if (!birdeyeService || typeof birdeyeService.getTokenMarketData !== 'function') {\n                    technicalStr = 'Birdeye service not available for technical analysis.';\n                } else {\n                    const tokenAddress = tokenMatch[0];\n                    console.log(`Token ${tokenAddress} not found in cache, attempting to fetch fresh data...`);\n\n                    // Use the Birdeye service to get market data which includes price history\n                    const marketData = await birdeyeService.getTokenMarketData(tokenAddress);\n\n                    if (marketData && marketData.price > 0) {\n                        console.log(`Successfully fetched price data from Birdeye plugin for ${tokenAddress}: $${marketData.price}`);\n\n                        // Calculate basic technical indicators from the available data\n                        const price = marketData.price;\n                        const priceHistory = marketData.priceHistory || [];\n\n                        if (priceHistory.length > 0) {\n                            // Calculate simple moving averages\n                            const sma20 = priceHistory.slice(-20).reduce((sum: number, p: number) => sum + p, 0) / Math.min(20, priceHistory.length);\n                            const sma50 = priceHistory.slice(-50).reduce((sum: number, p: number) => sum + p, 0) / Math.min(50, priceHistory.length);\n\n                            // Calculate RSI (simplified)\n                            const recentPrices = priceHistory.slice(-14);\n                            let gains = 0, losses = 0;\n                            for (let i = 1; i < recentPrices.length; i++) {\n                                const change = recentPrices[i] - recentPrices[i - 1];\n                                if (change > 0) gains += change;\n                                else losses -= change;\n                            }\n                            const avgGain = gains / 14;\n                            const avgLoss = losses / 14;\n                            const rs = avgGain / avgLoss;\n                            const rsi = 100 - (100 / (1 + rs));\n\n                            // Calculate MACD (simplified)\n                            const ema12 = priceHistory.slice(-12).reduce((sum: number, p: number) => sum + p, 0) / Math.min(12, priceHistory.length);\n                            const ema26 = priceHistory.slice(-26).reduce((sum: number, p: number) => sum + p, 0) / Math.min(26, priceHistory.length);\n                            const macd = ema12 - ema26;\n                            const signal = macd; // Simplified signal line\n                            const histogram = macd - signal;\n\n                            // Calculate Bollinger Bands\n                            const stdDev = Math.sqrt(priceHistory.slice(-20).reduce((sum: number, p: number) => sum + Math.pow(p - sma20, 2), 0) / Math.min(20, priceHistory.length));\n                            const upperBand = sma20 + (2 * stdDev);\n                            const lowerBand = sma20 - (2 * stdDev);\n                            const percentB = (price - lowerBand) / (upperBand - lowerBand);\n\n                            // Volume analysis\n                            const volumeRatio = marketData.volume24h > 0 ? 1.0 : 0.5; // Simplified\n\n                            technicalStr += ` TECHNICAL INDICATORS: ${tokenAddress}\\n\\n`\n\n                            technicalStr += ` MACD: ${macd > signal ? ' Bullish' : ' Bearish'}\\n`\n                            technicalStr += ` RSI: ${rsi.toFixed(2)} ${rsi > 70 ? '(Overbought)' : rsi < 30 ? '(Oversold)' : '(Neutral)'}\\n`\n                            technicalStr += ` BB %B: ${percentB.toFixed(3)}\\n`\n                            technicalStr += ` Volume: ${volumeRatio.toFixed(2)}x average\\n`\n                            technicalStr += ` Current Price: $${price.toFixed(6)}\\n`\n                            technicalStr += ` SMA20: $${sma20.toFixed(6)}\\n`\n                            technicalStr += ` SMA50: $${sma50.toFixed(6)}\\n`\n                        } else {\n                            technicalStr += ` TECHNICAL INDICATORS: ${tokenAddress}\\n\\n`\n                            technicalStr += ` Current Price: $${price.toFixed(6)}\\n`\n                            technicalStr += ` Insufficient historical data for full technical analysis.\\n`\n                        }\n                    } else {\n                        technicalStr = 'Unable to fetch price data for this token.';\n                    }\n                }\n            } catch (error) {\n                console.error('Error calculating technical indicators:', error);\n                technicalStr = 'Error calculating technical indicators.';\n            }\n        } else {\n            technicalStr = 'Please provide a token address to analyze technical indicators.';\n        }\n\n        const data = {\n            technicalIndicators: technicalStr\n        };\n\n        const values = {};\n\n        const text = technicalStr + '\\n';\n\n        return {\n            data,\n            values,\n            text,\n        };\n    },\n}; ",
    "import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { AnalyticsService } from '../services/analyticsService';\nimport type { ComprehensiveTokenAnalytics } from '../interfaces/types';\n\nexport const historicalDataProvider: Provider = {\n    name: 'HISTORICAL_DATA',\n    description: 'Historical price data and trend analysis for tokens across different timeframes',\n    dynamic: true,\n    get: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        console.log('HISTORICAL_DATA')\n\n        let historicalStr = ''\n\n        // Extract token address from message if available\n        const messageText = message.content?.text || '';\n        const tokenMatch = messageText.match(/0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44}/);\n\n        if (tokenMatch) {\n            try {\n                const analyticsService = new AnalyticsService(runtime);\n                const response = await analyticsService.getTokenAnalytics({\n                    tokenAddress: tokenMatch[0],\n                    chain: 'solana',\n                    timeframe: '1d',\n                    includeHistorical: true,\n                    includeHolders: false,\n                    includeSnipers: false\n                });\n\n                if (response.success && response.data && 'historicalData' in response.data && response.data.historicalData.length > 0) {\n                    const historicalData = response.data.historicalData;\n                    const firstPrice = historicalData[0].close;\n                    const lastPrice = historicalData[historicalData.length - 1].close;\n                    const totalChange = ((lastPrice - firstPrice) / firstPrice) * 100;\n\n                    historicalStr += ` HISTORICAL DATA: ${(response.data as ComprehensiveTokenAnalytics).symbol}\\n\\n`\n                    historicalStr += `Period: ${historicalData.length} days\\n`\n                    historicalStr += `Start Price: $${firstPrice.toFixed(6)}\\n`\n                    historicalStr += `End Price: $${lastPrice.toFixed(6)}\\n`\n                    historicalStr += `Total Change: ${totalChange >= 0 ? '+' : ''}${totalChange.toFixed(2)}%\\n`\n                } else {\n                    historicalStr = 'No historical data available for this token.'\n                }\n            } catch (error) {\n                historicalStr = 'Error fetching historical data.'\n            }\n        } else {\n            historicalStr = 'Please provide a token address to analyze historical data.'\n        }\n\n        const data = {\n            historicalData: historicalStr\n        };\n\n        const values = {};\n\n        const text = historicalStr + '\\n';\n\n        return {\n            data,\n            values,\n            text,\n        };\n    },\n}; ",
    "import type { IAgentRuntime } from '@elizaos/core';\nimport { logger, Service } from '@elizaos/core';\nimport { BirdeyeProvider } from '../providers/birdeyeProvider';\nimport { CoinMarketCapProvider } from '../providers/coinmarketcapProvider';\n\nexport class MarketDataService extends Service {\n    private isRunning = false;\n    static serviceType = 'MARKET_DATA_SERVICE';\n\n    capabilityDescription = 'Market data service for token prices and market information';\n\n    private birdeyeProvider?: BirdeyeProvider;\n    private coinmarketcapProvider?: CoinMarketCapProvider;\n\n    constructor(runtime: IAgentRuntime) {\n        super(runtime);\n\n        try {\n            this.birdeyeProvider = new BirdeyeProvider(runtime);\n        } catch (error) {\n            console.warn('Birdeye provider not available for market data service');\n        }\n\n        try {\n            this.coinmarketcapProvider = new CoinMarketCapProvider(runtime);\n        } catch (error) {\n            console.warn('CoinMarketCap provider not available for market data service');\n        }\n    }\n\n    async getMarketData(chain: string = 'solana') {\n        if (chain === 'solana' && this.birdeyeProvider) {\n            return await this.birdeyeProvider.getMarketData(chain);\n        }\n\n        if (this.coinmarketcapProvider) {\n            return await this.coinmarketcapProvider.getMarketData(chain);\n        }\n\n        return null;\n    }\n\n    async getTokenPrice(tokenAddress: string, chain: string = 'solana') {\n        if (chain === 'solana' && this.birdeyeProvider) {\n            return await this.birdeyeProvider.getTokenPrice(tokenAddress, chain);\n        }\n\n        if (this.coinmarketcapProvider) {\n            return await this.coinmarketcapProvider.getTokenPrice(tokenAddress, chain);\n        }\n\n        return null;\n    }\n\n\n    /**\n     * Start the scenario service with the given runtime.\n     * @param {IAgentRuntime} runtime - The agent runtime\n     * @returns {Promise<ScenarioService>} - The started scenario service\n     */\n    static async start(runtime: IAgentRuntime) {\n        const service = new MarketDataService(runtime);\n        service.start();\n        return service;\n    }\n    /**\n     * Stops the Scenario service associated with the given runtime.\n     *\n     * @param {IAgentRuntime} runtime The runtime to stop the service for.\n     * @throws {Error} When the Scenario service is not found.\n     */\n    static async stop(runtime: IAgentRuntime) {\n        const service = runtime.getService(this.serviceType);\n        if (!service) {\n            throw new Error(this.serviceType + ' service not found');\n        }\n        service.stop();\n    }\n\n    async start(): Promise<void> {\n        if (this.isRunning) {\n            logger.warn('MARKET_DATA_SERVICE service is already running');\n            return;\n        }\n\n        try {\n            logger.info('MARKET_DATA_SERVICE trading service...');\n\n            this.isRunning = true;\n            logger.info('MARKET_DATA_SERVICE service started successfully');\n        } catch (error) {\n            logger.error('Error starting MARKET_DATA_SERVICE service:', error as string);\n            throw error;\n        }\n    }\n\n    async stop(): Promise<void> {\n        if (!this.isRunning) {\n            logger.warn('MARKET_DATA_SERVICE service is not running');\n            return;\n        }\n\n        try {\n            logger.info('Stopping MARKET_DATA_SERVICE service...');\n\n            this.isRunning = false;\n            logger.info('MARKET_DATA_SERVICE stopped successfully');\n        } catch (error) {\n            logger.error('Error stopping MARKET_DATA_SERVICE service:', error as string);\n            throw error;\n        }\n    }\n\n    isServiceRunning(): boolean {\n        return this.isRunning;\n    }\n} ",
    "import type { IAgentRuntime } from '@elizaos/core';\nimport type {\n    TokenPriceData,\n    HistoricalPriceData,\n    MarketAnalytics,\n    AccountAnalytics\n} from '../interfaces/types';\n\n/**\n * Birdeye Data Provider\n * Integrates with Birdeye API for Solana token data\n */\nexport class BirdeyeProvider {\n    private runtime: IAgentRuntime;\n    private apiKey: string;\n    private readonly API_BASE_URL = 'https://public-api.birdeye.so';\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n        this.apiKey = runtime.getSetting('BIRDEYE_API_KEY') as string;\n\n        if (!this.apiKey) {\n            throw new Error('Birdeye API key not configured');\n        }\n    }\n\n    /**\n     * Get token price data from Birdeye\n     */\n    async getTokenPrice(tokenAddress: string, chain: string = 'solana'): Promise<TokenPriceData | null> {\n        try {\n            const cacheKey = `birdeye_price_${tokenAddress}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            console.log(`Fetching price for token ${tokenAddress} from Birdeye API...`);\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'x-chain': chain,\n                    'X-API-KEY': this.apiKey,\n                },\n            };\n\n            // Try the main price endpoint first\n            let url = `${this.API_BASE_URL}/defi/price?address=${tokenAddress}`;\n            console.log(`Making request to: ${url}`);\n\n            let response = await fetch(url, options);\n\n            // If the main endpoint fails, try the token overview endpoint\n            if (!response.ok || response.status === 404) {\n                console.log(`Main price endpoint failed, trying token overview endpoint...`);\n                url = `${this.API_BASE_URL}/defi/token_overview?address=${tokenAddress}`;\n                console.log(`Making request to: ${url}`);\n                response = await fetch(url, options);\n            }\n\n            console.log(`Birdeye API response status: ${response.status}`);\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`Birdeye API error response: ${errorText}`);\n                throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);\n            }\n\n            // Check if response has content\n            const responseText = await response.text();\n            console.log(`Birdeye API raw response: ${responseText}`);\n\n            if (!responseText || responseText.trim() === '') {\n                console.warn(`Birdeye API returned empty response for token ${tokenAddress}`);\n                return null;\n            }\n\n            let data;\n            try {\n                data = JSON.parse(responseText);\n                console.log(`Birdeye API response data:`, JSON.stringify(data, null, 2));\n            } catch (parseError) {\n                console.error(`Failed to parse Birdeye API response as JSON: ${responseText}`);\n                return null;\n            }\n\n            let tokenData = data?.data;\n\n            if (!tokenData) {\n                console.warn(`No token data found in Birdeye response for ${tokenAddress}`);\n                return null;\n            }\n\n            // Handle different response formats from price vs overview endpoints\n            const priceData: TokenPriceData = {\n                timestamp: Date.now(),\n                source: 'birdeye',\n                chain: chain,\n                tokenAddress: tokenAddress,\n                symbol: tokenData.symbol || tokenData.name || 'UNKNOWN',\n                price: tokenData.value || tokenData.price || 0,\n                priceChange24h: tokenData.priceChange24h || 0,\n                priceChangePercent24h: tokenData.priceChangePercent24h || tokenData.priceChangePercent || 0,\n                volume24h: tokenData.volume24h || tokenData.volume || 0,\n                marketCap: tokenData.marketCap || tokenData.marketcap || 0,\n                circulatingSupply: tokenData.circulatingSupply || tokenData.circulating_supply,\n                totalSupply: tokenData.totalSupply || tokenData.total_supply,\n            };\n\n            console.log(`Successfully parsed price data: $${priceData.price} for ${tokenData.symbol}`);\n\n            await this.setCachedData(cacheKey, priceData, 60); // 1 minute cache\n            return priceData;\n        } catch (error) {\n            console.error('Error fetching token price from Birdeye:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get historical price data from Birdeye using the correct endpoint\n     */\n    async getHistoricalData(\n        tokenAddress: string,\n        chain: string = 'solana',\n        timeframe: string = '1d'\n    ): Promise<HistoricalPriceData[]> {\n        try {\n            const cacheKey = `birdeye_historical_${tokenAddress}_${timeframe}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'x-chain': chain,\n                    'X-API-KEY': this.apiKey,\n                },\n            };\n\n            // Convert timeframe to Birdeye format\n            const interval = this.convertTimeframeToInterval(timeframe);\n\n            // Use the correct historical price endpoint\n            const url = `${this.API_BASE_URL}/defi/history_price?address=${tokenAddress}&address_type=token&type=${interval}`;\n            console.log(`Fetching historical data from: ${url}`);\n\n            const response = await fetch(url, options);\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`Birdeye historical API error: ${errorText}`);\n                throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);\n            }\n\n            const data = await response.json();\n            console.log(`Historical data response:`, JSON.stringify(data, null, 2));\n\n            if (!data.success || !data.data || !data.data.items) {\n                console.warn(`No historical data found for token ${tokenAddress}`);\n                return [];\n            }\n\n            const historyData = data.data.items;\n            console.log(`Found ${historyData.length} historical data points`);\n\n            const historicalData: HistoricalPriceData[] = historyData.map((item: any) => ({\n                timestamp: item.unixTime ? item.unixTime * 1000 : Date.now(),\n                open: item.o || item.open || item.value || 0,\n                high: item.h || item.high || item.value || 0,\n                low: item.l || item.low || item.value || 0,\n                close: item.c || item.close || item.value || 0,\n                volume: item.v || item.volume || 0,\n            }));\n\n            await this.setCachedData(cacheKey, historicalData, 300); // 5 minutes cache\n            return historicalData;\n        } catch (error) {\n            console.error('Error fetching historical data from Birdeye:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Get OHLCV data from Birdeye for better technical analysis\n     */\n    async getOHLCVData(\n        tokenAddress: string,\n        chain: string = 'solana',\n        timeframe: string = '1d'\n    ): Promise<HistoricalPriceData[]> {\n        try {\n            const cacheKey = `birdeye_ohlcv_${tokenAddress}_${timeframe}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'x-chain': chain,\n                    'X-API-KEY': this.apiKey,\n                },\n            };\n\n            // Convert timeframe to Birdeye format\n            const interval = this.convertTimeframeToInterval(timeframe);\n\n            // Use the OHLCV endpoint for better candlestick data\n            const url = `${this.API_BASE_URL}/defi/ohlcv?address=${tokenAddress}&type=${interval}`;\n            console.log(`Fetching OHLCV data from: ${url}`);\n\n            const response = await fetch(url, options);\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`Birdeye OHLCV API error: ${errorText}`);\n                throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);\n            }\n\n            const data = await response.json();\n            console.log(`OHLCV data response:`, JSON.stringify(data, null, 2));\n\n            if (!data.success || !data.data || !data.data.items) {\n                console.warn(`No OHLCV data found for token ${tokenAddress}, falling back to historical price data`);\n                return this.getHistoricalData(tokenAddress, chain, timeframe);\n            }\n\n            const ohlcvData = data.data.items;\n            console.log(`Found ${ohlcvData.length} OHLCV data points`);\n\n            const historicalData: HistoricalPriceData[] = ohlcvData.map((item: any) => ({\n                timestamp: item.unixTime ? item.unixTime * 1000 : Date.now(),\n                open: item.o || 0,\n                high: item.h || 0,\n                low: item.l || 0,\n                close: item.c || 0,\n                volume: item.v || 0,\n            }));\n\n            await this.setCachedData(cacheKey, historicalData, 300); // 5 minutes cache\n            return historicalData;\n        } catch (error) {\n            console.error('Error fetching OHLCV data from Birdeye:', error);\n            // Fall back to historical price data\n            return this.getHistoricalData(tokenAddress, chain, timeframe);\n        }\n    }\n\n    /**\n     * Get market data from Birdeye\n     */\n    async getMarketData(chain: string = 'solana'): Promise<MarketAnalytics | null> {\n        try {\n            const cacheKey = `birdeye_market_${chain}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'x-chain': chain,\n                    'X-API-KEY': this.apiKey,\n                },\n            };\n\n            // Get trending tokens\n            const trendingResponse = await fetch(\n                `${this.API_BASE_URL}/defi/token_trending?sort_by=rank&sort_type=asc&offset=0&limit=20`,\n                options\n            );\n\n            if (!trendingResponse.ok) {\n                throw new Error(`HTTP error! status: ${trendingResponse.status}`);\n            }\n\n            const trendingData = await trendingResponse.json();\n            const trendingTokens = trendingData?.data?.tokens || [];\n\n            // Get top gainers and losers\n            const gainersResponse = await fetch(\n                `${this.API_BASE_URL}/defi/token_trending?sort_by=priceChangePercent24h&sort_type=desc&offset=0&limit=10`,\n                options\n            );\n\n            const losersResponse = await fetch(\n                `${this.API_BASE_URL}/defi/token_trending?sort_by=priceChangePercent24h&sort_type=asc&offset=0&limit=10`,\n                options\n            );\n\n            const gainersData = await gainersResponse.json();\n            const losersData = await losersResponse.json();\n\n            const topGainers = (gainersData?.data?.tokens || []).map((token: any) => ({\n                timestamp: Date.now(),\n                source: 'birdeye' as const,\n                chain: chain,\n                tokenAddress: token.address,\n                symbol: token.symbol,\n                price: token.price || 0,\n                priceChange24h: token.priceChange24h || 0,\n                priceChangePercent24h: token.priceChangePercent24h || 0,\n                volume24h: token.volume24h || 0,\n                marketCap: token.marketCap || 0,\n            }));\n\n            const topLosers = (losersData?.data?.tokens || []).map((token: any) => ({\n                timestamp: Date.now(),\n                source: 'birdeye' as const,\n                chain: chain,\n                tokenAddress: token.address,\n                symbol: token.symbol,\n                price: token.price || 0,\n                priceChange24h: token.priceChange24h || 0,\n                priceChangePercent24h: token.priceChangePercent24h || 0,\n                volume24h: token.volume24h || 0,\n                marketCap: token.marketCap || 0,\n            }));\n\n            const trendingTokensData = trendingTokens.map((token: any) => ({\n                timestamp: Date.now(),\n                source: 'birdeye' as const,\n                chain: chain,\n                tokenAddress: token.address,\n                symbol: token.symbol,\n                price: token.price || 0,\n                priceChange24h: token.priceChange24h || 0,\n                priceChangePercent24h: token.priceChangePercent24h || 0,\n                volume24h: token.volume24h || 0,\n                marketCap: token.marketCap || 0,\n            }));\n\n            const marketAnalytics: MarketAnalytics = {\n                marketCap: 0, // Would need to calculate from all tokens\n                volume24h: 0, // Would need to calculate from all tokens\n                dominance: 0, // Would need market cap data\n                topGainers,\n                topLosers,\n                trendingTokens: trendingTokensData,\n                marketSentiment: {\n                    bullish: 0.6, // Placeholder - would need sentiment analysis\n                    bearish: 0.2,\n                    neutral: 0.2,\n                },\n            };\n\n            await this.setCachedData(cacheKey, marketAnalytics, 300); // 5 minutes cache\n            return marketAnalytics;\n        } catch (error) {\n            console.error('Error fetching market data from Birdeye:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Get account/wallet data from Birdeye\n     */\n    async getAccountData(walletAddress: string, chain: string = 'solana'): Promise<AccountAnalytics | null> {\n        try {\n            const cacheKey = `birdeye_account_${walletAddress}`;\n            const cached = await this.getCachedData(cacheKey);\n            if (cached) return cached;\n\n            const options = {\n                method: 'GET',\n                headers: {\n                    accept: 'application/json',\n                    'x-chain': chain,\n                    'X-API-KEY': this.apiKey,\n                },\n            };\n\n            // Get wallet portfolio\n            const portfolioResponse = await fetch(\n                `${this.API_BASE_URL}/v1/wallet/token_list?wallet=${walletAddress}`,\n                options\n            );\n\n            if (!portfolioResponse.ok) {\n                throw new Error(`HTTP error! status: ${portfolioResponse.status}`);\n            }\n\n            const portfolioData = await portfolioResponse.json();\n            const tokens = portfolioData?.data || [];\n\n            // Get wallet value\n            const valueResponse = await fetch(\n                `${this.API_BASE_URL}/v1/wallet/portfolio?wallet=${walletAddress}`,\n                options\n            );\n\n            const valueData = await valueResponse.json();\n            const portfolioValue = valueData?.data?.value || 0;\n\n            const portfolio = tokens.map((token: any) => ({\n                tokenAddress: token.address,\n                symbol: token.symbol,\n                balance: token.balance || 0,\n                value: token.value || 0,\n                valueChange24h: token.valueChange24h || 0,\n                allocation: token.value > 0 ? (token.value / portfolioValue) * 100 : 0,\n            }));\n\n            const accountAnalytics: AccountAnalytics = {\n                walletAddress,\n                totalValue: portfolioValue,\n                totalValueChange24h: 0, // Would need historical data\n                totalValueChangePercent24h: 0, // Would need historical data\n                portfolio,\n                performance: {\n                    totalPnL: 0, // Would need historical data\n                    totalPnLPercent: 0,\n                    bestPerformer: portfolio.length > 0 ? portfolio[0].symbol : '',\n                    worstPerformer: portfolio.length > 0 ? portfolio[0].symbol : '',\n                    riskMetrics: {\n                        sharpeRatio: 0,\n                        maxDrawdown: 0,\n                        volatility: 0,\n                    },\n                },\n                tradingHistory: {\n                    totalTrades: 0, // Would need transaction history\n                    winningTrades: 0,\n                    losingTrades: 0,\n                    winRate: 0,\n                    averageTradeSize: 0,\n                },\n            };\n\n            await this.setCachedData(cacheKey, accountAnalytics, 300); // 5 minutes cache\n            return accountAnalytics;\n        } catch (error) {\n            console.error('Error fetching account data from Birdeye:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Convert timeframe to Birdeye interval format\n     */\n    private convertTimeframeToInterval(timeframe: string): string {\n        switch (timeframe) {\n            case '1m': return '1m';\n            case '3m': return '3m';\n            case '5m': return '5m';\n            case '15m': return '15m';\n            case '30m': return '30m';\n            case '1h': return '1H';\n            case '2h': return '2H';\n            case '4h': return '4H';\n            case '6h': return '6H';\n            case '8h': return '8H';\n            case '12h': return '12H';\n            case '1d': return '1D';\n            case '3d': return '3D';\n            case '1w': return '1W';\n            case '1m': return '1M';\n            default: return '1D';\n        }\n    }\n\n    /**\n     * Get number of data points for timeframe\n     */\n    private getDataPointsForTimeframe(timeframe: string): number {\n        switch (timeframe) {\n            case '1h': return 168; // 1 week of hourly data\n            case '4h': return 168; // 4 weeks of 4h data\n            case '1d': return 365; // 1 year of daily data\n            case '1w': return 52; // 1 year of weekly data\n            case '1m': return 12; // 1 year of monthly data\n            default: return 30; // 30 days of daily data\n        }\n    }\n\n    /**\n     * Get cached data\n     */\n    private async getCachedData(key: string): Promise<any | null> {\n        try {\n            return await this.runtime.getCache(key);\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * Set cached data\n     */\n    private async setCachedData(key: string, data: any, ttlSeconds: number): Promise<void> {\n        try {\n            await this.runtime.setCache(key, data);\n        } catch (error) {\n            console.error('Failed to cache data:', error);\n        }\n    }\n}",
    "import type { IAgentRuntime } from '@elizaos/core';\nimport { logger, Service } from '@elizaos/core';\nimport {\n    calculateMACD,\n    calculateRSI,\n    calculateBollingerBands,\n    calculateVolumeIndicators,\n    generateSignals\n} from '../utils/technicalAnalysis';\n\nexport class TechnicalAnalysisService extends Service {\n    private isRunning = false;\n    static serviceType = 'TECHNICAL_ANALYSIS_SERVICE';\n\n    capabilityDescription = 'Technical analysis service for calculating indicators and signals';\n\n    constructor(runtime: IAgentRuntime) {\n        super(runtime);\n    }\n\n    /**\n     * Get technical indicators for a token using Birdeye data\n     */\n    async getTechnicalIndicators(tokenAddress: string, chain: string = 'solana'): Promise<any> {\n        try {\n            // Get Birdeye service for price data\n            const birdeyeService = this.runtime.getService('birdeye') as any;\n            if (!birdeyeService || typeof birdeyeService.getTokenMarketData !== 'function') {\n                logger.warn('Birdeye service not available for technical analysis');\n                return this.getEmptyTechnicalIndicators();\n            }\n\n            // Get current market data\n            const marketData = await (birdeyeService as any).getTokenMarketData(tokenAddress);\n            if (!marketData || marketData.price <= 0) {\n                logger.warn(`No valid price data available for ${tokenAddress}`);\n                return this.getEmptyTechnicalIndicators();\n            }\n\n            // Get price history for technical analysis\n            const priceHistory = marketData.priceHistory || [];\n            if (priceHistory.length < 50) {\n                logger.warn(`Insufficient price history for ${tokenAddress}: ${priceHistory.length} points (need at least 50)`);\n                return this.getEmptyTechnicalIndicators();\n            }\n\n            // Calculate technical indicators\n            const technicalIndicators = await this.calculateTechnicalIndicatorsFromPrices(priceHistory);\n\n            return {\n                success: true,\n                data: {\n                    tokenAddress,\n                    symbol: 'UNKNOWN', // Birdeye doesn't provide symbol in getTokenMarketData\n                    price: marketData.price,\n                    volume24h: marketData.volume24h,\n                    marketCap: marketData.marketCap,\n                    technicalIndicators\n                }\n            };\n\n        } catch (error) {\n            logger.error('Error calculating technical indicators:', error as string);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n                data: this.getEmptyTechnicalIndicators()\n            };\n        }\n    }\n\n    /**\n     * Calculate technical indicators from price data\n     */\n    private async calculateTechnicalIndicatorsFromPrices(prices: number[]): Promise<any> {\n        if (prices.length < 50) {\n            return this.getEmptyTechnicalIndicators();\n        }\n\n        // Calculate MACD\n        const macdResult = calculateMACD(prices);\n        const currentMACD = macdResult.macd[macdResult.macd.length - 1] || 0;\n        const currentSignal = macdResult.signal[macdResult.signal.length - 1] || 0;\n        const currentHistogram = macdResult.histogram[macdResult.histogram.length - 1] || 0;\n\n        // Calculate RSI\n        const rsiResult = calculateRSI(prices);\n        const currentRSI = rsiResult[rsiResult.length - 1] || 50;\n\n        // Calculate Bollinger Bands\n        const bbResult = calculateBollingerBands(prices);\n        const currentBB = {\n            upper: bbResult.upper[bbResult.upper.length - 1] || 0,\n            middle: bbResult.middle[bbResult.middle.length - 1] || 0,\n            lower: bbResult.lower[bbResult.lower.length - 1] || 0,\n            bandwidth: bbResult.bandwidth[bbResult.bandwidth.length - 1] || 0,\n            percentB: bbResult.percentB[bbResult.percentB.length - 1] || 0.5\n        };\n\n        // Calculate Moving Averages\n        const sma20 = this.calculateSMA(prices, 20);\n        const sma50 = this.calculateSMA(prices, 50);\n        const sma200 = this.calculateSMA(prices, 200);\n        const ema12 = this.calculateEMA(prices, 12);\n        const ema26 = this.calculateEMA(prices, 26);\n\n        // Calculate Volume indicators (using price as proxy for volume since we don't have volume data)\n        const volumeResult = calculateVolumeIndicators(prices, prices); // Using prices as proxy for volumes\n\n        return {\n            macd: {\n                macd: currentMACD,\n                signal: currentSignal,\n                histogram: currentHistogram,\n                bullish: currentMACD > currentSignal\n            },\n            rsi: {\n                value: currentRSI,\n                overbought: currentRSI > 70,\n                oversold: currentRSI < 30\n            },\n            bollingerBands: currentBB,\n            movingAverages: {\n                sma20: sma20[sma20.length - 1] || 0,\n                sma50: sma50[sma50.length - 1] || 0,\n                sma200: sma200[sma200.length - 1] || 0,\n                ema12: ema12[ema12.length - 1] || 0,\n                ema26: ema26[ema26.length - 1] || 0\n            },\n            volume: {\n                volumeSMA: volumeResult.volumeSMA[volumeResult.volumeSMA.length - 1] || 0,\n                volumeRatio: volumeResult.volumeRatio[volumeResult.volumeRatio.length - 1] || 1,\n                onBalanceVolume: volumeResult.onBalanceVolume[volumeResult.onBalanceVolume.length - 1] || 0\n            }\n        };\n    }\n\n    /**\n     * Get empty technical indicators when data is insufficient\n     */\n    private getEmptyTechnicalIndicators() {\n        return {\n            macd: { macd: 0, signal: 0, histogram: 0, bullish: false },\n            rsi: { value: 50, overbought: false, oversold: false },\n            bollingerBands: { upper: 0, middle: 0, lower: 0, bandwidth: 0, percentB: 0.5 },\n            movingAverages: { sma20: 0, sma50: 0, sma200: 0, ema12: 0, ema26: 0 },\n            volume: { volumeSMA: 0, volumeRatio: 1, onBalanceVolume: 0 }\n        };\n    }\n\n    calculateMACD(prices: number[], fastPeriod: number = 12, slowPeriod: number = 26, signalPeriod: number = 9) {\n        return calculateMACD(prices, fastPeriod, slowPeriod, signalPeriod);\n    }\n\n    calculateRSI(prices: number[], period: number = 14) {\n        return calculateRSI(prices, period);\n    }\n\n    calculateBollingerBands(prices: number[], period: number = 20, standardDeviations: number = 2) {\n        return calculateBollingerBands(prices, period, standardDeviations);\n    }\n\n    calculateMovingAverages(prices: number[], periods: number[]) {\n        const result: { [period: number]: number[] } = {};\n        for (const period of periods) {\n            result[period] = this.calculateSMA(prices, period);\n        }\n        return result;\n    }\n\n    calculateVolumeIndicators(prices: number[], volumes: number[], period: number = 20) {\n        return calculateVolumeIndicators(prices, volumes, period);\n    }\n\n    generateSignals(prices: number[], volumes: number[], highs: number[], lows: number[]) {\n        return generateSignals(prices, volumes, highs, lows);\n    }\n\n    /**\n     * Calculate Simple Moving Average\n     */\n    private calculateSMA(prices: number[], period: number): number[] {\n        if (prices.length < period) return [];\n\n        const sma: number[] = [];\n        for (let i = period - 1; i < prices.length; i++) {\n            const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);\n            sma.push(sum / period);\n        }\n        return sma;\n    }\n\n    /**\n     * Calculate Exponential Moving Average\n     */\n    private calculateEMA(prices: number[], period: number): number[] {\n        if (prices.length < period) return [];\n\n        const ema: number[] = [];\n        const multiplier = 2 / (period + 1);\n\n        // First EMA is SMA\n        let sum = 0;\n        for (let i = 0; i < period; i++) {\n            sum += prices[i];\n        }\n        ema.push(sum / period);\n\n        // Calculate EMA for remaining prices\n        for (let i = period; i < prices.length; i++) {\n            const currentEMA = (prices[i] * multiplier) + (ema[ema.length - 1] * (1 - multiplier));\n            ema.push(currentEMA);\n        }\n\n        return ema;\n    }\n\n    /**\n     * Start the technical analysis service with the given runtime.\n     * @param {IAgentRuntime} runtime - The agent runtime\n     * @returns {Promise<TechnicalAnalysisService>} - The started technical analysis service\n     */\n    static async start(runtime: IAgentRuntime) {\n        const service = new TechnicalAnalysisService(runtime);\n        service.start();\n        return service;\n    }\n\n    /**\n     * Stops the Technical Analysis service associated with the given runtime.\n     *\n     * @param {IAgentRuntime} runtime The runtime to stop the service for.\n     * @throws {Error} When the Technical Analysis service is not found.\n     */\n    static async stop(runtime: IAgentRuntime) {\n        const service = runtime.getService(this.serviceType);\n        if (!service) {\n            throw new Error(this.serviceType + ' service not found');\n        }\n        service.stop();\n    }\n\n    async start(): Promise<void> {\n        if (this.isRunning) {\n            logger.warn('TECHNICAL_ANALYSIS_SERVICE service is already running');\n            return;\n        }\n\n        try {\n            logger.info('Starting TECHNICAL_ANALYSIS_SERVICE...');\n\n            this.isRunning = true;\n            logger.info('TECHNICAL_ANALYSIS_SERVICE service started successfully');\n        } catch (error) {\n            logger.error('Error starting TECHNICAL_ANALYSIS_SERVICE service:', error as string);\n            throw error;\n        }\n    }\n\n    async stop(): Promise<void> {\n        if (!this.isRunning) {\n            logger.warn('TECHNICAL_ANALYSIS_SERVICE service is not running');\n            return;\n        }\n\n        try {\n            logger.info('Stopping TECHNICAL_ANALYSIS_SERVICE service...');\n\n            this.isRunning = false;\n            logger.info('TECHNICAL_ANALYSIS_SERVICE stopped successfully');\n        } catch (error) {\n            logger.error('Error stopping TECHNICAL_ANALYSIS_SERVICE service:', error as string);\n            throw error;\n        }\n    }\n\n    isServiceRunning(): boolean {\n        return this.isRunning;\n    }\n} ",
    "import type { Plugin } from '@elizaos/core';\n\n// Actions\nimport getTokenAnalytics from './actions/getTokenAnalytics';\nimport getAccountAnalytics from './actions/getAccountAnalytics';\nimport getMarketAnalytics from './actions/getMarketAnalytics';\nimport getHistoricalAnalytics from './actions/getHistoricalAnalytics';\nimport getTechnicalIndicators from './actions/getTechnicalIndicators';\n\n// Providers\nimport { analyticsProvider } from './providers/analytics';\nimport { marketDataProvider } from './providers/marketData';\nimport { technicalIndicatorsProvider } from './providers/technicalIndicators';\nimport { historicalDataProvider } from './providers/historicalData';\n\n// Services\nimport { AnalyticsService } from './services/analyticsService';\nimport { MarketDataService } from './services/marketDataService';\nimport { TechnicalAnalysisService } from './services/technicalAnalysisService';\n\nexport const analyticsPlugin: Plugin = {\n    name: 'analytics',\n    description: 'Comprehensive analytics platform integrating data from multiple providers (Birdeye, CoinMarketCap, Codex) with advanced technical indicators, historical analysis, and account-specific insights',\n    evaluators: [],\n    providers: [\n        analyticsProvider,\n        marketDataProvider,\n        technicalIndicatorsProvider,\n        historicalDataProvider\n    ],\n    actions: [\n//         getTokenAnalytics,\n//         getAccountAnalytics,\n//         getMarketAnalytics,\n//         getHistoricalAnalytics,\n//         getTechnicalIndicators\n    ],\n    services: [\n        AnalyticsService,\n        MarketDataService,\n        TechnicalAnalysisService\n    ],\n};\n\nexport default analyticsPlugin;"
  ],
  "mappings": "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",
  "debugId": "7AB75AF12F1D1A0E64756E2164756E21",
  "names": []
}