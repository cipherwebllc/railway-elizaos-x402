var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/providers/coinmarketcapProvider.ts
var exports_coinmarketcapProvider = {};
__export(exports_coinmarketcapProvider, {
  CoinMarketCapProvider: () => CoinMarketCapProvider
});

class CoinMarketCapProvider {
  runtime;
  apiKey;
  constructor(runtime) {
    this.runtime = runtime;
    this.apiKey = runtime.getSetting("COINMARKETCAP_API_KEY");
    if (!this.apiKey) {
      throw new Error("CoinMarketCap API key not configured");
    }
  }
  async getTokenPrice(tokenAddress, chain = "ethereum") {
    try {
      const cacheKey = `cmc_price_${tokenAddress}_${chain}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "X-CMC_PRO_API_KEY": this.apiKey
        }
      };
      const response = await fetch(`https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/latest?symbol=${tokenAddress}`, options);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const tokenData = data?.data?.[tokenAddress.toUpperCase()]?.[0];
      if (!tokenData) {
        return null;
      }
      const quote = tokenData.quote?.USD;
      if (!quote) {
        return null;
      }
      const priceData = {
        timestamp: Date.now(),
        source: "coinmarketcap",
        chain,
        tokenAddress,
        symbol: tokenData.symbol,
        price: quote.price || 0,
        priceChange24h: quote.volume_change_24h || 0,
        priceChangePercent24h: quote.percent_change_24h || 0,
        volume24h: quote.volume_24h || 0,
        marketCap: quote.market_cap || 0,
        circulatingSupply: tokenData.circulating_supply,
        totalSupply: tokenData.total_supply
      };
      await this.setCachedData(cacheKey, priceData, 300);
      return priceData;
    } catch (error) {
      console.error("Error fetching token price from CoinMarketCap:", error);
      return null;
    }
  }
  async getHistoricalData(tokenAddress, chain = "ethereum", timeframe = "1d") {
    try {
      const cacheKey = `cmc_historical_${tokenAddress}_${timeframe}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "X-CMC_PRO_API_KEY": this.apiKey
        }
      };
      const tokenResponse = await fetch(`https://pro-api.coinmarketcap.com/v1/cryptocurrency/map?symbol=${tokenAddress}`, options);
      if (!tokenResponse.ok) {
        throw new Error(`HTTP error! status: ${tokenResponse.status}`);
      }
      const tokenData = await tokenResponse.json();
      const tokenId = tokenData?.data?.[0]?.id;
      if (!tokenId) {
        return [];
      }
      const count = this.getDataPointsForTimeframe(timeframe);
      const interval = this.convertTimeframeToInterval(timeframe);
      const historicalResponse = await fetch(`https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/historical?id=${tokenId}&count=${count}&interval=${interval}`, options);
      if (!historicalResponse.ok) {
        throw new Error(`HTTP error! status: ${historicalResponse.status}`);
      }
      const historicalData = await historicalResponse.json();
      const quotes = historicalData?.data?.quotes || [];
      const historicalPriceData = quotes.map((quote) => ({
        timestamp: new Date(quote.timestamp).getTime(),
        open: quote.quote.USD.open || 0,
        high: quote.quote.USD.high || 0,
        low: quote.quote.USD.low || 0,
        close: quote.quote.USD.close || 0,
        volume: quote.quote.USD.volume || 0
      }));
      await this.setCachedData(cacheKey, historicalPriceData, 600);
      return historicalPriceData;
    } catch (error) {
      console.error("Error fetching historical data from CoinMarketCap:", error);
      return [];
    }
  }
  async getMarketData(chain = "ethereum") {
    try {
      const cacheKey = `cmc_market_${chain}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "X-CMC_PRO_API_KEY": this.apiKey
        }
      };
      const globalResponse = await fetch("https://pro-api.coinmarketcap.com/v1/global-metrics/quotes/latest", options);
      if (!globalResponse.ok) {
        throw new Error(`HTTP error! status: ${globalResponse.status}`);
      }
      const globalData = await globalResponse.json();
      const globalMetrics = globalData?.data;
      const gainersResponse = await fetch("https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?sort=percent_change_24h&sort_dir=desc&limit=10", options);
      const losersResponse = await fetch("https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?sort=percent_change_24h&sort_dir=asc&limit=10", options);
      const gainersData = await gainersResponse.json();
      const losersData = await losersResponse.json();
      const topGainers = (gainersData?.data || []).map((token) => ({
        timestamp: Date.now(),
        source: "coinmarketcap",
        chain: token.platform?.slug || "L1",
        tokenAddress: token.platform?.token_address || token.slug,
        symbol: token.symbol,
        price: token.quote?.USD?.price || 0,
        priceChange24h: token.quote?.USD?.volume_change_24h || 0,
        priceChangePercent24h: token.quote?.USD?.percent_change_24h || 0,
        volume24h: token.quote?.USD?.volume_24h || 0,
        marketCap: token.quote?.USD?.market_cap || 0
      }));
      const topLosers = (losersData?.data || []).map((token) => ({
        timestamp: Date.now(),
        source: "coinmarketcap",
        chain: token.platform?.slug || "L1",
        tokenAddress: token.platform?.token_address || token.slug,
        symbol: token.symbol,
        price: token.quote?.USD?.price || 0,
        priceChange24h: token.quote?.USD?.volume_change_24h || 0,
        priceChangePercent24h: token.quote?.USD?.percent_change_24h || 0,
        volume24h: token.quote?.USD?.volume_24h || 0,
        marketCap: token.quote?.USD?.market_cap || 0
      }));
      const trendingResponse = await fetch("https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?sort=volume_24h&sort_dir=desc&limit=20", options);
      const trendingData = await trendingResponse.json();
      const trendingTokens = (trendingData?.data || []).map((token) => ({
        timestamp: Date.now(),
        source: "coinmarketcap",
        chain: token.platform?.slug || "L1",
        tokenAddress: token.platform?.token_address || token.slug,
        symbol: token.symbol,
        price: token.quote?.USD?.price || 0,
        priceChange24h: token.quote?.USD?.volume_change_24h || 0,
        priceChangePercent24h: token.quote?.USD?.percent_change_24h || 0,
        volume24h: token.quote?.USD?.volume_24h || 0,
        marketCap: token.quote?.USD?.market_cap || 0
      }));
      const marketAnalytics = {
        marketCap: globalMetrics?.quote?.USD?.total_market_cap || 0,
        volume24h: globalMetrics?.quote?.USD?.total_volume_24h || 0,
        dominance: 0,
        topGainers,
        topLosers,
        trendingTokens,
        marketSentiment: {
          bullish: 0.5,
          bearish: 0.3,
          neutral: 0.2
        }
      };
      await this.setCachedData(cacheKey, marketAnalytics, 600);
      return marketAnalytics;
    } catch (error) {
      console.error("Error fetching market data from CoinMarketCap:", error);
      return null;
    }
  }
  async getAccountData(walletAddress, chain = "ethereum") {
    console.warn("CoinMarketCap does not provide account data");
    return null;
  }
  convertTimeframeToInterval(timeframe) {
    switch (timeframe) {
      case "1h":
        return "1h";
      case "4h":
        return "4h";
      case "1d":
        return "1d";
      case "1w":
        return "1w";
      case "1m":
        return "1M";
      default:
        return "1d";
    }
  }
  getDataPointsForTimeframe(timeframe) {
    switch (timeframe) {
      case "1h":
        return 168;
      case "4h":
        return 168;
      case "1d":
        return 365;
      case "1w":
        return 52;
      case "1m":
        return 12;
      default:
        return 30;
    }
  }
  async getCachedData(key) {
    try {
      return await this.runtime.getCache(key);
    } catch (error) {
      return null;
    }
  }
  async setCachedData(key, data, ttlSeconds) {
    try {
      await this.runtime.setCache(key, data);
    } catch (error) {
      console.error("Failed to cache data:", error);
    }
  }
}

// src/services/analyticsService.ts
import { logger, Service } from "@elizaos/core";

// src/utils/technicalAnalysis.ts
function calculateSMA(prices, period) {
  if (prices.length < period)
    return [];
  const sma = [];
  for (let i = period - 1;i < prices.length; i++) {
    const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
    sma.push(sum / period);
  }
  return sma;
}
function calculateEMA(prices, period) {
  if (prices.length < period)
    return [];
  const ema = [];
  const multiplier = 2 / (period + 1);
  let sum = 0;
  for (let i = 0;i < period; i++) {
    sum += prices[i];
  }
  ema.push(sum / period);
  for (let i = period;i < prices.length; i++) {
    const newEMA = prices[i] * multiplier + ema[ema.length - 1] * (1 - multiplier);
    ema.push(newEMA);
  }
  return ema;
}
function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  if (prices.length < slowPeriod) {
    return { macd: [], signal: [], histogram: [] };
  }
  const fastEMA = calculateEMA(prices, fastPeriod);
  const slowEMA = calculateEMA(prices, slowPeriod);
  const macd = [];
  const startIndex = slowPeriod - fastPeriod;
  for (let i = 0;i < fastEMA.length; i++) {
    const slowIndex = i + startIndex;
    if (slowIndex < slowEMA.length) {
      macd.push(fastEMA[i] - slowEMA[slowIndex]);
    }
  }
  const signal = calculateEMA(macd, signalPeriod);
  const histogram = [];
  for (let i = 0;i < signal.length; i++) {
    const macdIndex = i + signalPeriod - 1;
    if (macdIndex < macd.length) {
      histogram.push(macd[macdIndex] - signal[i]);
    }
  }
  return { macd, signal, histogram };
}
function calculateRSI(prices, period = 14) {
  if (prices.length < period + 1)
    return [];
  const rsi = [];
  const gains = [];
  const losses = [];
  for (let i = 1;i < prices.length; i++) {
    const change = prices[i] - prices[i - 1];
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? Math.abs(change) : 0);
  }
  let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
  const rs = avgGain / avgLoss;
  rsi.push(100 - 100 / (1 + rs));
  for (let i = period;i < gains.length; i++) {
    avgGain = (avgGain * (period - 1) + gains[i]) / period;
    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    const rs2 = avgGain / avgLoss;
    rsi.push(100 - 100 / (1 + rs2));
  }
  return rsi;
}
function calculateBollingerBands(prices, period = 20, standardDeviations = 2) {
  if (prices.length < period) {
    return { upper: [], middle: [], lower: [], bandwidth: [], percentB: [] };
  }
  const middle = calculateSMA(prices, period);
  const upper = [];
  const lower = [];
  const bandwidth = [];
  const percentB = [];
  for (let i = 0;i < middle.length; i++) {
    const startIndex = i;
    const endIndex = startIndex + period;
    const slice = prices.slice(startIndex, endIndex);
    const mean = middle[i];
    const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
    const stdDev = Math.sqrt(variance);
    const upperBand = mean + standardDeviations * stdDev;
    const lowerBand = mean - standardDeviations * stdDev;
    upper.push(upperBand);
    lower.push(lowerBand);
    bandwidth.push((upperBand - lowerBand) / mean);
    const currentPrice = prices[endIndex - 1];
    const percentBValue = (currentPrice - lowerBand) / (upperBand - lowerBand);
    percentB.push(percentBValue);
  }
  return { upper, middle, lower, bandwidth, percentB };
}
function calculateVolumeIndicators(prices, volumes, period = 20) {
  if (prices.length !== volumes.length || prices.length < period) {
    return { volumeSMA: [], volumeRatio: [], onBalanceVolume: [] };
  }
  const volumeSMA = calculateSMA(volumes, period);
  const volumeRatio = [];
  for (let i = period - 1;i < volumes.length; i++) {
    volumeRatio.push(volumes[i] / volumeSMA[i - period + 1]);
  }
  const onBalanceVolume = [];
  let obv = 0;
  for (let i = 0;i < prices.length; i++) {
    if (i === 0) {
      obv = volumes[i];
    } else {
      if (prices[i] > prices[i - 1]) {
        obv += volumes[i];
      } else if (prices[i] < prices[i - 1]) {
        obv -= volumes[i];
      }
    }
    onBalanceVolume.push(obv);
  }
  return { volumeSMA, volumeRatio, onBalanceVolume };
}
function generateSignals(prices, volumes, highs, lows) {
  if (prices.length < 50) {
    return {
      macdSignal: "hold",
      rsiSignal: "hold",
      bbSignal: "hold",
      volumeSignal: "hold",
      overallSignal: "hold",
      confidence: 0
    };
  }
  const { macd, signal, histogram } = calculateMACD(prices);
  const rsi = calculateRSI(prices);
  const { upper, middle, lower, percentB } = calculateBollingerBands(prices);
  const { volumeRatio } = calculateVolumeIndicators(prices, volumes);
  const currentPrice = prices[prices.length - 1];
  const currentMACD = macd[macd.length - 1];
  const currentSignal = signal[signal.length - 1];
  const currentHistogram = histogram[histogram.length - 1];
  const currentRSI = rsi[rsi.length - 1];
  const currentPercentB = percentB[percentB.length - 1];
  const currentVolumeRatio = volumeRatio[volumeRatio.length - 1];
  let macdSignal = "hold";
  if (currentMACD > currentSignal && currentHistogram > 0) {
    macdSignal = "buy";
  } else if (currentMACD < currentSignal && currentHistogram < 0) {
    macdSignal = "sell";
  }
  let rsiSignal = "hold";
  if (currentRSI < 30) {
    rsiSignal = "buy";
  } else if (currentRSI > 70) {
    rsiSignal = "sell";
  }
  let bbSignal = "hold";
  if (currentPercentB < 0.2) {
    bbSignal = "buy";
  } else if (currentPercentB > 0.8) {
    bbSignal = "sell";
  }
  let volumeSignal = "hold";
  if (currentVolumeRatio > 1.5) {
    volumeSignal = "buy";
  } else if (currentVolumeRatio < 0.5) {
    volumeSignal = "sell";
  }
  let buySignals = 0;
  let sellSignals = 0;
  if (macdSignal === "buy")
    buySignals++;
  if (macdSignal === "sell")
    sellSignals++;
  if (rsiSignal === "buy")
    buySignals++;
  if (rsiSignal === "sell")
    sellSignals++;
  if (bbSignal === "buy")
    buySignals++;
  if (bbSignal === "sell")
    sellSignals++;
  if (volumeSignal === "buy")
    buySignals++;
  if (volumeSignal === "sell")
    sellSignals++;
  let overallSignal = "hold";
  if (buySignals > sellSignals && buySignals >= 2) {
    overallSignal = "buy";
  } else if (sellSignals > buySignals && sellSignals >= 2) {
    overallSignal = "sell";
  }
  const totalSignals = buySignals + sellSignals;
  const confidence = totalSignals > 0 ? Math.max(buySignals, sellSignals) / totalSignals * 100 : 0;
  return {
    macdSignal,
    rsiSignal,
    bbSignal,
    volumeSignal,
    overallSignal,
    confidence
  };
}

// src/services/analyticsService.ts
class AnalyticsService extends Service {
  isRunning = false;
  static serviceType = "ANALYTICS_SERVICE";
  capabilityDescription = "Comprehensive analytics service for token and market data analysis";
  constructor(runtime) {
    super(runtime);
  }
  async getTokenAnalytics(request) {
    try {
      const { tokenAddress, chain = "solana", timeframe = "1d", includeHistorical = true, includeHolders = true, includeSnipers = true } = request;
      if (!tokenAddress) {
        return {
          success: false,
          data: null,
          timestamp: Date.now(),
          source: "analytics",
          error: "Token address is required"
        };
      }
      const priceData = await this.getTokenPriceFromExistingProviders(tokenAddress, chain);
      if (!priceData) {
        return {
          success: false,
          data: null,
          timestamp: Date.now(),
          source: "analytics",
          error: "Unable to fetch price data"
        };
      }
      let historicalData = [];
      console.log("includeHistorical", includeHistorical);
      if (includeHistorical) {
        historicalData = await this.getHistoricalDataFromExistingProviders(tokenAddress, chain, timeframe);
      }
      const technicalIndicators = await this.calculateTechnicalIndicators(historicalData);
      let holderAnalytics = null;
      if (includeHolders) {
        holderAnalytics = await this.getHolderAnalyticsFromCodex(tokenAddress);
      }
      let sniperAnalytics = null;
      if (includeSnipers) {
        sniperAnalytics = await this.getSniperAnalyticsFromCodex(tokenAddress);
      }
      const riskAssessment = this.calculateRiskAssessment(technicalIndicators, holderAnalytics, priceData);
      const recommendations = this.generateRecommendations(technicalIndicators, holderAnalytics, priceData, historicalData);
      const comprehensiveAnalytics = {
        tokenAddress,
        symbol: priceData.symbol,
        name: priceData.symbol,
        chain,
        price: priceData,
        technicalIndicators,
        historicalData,
        holderAnalytics: holderAnalytics || undefined,
        sniperAnalytics: sniperAnalytics || undefined,
        marketPosition: {
          rank: 0,
          marketCap: priceData.marketCap,
          volume24h: priceData.volume24h,
          dominance: 0
        },
        riskAssessment,
        recommendations
      };
      return {
        success: true,
        data: comprehensiveAnalytics,
        timestamp: Date.now(),
        source: "analytics"
      };
    } catch (error) {
      console.error("Error in getTokenAnalytics:", error);
      return {
        success: false,
        data: null,
        timestamp: Date.now(),
        source: "analytics",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async getAccountAnalytics(request) {
    try {
      const { walletAddress, chain = "solana" } = request;
      if (!walletAddress) {
        return {
          success: false,
          data: null,
          timestamp: Date.now(),
          source: "analytics",
          error: "Wallet address is required"
        };
      }
      const accountData = await this.getAccountDataFromExistingProviders(walletAddress, chain);
      if (!accountData) {
        return {
          success: false,
          data: null,
          timestamp: Date.now(),
          source: "analytics",
          error: "Unable to fetch account data"
        };
      }
      return {
        success: true,
        data: accountData,
        timestamp: Date.now(),
        source: "analytics"
      };
    } catch (error) {
      console.error("Error in getAccountAnalytics:", error);
      return {
        success: false,
        data: null,
        timestamp: Date.now(),
        source: "analytics",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async getMarketAnalytics(request) {
    try {
      const { chain = "solana" } = request;
      const marketData = await this.getMarketDataFromExistingProviders(chain);
      if (!marketData) {
        return {
          success: false,
          data: null,
          timestamp: Date.now(),
          source: "analytics",
          error: "Unable to fetch market data"
        };
      }
      return {
        success: true,
        data: marketData,
        timestamp: Date.now(),
        source: "analytics"
      };
    } catch (error) {
      console.error("Error in getMarketAnalytics:", error);
      return {
        success: false,
        data: null,
        timestamp: Date.now(),
        source: "analytics",
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async getTokenPriceFromExistingProviders(tokenAddress, chain) {
    try {
      const birdeyeTokens = await this.runtime.getCache("tokens_solana");
      if (birdeyeTokens) {
        const token = birdeyeTokens.find((t) => t.address === tokenAddress);
        if (token) {
          return {
            timestamp: Date.now(),
            source: "birdeye",
            chain,
            tokenAddress,
            symbol: token.symbol,
            price: token.price || 0,
            priceChange24h: 0,
            priceChangePercent24h: token.price24hChangePercent || 0,
            volume24h: token.volume24hUSD || 0,
            marketCap: token.marketcap || 0
          };
        }
      }
      const cmcTokens = await this.runtime.getCache("coinmarketcap_sync");
      if (cmcTokens) {
        const token = cmcTokens.find((t) => t.address === tokenAddress);
        if (token) {
          return {
            timestamp: Date.now(),
            source: "coinmarketcap",
            chain,
            tokenAddress,
            symbol: token.symbol,
            price: token.price || 0,
            priceChange24h: 0,
            priceChangePercent24h: token.price24hChangePercent || 0,
            volume24h: token.volume24hUSD || 0,
            marketCap: token.marketcap || 0
          };
        }
      }
      console.log(`Token ${tokenAddress} not found in cache, attempting to fetch fresh data...`);
      if (chain === "solana") {
        try {
          const birdeyeService = this.runtime.getService("birdeye");
          if (birdeyeService && typeof birdeyeService.getTokenMarketData === "function") {
            console.log(`Attempting to fetch from Birdeye plugin service for ${tokenAddress}...`);
            const priceData = await birdeyeService.getTokenMarketData(tokenAddress);
            if (priceData && priceData.price > 0) {
              console.log(`Successfully fetched price data from Birdeye plugin for ${tokenAddress}: $${priceData.price}`);
              return {
                timestamp: Date.now(),
                source: "birdeye",
                chain,
                tokenAddress,
                symbol: "UNKNOWN",
                price: priceData.price,
                priceChange24h: 0,
                priceChangePercent24h: 0,
                volume24h: priceData.volume24h || 0,
                marketCap: priceData.marketCap || 0
              };
            } else {
              console.warn(`Birdeye plugin service returned null or zero price for token ${tokenAddress}`);
            }
          } else {
            console.warn("Birdeye plugin service not available");
          }
        } catch (error) {
          console.warn(`Failed to fetch from Birdeye plugin service for ${tokenAddress}:`, error);
        }
      }
      try {
        const cmcApiKey = this.runtime.getSetting("COINMARKETCAP_API_KEY");
        if (cmcApiKey) {
          const { CoinMarketCapProvider: CoinMarketCapProvider2 } = await Promise.resolve().then(() => exports_coinmarketcapProvider);
          const cmcProvider = new CoinMarketCapProvider2(this.runtime);
          const priceData = await cmcProvider.getTokenPrice(tokenAddress, chain);
          if (priceData) {
            console.log(`Successfully fetched price data from CoinMarketCap for ${tokenAddress}`);
            return priceData;
          }
        }
      } catch (error) {
        console.warn(`Failed to fetch from CoinMarketCap for ${tokenAddress}:`, error);
      }
      if (chain === "solana") {
        try {
          const jupiterService = this.runtime.getService("JUPITER_SERVICE");
          if (jupiterService && typeof jupiterService.getTokenPrice === "function") {
            console.log(`Attempting to fetch price from Jupiter for ${tokenAddress}...`);
            let price = 0;
            const amounts = [1e6, 1e7, 1e8];
            for (const amount of amounts) {
              try {
                console.log(`Trying Jupiter with amount ${amount}...`);
                price = await jupiterService.getTokenPrice(tokenAddress, "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", 6);
                if (price > 0) {
                  console.log(`Successfully fetched price data from Jupiter for ${tokenAddress}: $${price}`);
                  break;
                }
              } catch (amountError) {
                console.warn(`Jupiter failed with amount ${amount}:`, amountError);
                continue;
              }
            }
            if (price > 0) {
              return {
                timestamp: Date.now(),
                source: "jupiter",
                chain,
                tokenAddress,
                symbol: "UNKNOWN",
                price,
                priceChange24h: 0,
                priceChangePercent24h: 0,
                volume24h: 0,
                marketCap: 0
              };
            } else {
              console.warn(`Jupiter returned price 0 for token ${tokenAddress} with all amounts`);
            }
          } else {
            console.warn("Jupiter service not available or getTokenPrice method not found");
          }
        } catch (error) {
          console.warn(`Failed to fetch from Jupiter for ${tokenAddress}:`, error);
        }
      }
      try {
        const communityInvestorService = this.runtime.getService("COMMUNITY_INVESTOR_SERVICE");
        if (communityInvestorService && typeof communityInvestorService.getCurrentPrice === "function") {
          console.log(`Attempting to fetch price from CommunityInvestorService for ${tokenAddress}...`);
          const price = await communityInvestorService.getCurrentPrice(chain, tokenAddress);
          if (price > 0) {
            console.log(`Successfully fetched price data from CommunityInvestorService for ${tokenAddress}: $${price}`);
            return {
              timestamp: Date.now(),
              source: "community_investor",
              chain,
              tokenAddress,
              symbol: "UNKNOWN",
              price,
              priceChange24h: 0,
              priceChangePercent24h: 0,
              volume24h: 0,
              marketCap: 0
            };
          } else {
            console.warn(`CommunityInvestorService returned price 0 for token ${tokenAddress}`);
          }
        } else {
          console.warn("CommunityInvestorService not available or getCurrentPrice method not found");
        }
      } catch (error) {
        console.warn(`Failed to fetch from CommunityInvestorService for ${tokenAddress}:`, error);
      }
      console.warn(`Unable to fetch price data for token ${tokenAddress} from any provider`);
      return null;
    } catch (error) {
      console.error("Error getting token price from existing providers:", error);
      return null;
    }
  }
  async getHistoricalDataFromExistingProviders(tokenAddress, chain, timeframe) {
    try {
      console.log(`Fetching historical data for ${tokenAddress} on ${chain} with timeframe ${timeframe}`);
      const birdeyeService = this.runtime.getService("birdeye");
      if (!birdeyeService || typeof birdeyeService.getTokenMarketData !== "function") {
        console.warn("Birdeye service not available");
        return [];
      }
      const birdeyeApiKey = this.runtime.getSetting("BIRDEYE_API_KEY");
      if (!birdeyeApiKey) {
        console.warn("BIRDEYE_API_KEY not configured, cannot fetch historical data");
        return [];
      }
      console.log("Birdeye API key found, using Birdeye service...");
      const marketData = await birdeyeService.getTokenMarketData(tokenAddress);
      if (!marketData || !marketData.priceHistory || marketData.priceHistory.length === 0) {
        console.warn(`No historical data found for token ${tokenAddress}`);
        return [];
      }
      const historicalData = marketData.priceHistory.map((price, index) => ({
        timestamp: Date.now() - (marketData.priceHistory.length - index) * 15 * 60 * 1000,
        open: price,
        high: price,
        low: price,
        close: price,
        volume: 0
      }));
      console.log(`Fetched ${historicalData.length} historical data points for ${tokenAddress}`);
      if (historicalData.length > 0) {
        console.log(`Sample data point:`, historicalData[0]);
      }
      return historicalData;
    } catch (error) {
      console.error("Error fetching historical data from Birdeye service:", error);
      return [];
    }
  }
  async getHolderAnalyticsFromCodex(tokenAddress) {
    try {
      const codexApiKey = this.runtime.getSetting("CODEX_API_KEY");
      if (!codexApiKey) {
        return null;
      }
      return null;
    } catch (error) {
      console.error("Error getting holder analytics from Codex:", error);
      return null;
    }
  }
  async getSniperAnalyticsFromCodex(tokenAddress) {
    try {
      const codexApiKey = this.runtime.getSetting("CODEX_API_KEY");
      if (!codexApiKey) {
        return null;
      }
      return null;
    } catch (error) {
      console.error("Error getting sniper analytics from Codex:", error);
      return null;
    }
  }
  async getAccountDataFromExistingProviders(walletAddress, chain) {
    try {
      const portfolioData = await this.runtime.getCache("portfolio");
      if (!portfolioData || portfolioData.wallet !== walletAddress) {
        return null;
      }
      const portfolio = portfolioData.data;
      const trades = await this.runtime.getCache("transaction_history") || [];
      const accountAnalytics = {
        walletAddress,
        totalValue: portfolio.totalUsd || 0,
        totalValueChange24h: 0,
        totalValueChangePercent24h: 0,
        portfolio: portfolio.items?.map((item) => ({
          tokenAddress: item.address,
          symbol: item.symbol,
          balance: item.balance || 0,
          value: item.value || 0,
          valueChange24h: 0,
          allocation: item.value > 0 ? item.value / portfolio.totalUsd * 100 : 0
        })) || [],
        performance: {
          totalPnL: 0,
          totalPnLPercent: 0,
          bestPerformer: "",
          worstPerformer: "",
          riskMetrics: {
            sharpeRatio: 0,
            maxDrawdown: 0,
            volatility: 0
          }
        },
        tradingHistory: {
          totalTrades: trades.length,
          winningTrades: 0,
          losingTrades: 0,
          winRate: 0,
          averageTradeSize: 0
        }
      };
      return accountAnalytics;
    } catch (error) {
      console.error("Error getting account data from existing providers:", error);
      return null;
    }
  }
  async getMarketDataFromExistingProviders(chain) {
    try {
      let topGainers = [];
      let topLosers = [];
      let trendingTokens = [];
      const birdeyeTokens = await this.runtime.getCache("tokens_solana");
      if (birdeyeTokens && birdeyeTokens.length > 0) {
        trendingTokens = birdeyeTokens.slice(0, 20).map((token) => ({
          timestamp: Date.now(),
          source: "birdeye",
          chain,
          tokenAddress: token.address,
          symbol: token.symbol,
          price: token.price || 0,
          priceChange24h: 0,
          priceChangePercent24h: token.price24hChangePercent || 0,
          volume24h: token.volume24hUSD || 0,
          marketCap: token.marketcap || 0
        }));
        const sortedTokens = [...birdeyeTokens].sort((a, b) => (b.price24hChangePercent || 0) - (a.price24hChangePercent || 0));
        topGainers = sortedTokens.slice(0, 10).map((token) => ({
          timestamp: Date.now(),
          source: "birdeye",
          chain,
          tokenAddress: token.address,
          symbol: token.symbol,
          price: token.price || 0,
          priceChange24h: 0,
          priceChangePercent24h: token.price24hChangePercent || 0,
          volume24h: token.volume24hUSD || 0,
          marketCap: token.marketcap || 0
        }));
        topLosers = sortedTokens.slice(-10).map((token) => ({
          timestamp: Date.now(),
          source: "birdeye",
          chain,
          tokenAddress: token.address,
          symbol: token.symbol,
          price: token.price || 0,
          priceChange24h: 0,
          priceChangePercent24h: token.price24hChangePercent || 0,
          volume24h: token.volume24hUSD || 0,
          marketCap: token.marketcap || 0
        }));
      }
      const cmcTokens = await this.runtime.getCache("coinmarketcap_sync");
      if (cmcTokens && cmcTokens.length > 0) {
        if (trendingTokens.length < 20) {
          const cmcTrending = cmcTokens.slice(0, 20 - trendingTokens.length).map((token) => ({
            timestamp: Date.now(),
            source: "coinmarketcap",
            chain,
            tokenAddress: token.address,
            symbol: token.symbol,
            price: token.price || 0,
            priceChange24h: 0,
            priceChangePercent24h: token.price24hChangePercent || 0,
            volume24h: token.volume24hUSD || 0,
            marketCap: token.marketcap || 0
          }));
          trendingTokens.push(...cmcTrending);
        }
      }
      const marketAnalytics = {
        marketCap: 0,
        volume24h: 0,
        dominance: 0,
        topGainers,
        topLosers,
        trendingTokens,
        marketSentiment: {
          bullish: 0.5,
          bearish: 0.3,
          neutral: 0.2
        }
      };
      return marketAnalytics;
    } catch (error) {
      console.error("Error getting market data from existing providers:", error);
      return null;
    }
  }
  async calculateTechnicalIndicators(historicalData) {
    console.log(`Calculating technical indicators with ${historicalData.length} data points`);
    if (historicalData.length < 50) {
      console.warn(`Insufficient historical data: ${historicalData.length} points (need at least 50)`);
      return {
        macd: { macd: 0, signal: 0, histogram: 0, bullish: false },
        rsi: { value: 50, overbought: false, oversold: false },
        bollingerBands: { upper: 0, middle: 0, lower: 0, bandwidth: 0, percentB: 0.5 },
        movingAverages: { sma20: 0, sma50: 0, sma200: 0, ema12: 0, ema26: 0 },
        volume: { volumeSMA: 0, volumeRatio: 1, onBalanceVolume: 0 }
      };
    }
    const prices = historicalData.map((d) => d.close);
    const volumes = historicalData.map((d) => d.volume);
    const highs = historicalData.map((d) => d.high);
    const lows = historicalData.map((d) => d.low);
    console.log(`Sample prices: ${prices.slice(0, 5).join(", ")}...`);
    console.log(`Sample volumes: ${volumes.slice(0, 5).join(", ")}...`);
    const macdResult = calculateMACD(prices);
    const currentMACD = macdResult.macd[macdResult.macd.length - 1] || 0;
    const currentSignal = macdResult.signal[macdResult.signal.length - 1] || 0;
    const currentHistogram = macdResult.histogram[macdResult.histogram.length - 1] || 0;
    console.log(`MACD calculation: MACD=${currentMACD}, Signal=${currentSignal}, Histogram=${currentHistogram}`);
    const rsiResult = calculateRSI(prices);
    const currentRSI = rsiResult[rsiResult.length - 1] || 50;
    console.log(`RSI calculation: ${currentRSI}`);
    const bbResult = calculateBollingerBands(prices);
    const currentBB = {
      upper: bbResult.upper[bbResult.upper.length - 1] || 0,
      middle: bbResult.middle[bbResult.middle.length - 1] || 0,
      lower: bbResult.lower[bbResult.lower.length - 1] || 0,
      bandwidth: bbResult.bandwidth[bbResult.bandwidth.length - 1] || 0,
      percentB: bbResult.percentB[bbResult.percentB.length - 1] || 0.5
    };
    console.log(`Bollinger Bands: Upper=${currentBB.upper}, Middle=${currentBB.middle}, Lower=${currentBB.lower}, %B=${currentBB.percentB}`);
    const sma20 = calculateSMA2(prices, 20);
    const sma50 = calculateSMA2(prices, 50);
    const sma200 = calculateSMA2(prices, 200);
    const ema12 = calculateEMA2(prices, 12);
    const ema26 = calculateEMA2(prices, 26);
    console.log(`Moving Averages: SMA20=${sma20[sma20.length - 1] || 0}, SMA50=${sma50[sma50.length - 1] || 0}, EMA12=${ema12[ema12.length - 1] || 0}`);
    const volumeResult = calculateVolumeIndicators(prices, volumes);
    console.log(`Volume indicators: VolumeSMA=${volumeResult.volumeSMA[volumeResult.volumeSMA.length - 1] || 0}, VolumeRatio=${volumeResult.volumeRatio[volumeResult.volumeRatio.length - 1] || 1}`);
    return {
      macd: {
        macd: currentMACD,
        signal: currentSignal,
        histogram: currentHistogram,
        bullish: currentMACD > currentSignal
      },
      rsi: {
        value: currentRSI,
        overbought: currentRSI > 70,
        oversold: currentRSI < 30
      },
      bollingerBands: currentBB,
      movingAverages: {
        sma20: sma20[sma20.length - 1] || 0,
        sma50: sma50[sma50.length - 1] || 0,
        sma200: sma200[sma200.length - 1] || 0,
        ema12: ema12[ema12.length - 1] || 0,
        ema26: ema26[ema26.length - 1] || 0
      },
      volume: {
        volumeSMA: volumeResult.volumeSMA[volumeResult.volumeSMA.length - 1] || 0,
        volumeRatio: volumeResult.volumeRatio[volumeResult.volumeRatio.length - 1] || 1,
        onBalanceVolume: volumeResult.onBalanceVolume[volumeResult.onBalanceVolume.length - 1] || 0
      }
    };
  }
  calculateRiskAssessment(technicalIndicators, holderAnalytics, priceData) {
    let volatility = 0;
    let liquidity = 0;
    let concentrationRisk = "low";
    let technicalRisk = "low";
    let overallRisk = "low";
    if (priceData.priceChangePercent24h) {
      volatility = Math.abs(priceData.priceChangePercent24h);
    }
    if (priceData.volume24h && priceData.marketCap) {
      liquidity = priceData.volume24h / priceData.marketCap * 100;
    }
    if (holderAnalytics) {
      concentrationRisk = holderAnalytics.concentrationRisk;
    }
    if (technicalIndicators.rsi.overbought || technicalIndicators.rsi.oversold) {
      technicalRisk = "moderate";
    }
    if (technicalIndicators.bollingerBands.percentB > 0.8 || technicalIndicators.bollingerBands.percentB < 0.2) {
      technicalRisk = "high";
    }
    let riskScore = 0;
    if (volatility > 50)
      riskScore += 2;
    if (liquidity < 1)
      riskScore += 2;
    if (concentrationRisk === "high")
      riskScore += 2;
    if (technicalRisk === "high")
      riskScore += 1;
    if (riskScore >= 4)
      overallRisk = "high";
    else if (riskScore >= 2)
      overallRisk = "moderate";
    else
      overallRisk = "low";
    return {
      volatility,
      liquidity,
      concentrationRisk,
      technicalRisk,
      overallRisk
    };
  }
  generateRecommendations(technicalIndicators, holderAnalytics, priceData, historicalData) {
    const signals = generateSignals(historicalData.map((d) => d.close), historicalData.map((d) => d.volume), historicalData.map((d) => d.high), historicalData.map((d) => d.low));
    let action = "hold";
    let confidence = 0;
    const reasons = [];
    const priceTargets = {
      shortTerm: priceData.price,
      mediumTerm: priceData.price,
      longTerm: priceData.price
    };
    if (signals.overallSignal === "buy" && signals.confidence > 60) {
      action = "buy";
      confidence = signals.confidence;
      reasons.push("Strong technical buy signals");
    } else if (signals.overallSignal === "sell" && signals.confidence > 60) {
      action = "sell";
      confidence = signals.confidence;
      reasons.push("Strong technical sell signals");
    } else if (signals.overallSignal === "buy" && signals.confidence > 40) {
      action = "accumulate";
      confidence = signals.confidence;
      reasons.push("Moderate technical buy signals");
    }
    if (holderAnalytics) {
      if (holderAnalytics.communityGrowth === "explosive") {
        reasons.push("Explosive community growth");
        confidence += 10;
      } else if (holderAnalytics.communityGrowth === "growing") {
        reasons.push("Growing community");
        confidence += 5;
      }
      if (holderAnalytics.concentrationRisk === "low") {
        reasons.push("Low concentration risk");
        confidence += 5;
      } else if (holderAnalytics.concentrationRisk === "high") {
        reasons.push("High concentration risk");
        confidence -= 10;
      }
    }
    if (historicalData.length > 0) {
      const currentPrice = priceData.price;
      const volatility = Math.abs(priceData.priceChangePercent24h) / 100;
      priceTargets.shortTerm = currentPrice * (1 + volatility * 0.5);
      priceTargets.mediumTerm = currentPrice * (1 + volatility * 1.5);
      priceTargets.longTerm = currentPrice * (1 + volatility * 3);
    }
    confidence = Math.min(confidence, 100);
    return {
      action,
      confidence,
      reasons,
      priceTargets
    };
  }
  static async start(runtime) {
    const service = new AnalyticsService(runtime);
    service.start();
    return service;
  }
  static async stop(runtime) {
    const service = runtime.getService(this.serviceType);
    if (!service) {
      throw new Error(this.serviceType + " service not found");
    }
    service.stop();
  }
  async start() {
    if (this.isRunning) {
      logger.warn("ANALYTICS_SERVICE service is already running");
      return;
    }
    try {
      logger.info("ANALYTICS_SERVICE trading service...");
      this.isRunning = true;
      logger.info("ANALYTICS_SERVICE service started successfully");
    } catch (error) {
      logger.error("Error starting ANALYTICS_SERVICE service:", error);
      throw error;
    }
  }
  async stop() {
    if (!this.isRunning) {
      logger.warn("ANALYTICS_SERVICE service is not running");
      return;
    }
    try {
      logger.info("Stopping ANALYTICS_SERVICE service...");
      this.isRunning = false;
      logger.info("ANALYTICS_SERVICE stopped successfully");
    } catch (error) {
      logger.error("Error stopping ANALYTICS_SERVICE service:", error);
      throw error;
    }
  }
  isServiceRunning() {
    return this.isRunning;
  }
}
function calculateSMA2(prices, period) {
  if (prices.length < period)
    return [];
  const sma = [];
  for (let i = period - 1;i < prices.length; i++) {
    const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
    sma.push(sum / period);
  }
  return sma;
}
function calculateEMA2(prices, period) {
  if (prices.length < period)
    return [];
  const ema = [];
  const multiplier = 2 / (period + 1);
  let sum = 0;
  for (let i = 0;i < period; i++) {
    sum += prices[i];
  }
  ema.push(sum / period);
  for (let i = period;i < prices.length; i++) {
    const newEMA = prices[i] * multiplier + ema[ema.length - 1] * (1 - multiplier);
    ema.push(newEMA);
  }
  return ema;
}

// src/utils/messageUtils.ts
async function getWalletsFromText(runtime, message) {
  const text = message.content?.text || "";
  const addresses = [];
  const solanaPattern = /\b[1-9A-HJ-NP-Za-km-z]{32,44}\b/g;
  const solanaMatches = text.match(solanaPattern) || [];
  addresses.push(...solanaMatches);
  const evmPattern = /\b0x[a-fA-F0-9]{40}\b/g;
  const evmMatches = text.match(evmPattern) || [];
  addresses.push(...evmMatches);
  return [...new Set(addresses)];
}
async function getAccountFromMessage(runtime, message) {
  try {
    const wallets = await getWalletsFromText(runtime, message);
    return {
      userId: message.entityId || message.userId,
      walletAddress: wallets.length > 0 ? wallets[0] : undefined,
      visualOutput: true
    };
  } catch (error) {
    console.warn("Error getting account from message:", error);
    return null;
  }
}

// src/utils/dateFilter.ts
function parseDateFilterFromMessage(messageText) {
  if (!messageText)
    return null;
  const text = messageText.toLowerCase();
  const now = new Date;
  const lastPeriodMatch = text.match(/last\s+(\d+)\s+(day|days|hour|hours|week|weeks|month|months)/i);
  if (lastPeriodMatch) {
    const amount = parseInt(lastPeriodMatch[1]);
    const unit = lastPeriodMatch[2].replace(/s$/, "");
    const startDate = new Date(now);
    switch (unit) {
      case "hour":
        startDate.setHours(startDate.getHours() - amount);
        break;
      case "day":
        startDate.setDate(startDate.getDate() - amount);
        break;
      case "week":
        startDate.setDate(startDate.getDate() - amount * 7);
        break;
      case "month":
        startDate.setMonth(startDate.getMonth() - amount);
        break;
    }
    return {
      startDate,
      endDate: now,
      period: `${amount} ${unit}${amount > 1 ? "s" : ""}`,
      type: "period"
    };
  }
  if (text.includes("today")) {
    const startOfDay = new Date(now);
    startOfDay.setHours(0, 0, 0, 0);
    return {
      startDate: startOfDay,
      endDate: now,
      period: "today",
      type: "period"
    };
  }
  if (text.includes("this week")) {
    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay());
    startOfWeek.setHours(0, 0, 0, 0);
    return {
      startDate: startOfWeek,
      endDate: now,
      period: "this week",
      type: "period"
    };
  }
  if (text.includes("this month")) {
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    return {
      startDate: startOfMonth,
      endDate: now,
      period: "this month",
      type: "period"
    };
  }
  const sinceMatch = text.match(/since\s+(\d{4}-\d{2}-\d{2})/i);
  if (sinceMatch) {
    return {
      startDate: new Date(sinceMatch[1]),
      endDate: now,
      type: "since"
    };
  }
  const untilMatch = text.match(/until\s+(\d{4}-\d{2}-\d{2})/i);
  if (untilMatch) {
    return {
      endDate: new Date(untilMatch[1]),
      type: "until"
    };
  }
  const rangeMatch = text.match(/from\s+(\d{4}-\d{2}-\d{2})\s+to\s+(\d{4}-\d{2}-\d{2})/i);
  if (rangeMatch) {
    return {
      startDate: new Date(rangeMatch[1]),
      endDate: new Date(rangeMatch[2]),
      type: "range"
    };
  }
  return null;
}
function formatDateFilterText(filter) {
  if (!filter)
    return "";
  if (filter.period) {
    return `Last ${filter.period}`;
  }
  if (filter.type === "range" && filter.startDate && filter.endDate) {
    return `${formatDate(filter.startDate)} to ${formatDate(filter.endDate)}`;
  }
  if (filter.type === "since" && filter.startDate) {
    return `Since ${formatDate(filter.startDate)}`;
  }
  if (filter.type === "until" && filter.endDate) {
    return `Until ${formatDate(filter.endDate)}`;
  }
  return "";
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

// src/providers/analytics.ts
var analyticsProvider = {
  name: "ANALYTICS",
  description: "Comprehensive analytics platform providing token analysis, technical indicators, holder analytics, market data, and account insights from multiple data providers (Birdeye, CoinMarketCap, Codex)",
  dynamic: true,
  get: async (runtime, message, state) => {
    console.log("ANALYTICS");
    let analyticsStr = "";
    const isDM = message.content.channelType?.toUpperCase() === "DM";
    if (isDM) {
      const account = await getAccountFromMessage(runtime, message);
      if (!account) {
        return {
          data: {},
          values: {},
          text: "No account found for this user."
        };
      }
      const analyticsService = new AnalyticsService(runtime);
      const messageText = message.content?.text?.toLowerCase() || "";
      const dateFilter = parseDateFilterFromMessage(messageText);
      analyticsStr += `=== COMPREHENSIVE ANALYTICS REPORT ===
`;
      if (dateFilter) {
        analyticsStr += `\uD83D\uDCC5 Date Filter: ${formatDateFilterText(dateFilter)}

`;
      }
      const uniqueTokens = new Set;
      if (account.walletAddress) {
        uniqueTokens.add(account.walletAddress);
      }
      if (uniqueTokens.size === 0) {
        analyticsStr += `No token positions found for analysis.
`;
      } else {
        analyticsStr += `Analyzing ${uniqueTokens.size} unique tokens from your positions...

`;
        for (const tokenAddress of uniqueTokens) {
          analyticsStr += await analyzeTokenComprehensive(analyticsService, tokenAddress, dateFilter);
          analyticsStr += `
` + "=".repeat(50) + `

`;
        }
        analyticsStr += await analyzePortfolio(analyticsService, account, dateFilter);
      }
      analyticsStr += await getMarketOverview(analyticsService);
    } else {
      analyticsStr = "Comprehensive analytics are only available in private messages.";
    }
    console.log("analyticsStr", analyticsStr);
    const data = {
      comprehensiveAnalytics: analyticsStr
    };
    const values = {};
    const text = analyticsStr + `
`;
    return {
      data,
      values,
      text
    };
  }
};
async function analyzeTokenComprehensive(analyticsService, tokenAddress, dateFilter) {
  let analysis = `\uD83D\uDD0D COMPREHENSIVE TOKEN ANALYSIS: ${tokenAddress}
`;
  try {
    const request = {
      tokenAddress,
      chain: "solana",
      timeframe: "1d",
      includeHistorical: true,
      includeHolders: true,
      includeSnipers: true
    };
    const response = await analyticsService.getTokenAnalytics(request);
    if (!response.success || !response.data) {
      analysis += `❌ Error analyzing token: ${response.error || "Unknown error"}
`;
      return analysis;
    }
    const tokenData = response.data;
    analysis += `\uD83D\uDCB0 PRICE ANALYSIS:
`;
    analysis += `  • Current Price: $${tokenData.price.price.toFixed(6)}
`;
    analysis += `  • 24h Change: ${tokenData.price.priceChangePercent24h >= 0 ? "+" : ""}${tokenData.price.priceChangePercent24h.toFixed(2)}%
`;
    analysis += `  • 24h Volume: $${tokenData.price.volume24h.toLocaleString()}
`;
    analysis += `  • Market Cap: $${tokenData.price.marketCap.toLocaleString()}

`;
    analysis += `\uD83D\uDCCA TECHNICAL INDICATORS:
`;
    const tech = tokenData.technicalIndicators;
    analysis += `  • MACD: ${tech.macd.bullish ? "\uD83D\uDFE2 Bullish" : "\uD83D\uDD34 Bearish"} (${tech.macd.macd.toFixed(6)})
`;
    analysis += `  • RSI: ${tech.rsi.value.toFixed(2)} ${tech.rsi.overbought ? "(Overbought)" : tech.rsi.oversold ? "(Oversold)" : "(Neutral)"}
`;
    analysis += `  • Bollinger Bands: ${tech.bollingerBands.percentB.toFixed(2)} (${tech.bollingerBands.percentB > 0.8 ? "Upper" : tech.bollingerBands.percentB < 0.2 ? "Lower" : "Middle"})
`;
    analysis += `  • Volume Ratio: ${tech.volume.volumeRatio.toFixed(2)}x average

`;
    analysis += `\uD83D\uDCC8 MOVING AVERAGES:
`;
    analysis += `  • SMA 20: $${tech.movingAverages.sma20.toFixed(6)}
`;
    analysis += `  • SMA 50: $${tech.movingAverages.sma50.toFixed(6)}
`;
    analysis += `  • SMA 200: $${tech.movingAverages.sma200.toFixed(6)}
`;
    analysis += `  • EMA 12: $${tech.movingAverages.ema12.toFixed(6)}
`;
    analysis += `  • EMA 26: $${tech.movingAverages.ema26.toFixed(6)}

`;
    if (tokenData.holderAnalytics) {
      analysis += `\uD83D\uDC65 HOLDER ANALYTICS:
`;
      const holders = tokenData.holderAnalytics;
      analysis += `  • Total Holders: ${holders.totalHolders.toLocaleString()}
`;
      analysis += `  • Concentration Risk: ${holders.concentrationRisk.toUpperCase()}
`;
      analysis += `  • Community Growth: ${holders.communityGrowth.toUpperCase()}
`;
      analysis += `  • Acquisition Methods:
`;
      analysis += `    - Swaps: ${(holders.holdersByAcquisition.swap / holders.totalHolders * 100).toFixed(1)}%
`;
      analysis += `    - Transfers: ${(holders.holdersByAcquisition.transfer / holders.totalHolders * 100).toFixed(1)}%
`;
      analysis += `    - Airdrops: ${(holders.holdersByAcquisition.airdrop / holders.totalHolders * 100).toFixed(1)}%

`;
    }
    if (tokenData.sniperAnalytics) {
      analysis += `\uD83C\uDFAF SNIPER ACTIVITY:
`;
      const snipers = tokenData.sniperAnalytics;
      analysis += `  • Active Snipers: ${snipers.activeSnipers}
`;
      analysis += `  • Total Sniped: $${snipers.totalSnipedUsd.toLocaleString()}
`;
      analysis += `  • Total Sold: $${snipers.totalSoldUsd.toLocaleString()}
`;
      analysis += `  • Total Profit: $${snipers.totalProfitUsd.toLocaleString()}
`;
      analysis += `  • Average Profit: ${snipers.averageProfitPercent >= 0 ? "+" : ""}${snipers.averageProfitPercent.toFixed(2)}%

`;
    }
    analysis += `⚠️ RISK ASSESSMENT:
`;
    const risk = tokenData.riskAssessment;
    analysis += `  • Overall Risk: ${risk.overallRisk.toUpperCase()}
`;
    analysis += `  • Volatility: ${risk.volatility.toFixed(2)}%
`;
    analysis += `  • Liquidity: ${risk.liquidity.toFixed(2)}%
`;
    analysis += `  • Concentration Risk: ${risk.concentrationRisk.toUpperCase()}
`;
    analysis += `  • Technical Risk: ${risk.technicalRisk.toUpperCase()}

`;
    analysis += `\uD83D\uDCA1 RECOMMENDATIONS:
`;
    const rec = tokenData.recommendations;
    analysis += `  • Action: ${rec.action.toUpperCase()}
`;
    analysis += `  • Confidence: ${rec.confidence.toFixed(0)}%
`;
    analysis += `  • Reasons: ${rec.reasons.join(", ")}
`;
    analysis += `  • Price Targets:
`;
    analysis += `    - Short Term: $${rec.priceTargets.shortTerm.toFixed(6)}
`;
    analysis += `    - Medium Term: $${rec.priceTargets.mediumTerm.toFixed(6)}
`;
    analysis += `    - Long Term: $${rec.priceTargets.longTerm.toFixed(6)}

`;
  } catch (error) {
    analysis += `❌ Error in comprehensive analysis: ${error}
`;
  }
  return analysis;
}
async function analyzePortfolio(analyticsService, account, dateFilter) {
  let analysis = `\uD83D\uDCCA PORTFOLIO ANALYSIS
`;
  try {
    const request = {
      walletAddress: account.walletAddress || "unknown",
      chain: "solana"
    };
    const response = await analyticsService.getAccountAnalytics(request);
    if (!response.success || !response.data) {
      analysis += `❌ Error analyzing portfolio: ${response.error || "Unknown error"}

`;
      return analysis;
    }
    const portfolioData = response.data;
    analysis += `\uD83D\uDCB0 PORTFOLIO OVERVIEW:
`;
    analysis += `  • Total Value: $${portfolioData.totalValue.toLocaleString()}
`;
    analysis += `  • 24h Change: ${portfolioData.totalValueChangePercent24h >= 0 ? "+" : ""}${portfolioData.totalValueChangePercent24h.toFixed(2)}%
`;
    analysis += `  • Total PnL: ${portfolioData.performance.totalPnLPercent >= 0 ? "+" : ""}${portfolioData.performance.totalPnLPercent.toFixed(2)}%

`;
    analysis += `\uD83D\uDCC8 PERFORMANCE METRICS:
`;
    analysis += `  • Best Performer: ${portfolioData.performance.bestPerformer}
`;
    analysis += `  • Worst Performer: ${portfolioData.performance.worstPerformer}
`;
    analysis += `  • Sharpe Ratio: ${portfolioData.performance.riskMetrics.sharpeRatio.toFixed(2)}
`;
    analysis += `  • Max Drawdown: ${portfolioData.performance.riskMetrics.maxDrawdown.toFixed(2)}%
`;
    analysis += `  • Volatility: ${portfolioData.performance.riskMetrics.volatility.toFixed(2)}%

`;
    analysis += `\uD83D\uDD04 TRADING HISTORY:
`;
    analysis += `  • Total Trades: ${portfolioData.tradingHistory.totalTrades}
`;
    analysis += `  • Win Rate: ${portfolioData.tradingHistory.winRate.toFixed(1)}%
`;
    analysis += `  • Average Trade Size: $${portfolioData.tradingHistory.averageTradeSize.toLocaleString()}

`;
    analysis += `\uD83C\uDFAF TOP HOLDINGS:
`;
    const sortedPortfolio = portfolioData.portfolio.sort((a, b) => b.value - a.value).slice(0, 5);
    for (let i = 0;i < sortedPortfolio.length; i++) {
      const holding = sortedPortfolio[i];
      analysis += `  ${i + 1}. ${holding.symbol}: $${holding.value.toLocaleString()} (${holding.allocation.toFixed(1)}%)
`;
    }
    analysis += `
`;
  } catch (error) {
    analysis += `❌ Error in portfolio analysis: ${error}

`;
  }
  return analysis;
}
async function getMarketOverview(analyticsService) {
  let analysis = `\uD83C\uDF0D MARKET OVERVIEW
`;
  try {
    const request = {
      chain: "solana"
    };
    const response = await analyticsService.getMarketAnalytics(request);
    if (!response.success || !response.data) {
      analysis += `❌ Error getting market data: ${response.error || "Unknown error"}

`;
      return analysis;
    }
    const marketData = response.data;
    analysis += `\uD83D\uDCCA MARKET METRICS:
`;
    analysis += `  • Total Market Cap: $${marketData.marketCap.toLocaleString()}
`;
    analysis += `  • 24h Volume: $${marketData.volume24h.toLocaleString()}
`;
    analysis += `  • Market Sentiment: ${getSentimentText(marketData.marketSentiment)}

`;
    analysis += `\uD83D\uDE80 TOP GAINERS (24h):
`;
    for (let i = 0;i < Math.min(5, marketData.topGainers.length); i++) {
      const token = marketData.topGainers[i];
      analysis += `  ${i + 1}. ${token.symbol}: +${token.priceChangePercent24h.toFixed(2)}% ($${token.price.toFixed(6)})
`;
    }
    analysis += `
`;
    analysis += `\uD83D\uDCC9 TOP LOSERS (24h):
`;
    for (let i = 0;i < Math.min(5, marketData.topLosers.length); i++) {
      const token = marketData.topLosers[i];
      analysis += `  ${i + 1}. ${token.symbol}: ${token.priceChangePercent24h.toFixed(2)}% ($${token.price.toFixed(6)})
`;
    }
    analysis += `
`;
    analysis += `\uD83D\uDD25 TRENDING TOKENS:
`;
    for (let i = 0;i < Math.min(5, marketData.trendingTokens.length); i++) {
      const token = marketData.trendingTokens[i];
      analysis += `  ${i + 1}. ${token.symbol}: $${token.volume24h.toLocaleString()} volume ($${token.price.toFixed(6)})
`;
    }
    analysis += `
`;
  } catch (error) {
    analysis += `❌ Error in market overview: ${error}

`;
  }
  return analysis;
}
function getSentimentText(sentiment) {
  if (sentiment.bullish > 0.6)
    return "\uD83D\uDFE2 Bullish";
  if (sentiment.bearish > 0.6)
    return "\uD83D\uDD34 Bearish";
  return "\uD83D\uDFE1 Neutral";
}

// src/providers/marketData.ts
var marketDataProvider = {
  name: "MARKET_DATA",
  description: "Real-time market data including top gainers, losers, trending tokens, and market sentiment across multiple chains",
  dynamic: true,
  get: async (runtime, message, state) => {
    console.log("MARKET_DATA");
    let marketStr = "";
    try {
      const analyticsService = new AnalyticsService(runtime);
      const response = await analyticsService.getMarketAnalytics({ chain: "solana" });
      if (response.success && response.data) {
        const marketData = response.data;
        marketStr += `\uD83C\uDF0D MARKET OVERVIEW
`;
        marketStr += `Total Market Cap: $${marketData.marketCap.toLocaleString()}
`;
        marketStr += `24h Volume: $${marketData.volume24h.toLocaleString()}

`;
        marketStr += `\uD83D\uDE80 TOP GAINERS (24h):
`;
        for (let i = 0;i < Math.min(3, marketData.topGainers.length); i++) {
          const token = marketData.topGainers[i];
          marketStr += `${i + 1}. ${token.symbol}: +${token.priceChangePercent24h.toFixed(2)}%
`;
        }
        marketStr += `
`;
        marketStr += `\uD83D\uDCC9 TOP LOSERS (24h):
`;
        for (let i = 0;i < Math.min(3, marketData.topLosers.length); i++) {
          const token = marketData.topLosers[i];
          marketStr += `${i + 1}. ${token.symbol}: ${token.priceChangePercent24h.toFixed(2)}%
`;
        }
        marketStr += `
`;
        marketStr += `\uD83D\uDD25 TRENDING:
`;
        for (let i = 0;i < Math.min(3, marketData.trendingTokens.length); i++) {
          const token = marketData.trendingTokens[i];
          marketStr += `${i + 1}. ${token.symbol}: $${token.volume24h.toLocaleString()} volume
`;
        }
      } else {
        marketStr = "Unable to fetch market data at this time.";
      }
    } catch (error) {
      marketStr = "Error fetching market data.";
    }
    const data = {
      marketData: marketStr
    };
    const values = {};
    const text = marketStr + `
`;
    return {
      data,
      values,
      text
    };
  }
};

// src/providers/technicalIndicators.ts
var technicalIndicatorsProvider = {
  name: "TECHNICAL_INDICATORS",
  description: "Real-time technical indicators including MACD, RSI, Bollinger Bands, moving averages, and trading signals",
  dynamic: true,
  get: async (runtime, message, state) => {
    console.log("TECHNICAL_INDICATORS");
    let technicalStr = "";
    const messageText = message.content?.text || "";
    const tokenMatch = messageText.match(/0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44}/);
    if (tokenMatch) {
      try {
        const birdeyeService = runtime.getService("birdeye");
        if (!birdeyeService || typeof birdeyeService.getTokenMarketData !== "function") {
          technicalStr = "Birdeye service not available for technical analysis.";
        } else {
          const tokenAddress = tokenMatch[0];
          console.log(`Token ${tokenAddress} not found in cache, attempting to fetch fresh data...`);
          const marketData = await birdeyeService.getTokenMarketData(tokenAddress);
          if (marketData && marketData.price > 0) {
            console.log(`Successfully fetched price data from Birdeye plugin for ${tokenAddress}: $${marketData.price}`);
            const price = marketData.price;
            const priceHistory = marketData.priceHistory || [];
            if (priceHistory.length > 0) {
              const sma20 = priceHistory.slice(-20).reduce((sum, p) => sum + p, 0) / Math.min(20, priceHistory.length);
              const sma50 = priceHistory.slice(-50).reduce((sum, p) => sum + p, 0) / Math.min(50, priceHistory.length);
              const recentPrices = priceHistory.slice(-14);
              let gains = 0, losses = 0;
              for (let i = 1;i < recentPrices.length; i++) {
                const change = recentPrices[i] - recentPrices[i - 1];
                if (change > 0)
                  gains += change;
                else
                  losses -= change;
              }
              const avgGain = gains / 14;
              const avgLoss = losses / 14;
              const rs = avgGain / avgLoss;
              const rsi = 100 - 100 / (1 + rs);
              const ema12 = priceHistory.slice(-12).reduce((sum, p) => sum + p, 0) / Math.min(12, priceHistory.length);
              const ema26 = priceHistory.slice(-26).reduce((sum, p) => sum + p, 0) / Math.min(26, priceHistory.length);
              const macd = ema12 - ema26;
              const signal = macd;
              const histogram = macd - signal;
              const stdDev = Math.sqrt(priceHistory.slice(-20).reduce((sum, p) => sum + Math.pow(p - sma20, 2), 0) / Math.min(20, priceHistory.length));
              const upperBand = sma20 + 2 * stdDev;
              const lowerBand = sma20 - 2 * stdDev;
              const percentB = (price - lowerBand) / (upperBand - lowerBand);
              const volumeRatio = marketData.volume24h > 0 ? 1 : 0.5;
              technicalStr += `\uD83D\uDCCA TECHNICAL INDICATORS: ${tokenAddress}

`;
              technicalStr += `\uD83D\uDCC8 MACD: ${macd > signal ? "\uD83D\uDFE2 Bullish" : "\uD83D\uDD34 Bearish"}
`;
              technicalStr += `\uD83D\uDCCA RSI: ${rsi.toFixed(2)} ${rsi > 70 ? "(Overbought)" : rsi < 30 ? "(Oversold)" : "(Neutral)"}
`;
              technicalStr += `\uD83D\uDCCF BB %B: ${percentB.toFixed(3)}
`;
              technicalStr += `\uD83D\uDCCA Volume: ${volumeRatio.toFixed(2)}x average
`;
              technicalStr += `\uD83D\uDCB0 Current Price: $${price.toFixed(6)}
`;
              technicalStr += `\uD83D\uDCC8 SMA20: $${sma20.toFixed(6)}
`;
              technicalStr += `\uD83D\uDCC8 SMA50: $${sma50.toFixed(6)}
`;
            } else {
              technicalStr += `\uD83D\uDCCA TECHNICAL INDICATORS: ${tokenAddress}

`;
              technicalStr += `\uD83D\uDCB0 Current Price: $${price.toFixed(6)}
`;
              technicalStr += `\uD83D\uDCCA Insufficient historical data for full technical analysis.
`;
            }
          } else {
            technicalStr = "Unable to fetch price data for this token.";
          }
        }
      } catch (error) {
        console.error("Error calculating technical indicators:", error);
        technicalStr = "Error calculating technical indicators.";
      }
    } else {
      technicalStr = "Please provide a token address to analyze technical indicators.";
    }
    const data = {
      technicalIndicators: technicalStr
    };
    const values = {};
    const text = technicalStr + `
`;
    return {
      data,
      values,
      text
    };
  }
};

// src/providers/historicalData.ts
var historicalDataProvider = {
  name: "HISTORICAL_DATA",
  description: "Historical price data and trend analysis for tokens across different timeframes",
  dynamic: true,
  get: async (runtime, message, state) => {
    console.log("HISTORICAL_DATA");
    let historicalStr = "";
    const messageText = message.content?.text || "";
    const tokenMatch = messageText.match(/0x[a-fA-F0-9]{40}|[1-9A-HJ-NP-Za-km-z]{32,44}/);
    if (tokenMatch) {
      try {
        const analyticsService = new AnalyticsService(runtime);
        const response = await analyticsService.getTokenAnalytics({
          tokenAddress: tokenMatch[0],
          chain: "solana",
          timeframe: "1d",
          includeHistorical: true,
          includeHolders: false,
          includeSnipers: false
        });
        if (response.success && response.data && "historicalData" in response.data && response.data.historicalData.length > 0) {
          const historicalData = response.data.historicalData;
          const firstPrice = historicalData[0].close;
          const lastPrice = historicalData[historicalData.length - 1].close;
          const totalChange = (lastPrice - firstPrice) / firstPrice * 100;
          historicalStr += `\uD83D\uDCC8 HISTORICAL DATA: ${response.data.symbol}

`;
          historicalStr += `Period: ${historicalData.length} days
`;
          historicalStr += `Start Price: $${firstPrice.toFixed(6)}
`;
          historicalStr += `End Price: $${lastPrice.toFixed(6)}
`;
          historicalStr += `Total Change: ${totalChange >= 0 ? "+" : ""}${totalChange.toFixed(2)}%
`;
        } else {
          historicalStr = "No historical data available for this token.";
        }
      } catch (error) {
        historicalStr = "Error fetching historical data.";
      }
    } else {
      historicalStr = "Please provide a token address to analyze historical data.";
    }
    const data = {
      historicalData: historicalStr
    };
    const values = {};
    const text = historicalStr + `
`;
    return {
      data,
      values,
      text
    };
  }
};

// src/services/marketDataService.ts
import { logger as logger2, Service as Service2 } from "@elizaos/core";

// src/providers/birdeyeProvider.ts
class BirdeyeProvider {
  runtime;
  apiKey;
  API_BASE_URL = "https://public-api.birdeye.so";
  constructor(runtime) {
    this.runtime = runtime;
    this.apiKey = runtime.getSetting("BIRDEYE_API_KEY");
    if (!this.apiKey) {
      throw new Error("Birdeye API key not configured");
    }
  }
  async getTokenPrice(tokenAddress, chain = "solana") {
    try {
      const cacheKey = `birdeye_price_${tokenAddress}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      console.log(`Fetching price for token ${tokenAddress} from Birdeye API...`);
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "x-chain": chain,
          "X-API-KEY": this.apiKey
        }
      };
      let url = `${this.API_BASE_URL}/defi/price?address=${tokenAddress}`;
      console.log(`Making request to: ${url}`);
      let response = await fetch(url, options);
      if (!response.ok || response.status === 404) {
        console.log(`Main price endpoint failed, trying token overview endpoint...`);
        url = `${this.API_BASE_URL}/defi/token_overview?address=${tokenAddress}`;
        console.log(`Making request to: ${url}`);
        response = await fetch(url, options);
      }
      console.log(`Birdeye API response status: ${response.status}`);
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Birdeye API error response: ${errorText}`);
        throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
      }
      const responseText = await response.text();
      console.log(`Birdeye API raw response: ${responseText}`);
      if (!responseText || responseText.trim() === "") {
        console.warn(`Birdeye API returned empty response for token ${tokenAddress}`);
        return null;
      }
      let data;
      try {
        data = JSON.parse(responseText);
        console.log(`Birdeye API response data:`, JSON.stringify(data, null, 2));
      } catch (parseError) {
        console.error(`Failed to parse Birdeye API response as JSON: ${responseText}`);
        return null;
      }
      let tokenData = data?.data;
      if (!tokenData) {
        console.warn(`No token data found in Birdeye response for ${tokenAddress}`);
        return null;
      }
      const priceData = {
        timestamp: Date.now(),
        source: "birdeye",
        chain,
        tokenAddress,
        symbol: tokenData.symbol || tokenData.name || "UNKNOWN",
        price: tokenData.value || tokenData.price || 0,
        priceChange24h: tokenData.priceChange24h || 0,
        priceChangePercent24h: tokenData.priceChangePercent24h || tokenData.priceChangePercent || 0,
        volume24h: tokenData.volume24h || tokenData.volume || 0,
        marketCap: tokenData.marketCap || tokenData.marketcap || 0,
        circulatingSupply: tokenData.circulatingSupply || tokenData.circulating_supply,
        totalSupply: tokenData.totalSupply || tokenData.total_supply
      };
      console.log(`Successfully parsed price data: $${priceData.price} for ${tokenData.symbol}`);
      await this.setCachedData(cacheKey, priceData, 60);
      return priceData;
    } catch (error) {
      console.error("Error fetching token price from Birdeye:", error);
      return null;
    }
  }
  async getHistoricalData(tokenAddress, chain = "solana", timeframe = "1d") {
    try {
      const cacheKey = `birdeye_historical_${tokenAddress}_${timeframe}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "x-chain": chain,
          "X-API-KEY": this.apiKey
        }
      };
      const interval = this.convertTimeframeToInterval(timeframe);
      const url = `${this.API_BASE_URL}/defi/history_price?address=${tokenAddress}&address_type=token&type=${interval}`;
      console.log(`Fetching historical data from: ${url}`);
      const response = await fetch(url, options);
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Birdeye historical API error: ${errorText}`);
        throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
      }
      const data = await response.json();
      console.log(`Historical data response:`, JSON.stringify(data, null, 2));
      if (!data.success || !data.data || !data.data.items) {
        console.warn(`No historical data found for token ${tokenAddress}`);
        return [];
      }
      const historyData = data.data.items;
      console.log(`Found ${historyData.length} historical data points`);
      const historicalData = historyData.map((item) => ({
        timestamp: item.unixTime ? item.unixTime * 1000 : Date.now(),
        open: item.o || item.open || item.value || 0,
        high: item.h || item.high || item.value || 0,
        low: item.l || item.low || item.value || 0,
        close: item.c || item.close || item.value || 0,
        volume: item.v || item.volume || 0
      }));
      await this.setCachedData(cacheKey, historicalData, 300);
      return historicalData;
    } catch (error) {
      console.error("Error fetching historical data from Birdeye:", error);
      return [];
    }
  }
  async getOHLCVData(tokenAddress, chain = "solana", timeframe = "1d") {
    try {
      const cacheKey = `birdeye_ohlcv_${tokenAddress}_${timeframe}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "x-chain": chain,
          "X-API-KEY": this.apiKey
        }
      };
      const interval = this.convertTimeframeToInterval(timeframe);
      const url = `${this.API_BASE_URL}/defi/ohlcv?address=${tokenAddress}&type=${interval}`;
      console.log(`Fetching OHLCV data from: ${url}`);
      const response = await fetch(url, options);
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Birdeye OHLCV API error: ${errorText}`);
        throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
      }
      const data = await response.json();
      console.log(`OHLCV data response:`, JSON.stringify(data, null, 2));
      if (!data.success || !data.data || !data.data.items) {
        console.warn(`No OHLCV data found for token ${tokenAddress}, falling back to historical price data`);
        return this.getHistoricalData(tokenAddress, chain, timeframe);
      }
      const ohlcvData = data.data.items;
      console.log(`Found ${ohlcvData.length} OHLCV data points`);
      const historicalData = ohlcvData.map((item) => ({
        timestamp: item.unixTime ? item.unixTime * 1000 : Date.now(),
        open: item.o || 0,
        high: item.h || 0,
        low: item.l || 0,
        close: item.c || 0,
        volume: item.v || 0
      }));
      await this.setCachedData(cacheKey, historicalData, 300);
      return historicalData;
    } catch (error) {
      console.error("Error fetching OHLCV data from Birdeye:", error);
      return this.getHistoricalData(tokenAddress, chain, timeframe);
    }
  }
  async getMarketData(chain = "solana") {
    try {
      const cacheKey = `birdeye_market_${chain}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "x-chain": chain,
          "X-API-KEY": this.apiKey
        }
      };
      const trendingResponse = await fetch(`${this.API_BASE_URL}/defi/token_trending?sort_by=rank&sort_type=asc&offset=0&limit=20`, options);
      if (!trendingResponse.ok) {
        throw new Error(`HTTP error! status: ${trendingResponse.status}`);
      }
      const trendingData = await trendingResponse.json();
      const trendingTokens = trendingData?.data?.tokens || [];
      const gainersResponse = await fetch(`${this.API_BASE_URL}/defi/token_trending?sort_by=priceChangePercent24h&sort_type=desc&offset=0&limit=10`, options);
      const losersResponse = await fetch(`${this.API_BASE_URL}/defi/token_trending?sort_by=priceChangePercent24h&sort_type=asc&offset=0&limit=10`, options);
      const gainersData = await gainersResponse.json();
      const losersData = await losersResponse.json();
      const topGainers = (gainersData?.data?.tokens || []).map((token) => ({
        timestamp: Date.now(),
        source: "birdeye",
        chain,
        tokenAddress: token.address,
        symbol: token.symbol,
        price: token.price || 0,
        priceChange24h: token.priceChange24h || 0,
        priceChangePercent24h: token.priceChangePercent24h || 0,
        volume24h: token.volume24h || 0,
        marketCap: token.marketCap || 0
      }));
      const topLosers = (losersData?.data?.tokens || []).map((token) => ({
        timestamp: Date.now(),
        source: "birdeye",
        chain,
        tokenAddress: token.address,
        symbol: token.symbol,
        price: token.price || 0,
        priceChange24h: token.priceChange24h || 0,
        priceChangePercent24h: token.priceChangePercent24h || 0,
        volume24h: token.volume24h || 0,
        marketCap: token.marketCap || 0
      }));
      const trendingTokensData = trendingTokens.map((token) => ({
        timestamp: Date.now(),
        source: "birdeye",
        chain,
        tokenAddress: token.address,
        symbol: token.symbol,
        price: token.price || 0,
        priceChange24h: token.priceChange24h || 0,
        priceChangePercent24h: token.priceChangePercent24h || 0,
        volume24h: token.volume24h || 0,
        marketCap: token.marketCap || 0
      }));
      const marketAnalytics = {
        marketCap: 0,
        volume24h: 0,
        dominance: 0,
        topGainers,
        topLosers,
        trendingTokens: trendingTokensData,
        marketSentiment: {
          bullish: 0.6,
          bearish: 0.2,
          neutral: 0.2
        }
      };
      await this.setCachedData(cacheKey, marketAnalytics, 300);
      return marketAnalytics;
    } catch (error) {
      console.error("Error fetching market data from Birdeye:", error);
      return null;
    }
  }
  async getAccountData(walletAddress, chain = "solana") {
    try {
      const cacheKey = `birdeye_account_${walletAddress}`;
      const cached = await this.getCachedData(cacheKey);
      if (cached)
        return cached;
      const options = {
        method: "GET",
        headers: {
          accept: "application/json",
          "x-chain": chain,
          "X-API-KEY": this.apiKey
        }
      };
      const portfolioResponse = await fetch(`${this.API_BASE_URL}/v1/wallet/token_list?wallet=${walletAddress}`, options);
      if (!portfolioResponse.ok) {
        throw new Error(`HTTP error! status: ${portfolioResponse.status}`);
      }
      const portfolioData = await portfolioResponse.json();
      const tokens = portfolioData?.data || [];
      const valueResponse = await fetch(`${this.API_BASE_URL}/v1/wallet/portfolio?wallet=${walletAddress}`, options);
      const valueData = await valueResponse.json();
      const portfolioValue = valueData?.data?.value || 0;
      const portfolio = tokens.map((token) => ({
        tokenAddress: token.address,
        symbol: token.symbol,
        balance: token.balance || 0,
        value: token.value || 0,
        valueChange24h: token.valueChange24h || 0,
        allocation: token.value > 0 ? token.value / portfolioValue * 100 : 0
      }));
      const accountAnalytics = {
        walletAddress,
        totalValue: portfolioValue,
        totalValueChange24h: 0,
        totalValueChangePercent24h: 0,
        portfolio,
        performance: {
          totalPnL: 0,
          totalPnLPercent: 0,
          bestPerformer: portfolio.length > 0 ? portfolio[0].symbol : "",
          worstPerformer: portfolio.length > 0 ? portfolio[0].symbol : "",
          riskMetrics: {
            sharpeRatio: 0,
            maxDrawdown: 0,
            volatility: 0
          }
        },
        tradingHistory: {
          totalTrades: 0,
          winningTrades: 0,
          losingTrades: 0,
          winRate: 0,
          averageTradeSize: 0
        }
      };
      await this.setCachedData(cacheKey, accountAnalytics, 300);
      return accountAnalytics;
    } catch (error) {
      console.error("Error fetching account data from Birdeye:", error);
      return null;
    }
  }
  convertTimeframeToInterval(timeframe) {
    switch (timeframe) {
      case "1m":
        return "1m";
      case "3m":
        return "3m";
      case "5m":
        return "5m";
      case "15m":
        return "15m";
      case "30m":
        return "30m";
      case "1h":
        return "1H";
      case "2h":
        return "2H";
      case "4h":
        return "4H";
      case "6h":
        return "6H";
      case "8h":
        return "8H";
      case "12h":
        return "12H";
      case "1d":
        return "1D";
      case "3d":
        return "3D";
      case "1w":
        return "1W";
      case "1m":
        return "1M";
      default:
        return "1D";
    }
  }
  getDataPointsForTimeframe(timeframe) {
    switch (timeframe) {
      case "1h":
        return 168;
      case "4h":
        return 168;
      case "1d":
        return 365;
      case "1w":
        return 52;
      case "1m":
        return 12;
      default:
        return 30;
    }
  }
  async getCachedData(key) {
    try {
      return await this.runtime.getCache(key);
    } catch (error) {
      return null;
    }
  }
  async setCachedData(key, data, ttlSeconds) {
    try {
      await this.runtime.setCache(key, data);
    } catch (error) {
      console.error("Failed to cache data:", error);
    }
  }
}

// src/services/marketDataService.ts
class MarketDataService extends Service2 {
  isRunning = false;
  static serviceType = "MARKET_DATA_SERVICE";
  capabilityDescription = "Market data service for token prices and market information";
  birdeyeProvider;
  coinmarketcapProvider;
  constructor(runtime) {
    super(runtime);
    try {
      this.birdeyeProvider = new BirdeyeProvider(runtime);
    } catch (error) {
      console.warn("Birdeye provider not available for market data service");
    }
    try {
      this.coinmarketcapProvider = new CoinMarketCapProvider(runtime);
    } catch (error) {
      console.warn("CoinMarketCap provider not available for market data service");
    }
  }
  async getMarketData(chain = "solana") {
    if (chain === "solana" && this.birdeyeProvider) {
      return await this.birdeyeProvider.getMarketData(chain);
    }
    if (this.coinmarketcapProvider) {
      return await this.coinmarketcapProvider.getMarketData(chain);
    }
    return null;
  }
  async getTokenPrice(tokenAddress, chain = "solana") {
    if (chain === "solana" && this.birdeyeProvider) {
      return await this.birdeyeProvider.getTokenPrice(tokenAddress, chain);
    }
    if (this.coinmarketcapProvider) {
      return await this.coinmarketcapProvider.getTokenPrice(tokenAddress, chain);
    }
    return null;
  }
  static async start(runtime) {
    const service = new MarketDataService(runtime);
    service.start();
    return service;
  }
  static async stop(runtime) {
    const service = runtime.getService(this.serviceType);
    if (!service) {
      throw new Error(this.serviceType + " service not found");
    }
    service.stop();
  }
  async start() {
    if (this.isRunning) {
      logger2.warn("MARKET_DATA_SERVICE service is already running");
      return;
    }
    try {
      logger2.info("MARKET_DATA_SERVICE trading service...");
      this.isRunning = true;
      logger2.info("MARKET_DATA_SERVICE service started successfully");
    } catch (error) {
      logger2.error("Error starting MARKET_DATA_SERVICE service:", error);
      throw error;
    }
  }
  async stop() {
    if (!this.isRunning) {
      logger2.warn("MARKET_DATA_SERVICE service is not running");
      return;
    }
    try {
      logger2.info("Stopping MARKET_DATA_SERVICE service...");
      this.isRunning = false;
      logger2.info("MARKET_DATA_SERVICE stopped successfully");
    } catch (error) {
      logger2.error("Error stopping MARKET_DATA_SERVICE service:", error);
      throw error;
    }
  }
  isServiceRunning() {
    return this.isRunning;
  }
}

// src/services/technicalAnalysisService.ts
import { logger as logger3, Service as Service3 } from "@elizaos/core";
class TechnicalAnalysisService extends Service3 {
  isRunning = false;
  static serviceType = "TECHNICAL_ANALYSIS_SERVICE";
  capabilityDescription = "Technical analysis service for calculating indicators and signals";
  constructor(runtime) {
    super(runtime);
  }
  async getTechnicalIndicators(tokenAddress, chain = "solana") {
    try {
      const birdeyeService = this.runtime.getService("birdeye");
      if (!birdeyeService || typeof birdeyeService.getTokenMarketData !== "function") {
        logger3.warn("Birdeye service not available for technical analysis");
        return this.getEmptyTechnicalIndicators();
      }
      const marketData = await birdeyeService.getTokenMarketData(tokenAddress);
      if (!marketData || marketData.price <= 0) {
        logger3.warn(`No valid price data available for ${tokenAddress}`);
        return this.getEmptyTechnicalIndicators();
      }
      const priceHistory = marketData.priceHistory || [];
      if (priceHistory.length < 50) {
        logger3.warn(`Insufficient price history for ${tokenAddress}: ${priceHistory.length} points (need at least 50)`);
        return this.getEmptyTechnicalIndicators();
      }
      const technicalIndicators = await this.calculateTechnicalIndicatorsFromPrices(priceHistory);
      return {
        success: true,
        data: {
          tokenAddress,
          symbol: "UNKNOWN",
          price: marketData.price,
          volume24h: marketData.volume24h,
          marketCap: marketData.marketCap,
          technicalIndicators
        }
      };
    } catch (error) {
      logger3.error("Error calculating technical indicators:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        data: this.getEmptyTechnicalIndicators()
      };
    }
  }
  async calculateTechnicalIndicatorsFromPrices(prices) {
    if (prices.length < 50) {
      return this.getEmptyTechnicalIndicators();
    }
    const macdResult = calculateMACD(prices);
    const currentMACD = macdResult.macd[macdResult.macd.length - 1] || 0;
    const currentSignal = macdResult.signal[macdResult.signal.length - 1] || 0;
    const currentHistogram = macdResult.histogram[macdResult.histogram.length - 1] || 0;
    const rsiResult = calculateRSI(prices);
    const currentRSI = rsiResult[rsiResult.length - 1] || 50;
    const bbResult = calculateBollingerBands(prices);
    const currentBB = {
      upper: bbResult.upper[bbResult.upper.length - 1] || 0,
      middle: bbResult.middle[bbResult.middle.length - 1] || 0,
      lower: bbResult.lower[bbResult.lower.length - 1] || 0,
      bandwidth: bbResult.bandwidth[bbResult.bandwidth.length - 1] || 0,
      percentB: bbResult.percentB[bbResult.percentB.length - 1] || 0.5
    };
    const sma20 = this.calculateSMA(prices, 20);
    const sma50 = this.calculateSMA(prices, 50);
    const sma200 = this.calculateSMA(prices, 200);
    const ema12 = this.calculateEMA(prices, 12);
    const ema26 = this.calculateEMA(prices, 26);
    const volumeResult = calculateVolumeIndicators(prices, prices);
    return {
      macd: {
        macd: currentMACD,
        signal: currentSignal,
        histogram: currentHistogram,
        bullish: currentMACD > currentSignal
      },
      rsi: {
        value: currentRSI,
        overbought: currentRSI > 70,
        oversold: currentRSI < 30
      },
      bollingerBands: currentBB,
      movingAverages: {
        sma20: sma20[sma20.length - 1] || 0,
        sma50: sma50[sma50.length - 1] || 0,
        sma200: sma200[sma200.length - 1] || 0,
        ema12: ema12[ema12.length - 1] || 0,
        ema26: ema26[ema26.length - 1] || 0
      },
      volume: {
        volumeSMA: volumeResult.volumeSMA[volumeResult.volumeSMA.length - 1] || 0,
        volumeRatio: volumeResult.volumeRatio[volumeResult.volumeRatio.length - 1] || 1,
        onBalanceVolume: volumeResult.onBalanceVolume[volumeResult.onBalanceVolume.length - 1] || 0
      }
    };
  }
  getEmptyTechnicalIndicators() {
    return {
      macd: { macd: 0, signal: 0, histogram: 0, bullish: false },
      rsi: { value: 50, overbought: false, oversold: false },
      bollingerBands: { upper: 0, middle: 0, lower: 0, bandwidth: 0, percentB: 0.5 },
      movingAverages: { sma20: 0, sma50: 0, sma200: 0, ema12: 0, ema26: 0 },
      volume: { volumeSMA: 0, volumeRatio: 1, onBalanceVolume: 0 }
    };
  }
  calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    return calculateMACD(prices, fastPeriod, slowPeriod, signalPeriod);
  }
  calculateRSI(prices, period = 14) {
    return calculateRSI(prices, period);
  }
  calculateBollingerBands(prices, period = 20, standardDeviations = 2) {
    return calculateBollingerBands(prices, period, standardDeviations);
  }
  calculateMovingAverages(prices, periods) {
    const result = {};
    for (const period of periods) {
      result[period] = this.calculateSMA(prices, period);
    }
    return result;
  }
  calculateVolumeIndicators(prices, volumes, period = 20) {
    return calculateVolumeIndicators(prices, volumes, period);
  }
  generateSignals(prices, volumes, highs, lows) {
    return generateSignals(prices, volumes, highs, lows);
  }
  calculateSMA(prices, period) {
    if (prices.length < period)
      return [];
    const sma = [];
    for (let i = period - 1;i < prices.length; i++) {
      const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
      sma.push(sum / period);
    }
    return sma;
  }
  calculateEMA(prices, period) {
    if (prices.length < period)
      return [];
    const ema = [];
    const multiplier = 2 / (period + 1);
    let sum = 0;
    for (let i = 0;i < period; i++) {
      sum += prices[i];
    }
    ema.push(sum / period);
    for (let i = period;i < prices.length; i++) {
      const currentEMA = prices[i] * multiplier + ema[ema.length - 1] * (1 - multiplier);
      ema.push(currentEMA);
    }
    return ema;
  }
  static async start(runtime) {
    const service = new TechnicalAnalysisService(runtime);
    service.start();
    return service;
  }
  static async stop(runtime) {
    const service = runtime.getService(this.serviceType);
    if (!service) {
      throw new Error(this.serviceType + " service not found");
    }
    service.stop();
  }
  async start() {
    if (this.isRunning) {
      logger3.warn("TECHNICAL_ANALYSIS_SERVICE service is already running");
      return;
    }
    try {
      logger3.info("Starting TECHNICAL_ANALYSIS_SERVICE...");
      this.isRunning = true;
      logger3.info("TECHNICAL_ANALYSIS_SERVICE service started successfully");
    } catch (error) {
      logger3.error("Error starting TECHNICAL_ANALYSIS_SERVICE service:", error);
      throw error;
    }
  }
  async stop() {
    if (!this.isRunning) {
      logger3.warn("TECHNICAL_ANALYSIS_SERVICE service is not running");
      return;
    }
    try {
      logger3.info("Stopping TECHNICAL_ANALYSIS_SERVICE service...");
      this.isRunning = false;
      logger3.info("TECHNICAL_ANALYSIS_SERVICE stopped successfully");
    } catch (error) {
      logger3.error("Error stopping TECHNICAL_ANALYSIS_SERVICE service:", error);
      throw error;
    }
  }
  isServiceRunning() {
    return this.isRunning;
  }
}

// src/index.ts
var analyticsPlugin = {
  name: "analytics",
  description: "Comprehensive analytics platform integrating data from multiple providers (Birdeye, CoinMarketCap, Codex) with advanced technical indicators, historical analysis, and account-specific insights",
  evaluators: [],
  providers: [
    analyticsProvider,
    marketDataProvider,
    technicalIndicatorsProvider,
    historicalDataProvider
  ],
  actions: [],
  services: [
    AnalyticsService,
    MarketDataService,
    TechnicalAnalysisService
  ]
};
var src_default = analyticsPlugin;
export {
  src_default as default,
  analyticsPlugin
};

//# debugId=7AB75AF12F1D1A0E64756E2164756E21
